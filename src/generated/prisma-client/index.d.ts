// Code generated by Prisma (prisma@1.28.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  discount: (where?: DiscountWhereInput) => Promise<boolean>;
  game: (where?: GameWhereInput) => Promise<boolean>;
  gameIndex: (where?: GameIndexWhereInput) => Promise<boolean>;
  gamerRequest: (where?: GamerRequestWhereInput) => Promise<boolean>;
  gamingSession: (where?: GamingSessionWhereInput) => Promise<boolean>;
  gamingSessionIndex: (
    where?: GamingSessionIndexWhereInput
  ) => Promise<boolean>;
  individualGamingSession: (
    where?: IndividualGamingSessionWhereInput
  ) => Promise<boolean>;
  requirement: (where?: RequirementWhereInput) => Promise<boolean>;
  sessionReview: (where?: SessionReviewWhereInput) => Promise<boolean>;
  sessionReviewIndex: (
    where?: SessionReviewIndexWhereInput
  ) => Promise<boolean>;
  socialMedia: (where?: SocialMediaWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userIndex: (where?: UserIndexWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  discounts: (
    args?: {
      where?: DiscountWhereInput;
      orderBy?: DiscountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Discount>;
  discountsConnection: (
    args?: {
      where?: DiscountWhereInput;
      orderBy?: DiscountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DiscountConnectionPromise;
  game: (where: GameWhereUniqueInput) => GamePromise;
  games: (
    args?: {
      where?: GameWhereInput;
      orderBy?: GameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Game>;
  gamesConnection: (
    args?: {
      where?: GameWhereInput;
      orderBy?: GameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GameConnectionPromise;
  gameIndex: (where: GameIndexWhereUniqueInput) => GameIndexPromise;
  gameIndexes: (
    args?: {
      where?: GameIndexWhereInput;
      orderBy?: GameIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GameIndex>;
  gameIndexesConnection: (
    args?: {
      where?: GameIndexWhereInput;
      orderBy?: GameIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GameIndexConnectionPromise;
  gamerRequest: (where: GamerRequestWhereUniqueInput) => GamerRequestPromise;
  gamerRequests: (
    args?: {
      where?: GamerRequestWhereInput;
      orderBy?: GamerRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GamerRequest>;
  gamerRequestsConnection: (
    args?: {
      where?: GamerRequestWhereInput;
      orderBy?: GamerRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GamerRequestConnectionPromise;
  gamingSession: (where: GamingSessionWhereUniqueInput) => GamingSessionPromise;
  gamingSessions: (
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GamingSession>;
  gamingSessionsConnection: (
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GamingSessionConnectionPromise;
  gamingSessionIndex: (
    where: GamingSessionIndexWhereUniqueInput
  ) => GamingSessionIndexPromise;
  gamingSessionIndexes: (
    args?: {
      where?: GamingSessionIndexWhereInput;
      orderBy?: GamingSessionIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GamingSessionIndex>;
  gamingSessionIndexesConnection: (
    args?: {
      where?: GamingSessionIndexWhereInput;
      orderBy?: GamingSessionIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GamingSessionIndexConnectionPromise;
  individualGamingSession: (
    where: IndividualGamingSessionWhereUniqueInput
  ) => IndividualGamingSessionPromise;
  individualGamingSessions: (
    args?: {
      where?: IndividualGamingSessionWhereInput;
      orderBy?: IndividualGamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<IndividualGamingSession>;
  individualGamingSessionsConnection: (
    args?: {
      where?: IndividualGamingSessionWhereInput;
      orderBy?: IndividualGamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => IndividualGamingSessionConnectionPromise;
  requirements: (
    args?: {
      where?: RequirementWhereInput;
      orderBy?: RequirementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Requirement>;
  requirementsConnection: (
    args?: {
      where?: RequirementWhereInput;
      orderBy?: RequirementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RequirementConnectionPromise;
  sessionReview: (where: SessionReviewWhereUniqueInput) => SessionReviewPromise;
  sessionReviews: (
    args?: {
      where?: SessionReviewWhereInput;
      orderBy?: SessionReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SessionReview>;
  sessionReviewsConnection: (
    args?: {
      where?: SessionReviewWhereInput;
      orderBy?: SessionReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SessionReviewConnectionPromise;
  sessionReviewIndex: (
    where: SessionReviewIndexWhereUniqueInput
  ) => SessionReviewIndexPromise;
  sessionReviewIndexes: (
    args?: {
      where?: SessionReviewIndexWhereInput;
      orderBy?: SessionReviewIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SessionReviewIndex>;
  sessionReviewIndexesConnection: (
    args?: {
      where?: SessionReviewIndexWhereInput;
      orderBy?: SessionReviewIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SessionReviewIndexConnectionPromise;
  socialMedia: (where: SocialMediaWhereUniqueInput) => SocialMediaPromise;
  socialMedias: (
    args?: {
      where?: SocialMediaWhereInput;
      orderBy?: SocialMediaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SocialMedia>;
  socialMediasConnection: (
    args?: {
      where?: SocialMediaWhereInput;
      orderBy?: SocialMediaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SocialMediaConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userIndex: (where: UserIndexWhereUniqueInput) => UserIndexPromise;
  userIndexes: (
    args?: {
      where?: UserIndexWhereInput;
      orderBy?: UserIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserIndex>;
  userIndexesConnection: (
    args?: {
      where?: UserIndexWhereInput;
      orderBy?: UserIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserIndexConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDiscount: (data: DiscountCreateInput) => DiscountPromise;
  updateManyDiscounts: (
    args: { data: DiscountUpdateManyMutationInput; where?: DiscountWhereInput }
  ) => BatchPayloadPromise;
  deleteManyDiscounts: (where?: DiscountWhereInput) => BatchPayloadPromise;
  createGame: (data: GameCreateInput) => GamePromise;
  updateGame: (
    args: { data: GameUpdateInput; where: GameWhereUniqueInput }
  ) => GamePromise;
  updateManyGames: (
    args: { data: GameUpdateManyMutationInput; where?: GameWhereInput }
  ) => BatchPayloadPromise;
  upsertGame: (
    args: {
      where: GameWhereUniqueInput;
      create: GameCreateInput;
      update: GameUpdateInput;
    }
  ) => GamePromise;
  deleteGame: (where: GameWhereUniqueInput) => GamePromise;
  deleteManyGames: (where?: GameWhereInput) => BatchPayloadPromise;
  createGameIndex: (data: GameIndexCreateInput) => GameIndexPromise;
  updateGameIndex: (
    args: { data: GameIndexUpdateInput; where: GameIndexWhereUniqueInput }
  ) => GameIndexPromise;
  updateManyGameIndexes: (
    args: {
      data: GameIndexUpdateManyMutationInput;
      where?: GameIndexWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGameIndex: (
    args: {
      where: GameIndexWhereUniqueInput;
      create: GameIndexCreateInput;
      update: GameIndexUpdateInput;
    }
  ) => GameIndexPromise;
  deleteGameIndex: (where: GameIndexWhereUniqueInput) => GameIndexPromise;
  deleteManyGameIndexes: (where?: GameIndexWhereInput) => BatchPayloadPromise;
  createGamerRequest: (data: GamerRequestCreateInput) => GamerRequestPromise;
  updateGamerRequest: (
    args: { data: GamerRequestUpdateInput; where: GamerRequestWhereUniqueInput }
  ) => GamerRequestPromise;
  updateManyGamerRequests: (
    args: {
      data: GamerRequestUpdateManyMutationInput;
      where?: GamerRequestWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGamerRequest: (
    args: {
      where: GamerRequestWhereUniqueInput;
      create: GamerRequestCreateInput;
      update: GamerRequestUpdateInput;
    }
  ) => GamerRequestPromise;
  deleteGamerRequest: (
    where: GamerRequestWhereUniqueInput
  ) => GamerRequestPromise;
  deleteManyGamerRequests: (
    where?: GamerRequestWhereInput
  ) => BatchPayloadPromise;
  createGamingSession: (data: GamingSessionCreateInput) => GamingSessionPromise;
  updateGamingSession: (
    args: {
      data: GamingSessionUpdateInput;
      where: GamingSessionWhereUniqueInput;
    }
  ) => GamingSessionPromise;
  updateManyGamingSessions: (
    args: {
      data: GamingSessionUpdateManyMutationInput;
      where?: GamingSessionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGamingSession: (
    args: {
      where: GamingSessionWhereUniqueInput;
      create: GamingSessionCreateInput;
      update: GamingSessionUpdateInput;
    }
  ) => GamingSessionPromise;
  deleteGamingSession: (
    where: GamingSessionWhereUniqueInput
  ) => GamingSessionPromise;
  deleteManyGamingSessions: (
    where?: GamingSessionWhereInput
  ) => BatchPayloadPromise;
  createGamingSessionIndex: (
    data: GamingSessionIndexCreateInput
  ) => GamingSessionIndexPromise;
  updateGamingSessionIndex: (
    args: {
      data: GamingSessionIndexUpdateInput;
      where: GamingSessionIndexWhereUniqueInput;
    }
  ) => GamingSessionIndexPromise;
  updateManyGamingSessionIndexes: (
    args: {
      data: GamingSessionIndexUpdateManyMutationInput;
      where?: GamingSessionIndexWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGamingSessionIndex: (
    args: {
      where: GamingSessionIndexWhereUniqueInput;
      create: GamingSessionIndexCreateInput;
      update: GamingSessionIndexUpdateInput;
    }
  ) => GamingSessionIndexPromise;
  deleteGamingSessionIndex: (
    where: GamingSessionIndexWhereUniqueInput
  ) => GamingSessionIndexPromise;
  deleteManyGamingSessionIndexes: (
    where?: GamingSessionIndexWhereInput
  ) => BatchPayloadPromise;
  createIndividualGamingSession: (
    data: IndividualGamingSessionCreateInput
  ) => IndividualGamingSessionPromise;
  updateIndividualGamingSession: (
    args: {
      data: IndividualGamingSessionUpdateInput;
      where: IndividualGamingSessionWhereUniqueInput;
    }
  ) => IndividualGamingSessionPromise;
  updateManyIndividualGamingSessions: (
    args: {
      data: IndividualGamingSessionUpdateManyMutationInput;
      where?: IndividualGamingSessionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertIndividualGamingSession: (
    args: {
      where: IndividualGamingSessionWhereUniqueInput;
      create: IndividualGamingSessionCreateInput;
      update: IndividualGamingSessionUpdateInput;
    }
  ) => IndividualGamingSessionPromise;
  deleteIndividualGamingSession: (
    where: IndividualGamingSessionWhereUniqueInput
  ) => IndividualGamingSessionPromise;
  deleteManyIndividualGamingSessions: (
    where?: IndividualGamingSessionWhereInput
  ) => BatchPayloadPromise;
  createRequirement: (data: RequirementCreateInput) => RequirementPromise;
  updateManyRequirements: (
    args: {
      data: RequirementUpdateManyMutationInput;
      where?: RequirementWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyRequirements: (
    where?: RequirementWhereInput
  ) => BatchPayloadPromise;
  createSessionReview: (data: SessionReviewCreateInput) => SessionReviewPromise;
  updateSessionReview: (
    args: {
      data: SessionReviewUpdateInput;
      where: SessionReviewWhereUniqueInput;
    }
  ) => SessionReviewPromise;
  updateManySessionReviews: (
    args: {
      data: SessionReviewUpdateManyMutationInput;
      where?: SessionReviewWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSessionReview: (
    args: {
      where: SessionReviewWhereUniqueInput;
      create: SessionReviewCreateInput;
      update: SessionReviewUpdateInput;
    }
  ) => SessionReviewPromise;
  deleteSessionReview: (
    where: SessionReviewWhereUniqueInput
  ) => SessionReviewPromise;
  deleteManySessionReviews: (
    where?: SessionReviewWhereInput
  ) => BatchPayloadPromise;
  createSessionReviewIndex: (
    data: SessionReviewIndexCreateInput
  ) => SessionReviewIndexPromise;
  updateSessionReviewIndex: (
    args: {
      data: SessionReviewIndexUpdateInput;
      where: SessionReviewIndexWhereUniqueInput;
    }
  ) => SessionReviewIndexPromise;
  updateManySessionReviewIndexes: (
    args: {
      data: SessionReviewIndexUpdateManyMutationInput;
      where?: SessionReviewIndexWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSessionReviewIndex: (
    args: {
      where: SessionReviewIndexWhereUniqueInput;
      create: SessionReviewIndexCreateInput;
      update: SessionReviewIndexUpdateInput;
    }
  ) => SessionReviewIndexPromise;
  deleteSessionReviewIndex: (
    where: SessionReviewIndexWhereUniqueInput
  ) => SessionReviewIndexPromise;
  deleteManySessionReviewIndexes: (
    where?: SessionReviewIndexWhereInput
  ) => BatchPayloadPromise;
  createSocialMedia: (data: SocialMediaCreateInput) => SocialMediaPromise;
  updateSocialMedia: (
    args: { data: SocialMediaUpdateInput; where: SocialMediaWhereUniqueInput }
  ) => SocialMediaPromise;
  updateManySocialMedias: (
    args: {
      data: SocialMediaUpdateManyMutationInput;
      where?: SocialMediaWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSocialMedia: (
    args: {
      where: SocialMediaWhereUniqueInput;
      create: SocialMediaCreateInput;
      update: SocialMediaUpdateInput;
    }
  ) => SocialMediaPromise;
  deleteSocialMedia: (where: SocialMediaWhereUniqueInput) => SocialMediaPromise;
  deleteManySocialMedias: (
    where?: SocialMediaWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserIndex: (data: UserIndexCreateInput) => UserIndexPromise;
  updateUserIndex: (
    args: { data: UserIndexUpdateInput; where: UserIndexWhereUniqueInput }
  ) => UserIndexPromise;
  updateManyUserIndexes: (
    args: {
      data: UserIndexUpdateManyMutationInput;
      where?: UserIndexWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserIndex: (
    args: {
      where: UserIndexWhereUniqueInput;
      create: UserIndexCreateInput;
      update: UserIndexUpdateInput;
    }
  ) => UserIndexPromise;
  deleteUserIndex: (where: UserIndexWhereUniqueInput) => UserIndexPromise;
  deleteManyUserIndexes: (where?: UserIndexWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  discount: (
    where?: DiscountSubscriptionWhereInput
  ) => DiscountSubscriptionPayloadSubscription;
  game: (
    where?: GameSubscriptionWhereInput
  ) => GameSubscriptionPayloadSubscription;
  gameIndex: (
    where?: GameIndexSubscriptionWhereInput
  ) => GameIndexSubscriptionPayloadSubscription;
  gamerRequest: (
    where?: GamerRequestSubscriptionWhereInput
  ) => GamerRequestSubscriptionPayloadSubscription;
  gamingSession: (
    where?: GamingSessionSubscriptionWhereInput
  ) => GamingSessionSubscriptionPayloadSubscription;
  gamingSessionIndex: (
    where?: GamingSessionIndexSubscriptionWhereInput
  ) => GamingSessionIndexSubscriptionPayloadSubscription;
  individualGamingSession: (
    where?: IndividualGamingSessionSubscriptionWhereInput
  ) => IndividualGamingSessionSubscriptionPayloadSubscription;
  requirement: (
    where?: RequirementSubscriptionWhereInput
  ) => RequirementSubscriptionPayloadSubscription;
  sessionReview: (
    where?: SessionReviewSubscriptionWhereInput
  ) => SessionReviewSubscriptionPayloadSubscription;
  sessionReviewIndex: (
    where?: SessionReviewIndexSubscriptionWhereInput
  ) => SessionReviewIndexSubscriptionPayloadSubscription;
  socialMedia: (
    where?: SocialMediaSubscriptionWhereInput
  ) => SocialMediaSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userIndex: (
    where?: UserIndexSubscriptionWhereInput
  ) => UserIndexSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type RequirementOrderByInput =
  | "msg_ASC"
  | "msg_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TypeOfGame = "CUSTOM" | "MATCHMAKING";

export type System = "XBOX_ONE" | "NINTENDO_SWITCH" | "PC" | "PS4";

export type DiscountOrderByInput =
  | "percentage_ASC"
  | "percentage_DESC"
  | "threshold_ASC"
  | "threshold_DESC"
  | "playerOrSession_ASC"
  | "playerOrSession_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SessionReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "text_ASC"
  | "text_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "username_ASC"
  | "username_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Tags =
  | "ACTION"
  | "ADVENTURE_GAME"
  | "CARD_AND_BOARD_GAME"
  | "COMPILATION"
  | "DRIVING_SLASH_RACING_GAME"
  | "EDUCATIONAL_GAME"
  | "FIGHTING"
  | "FLIGHT_SIMULATOR"
  | "FPS"
  | "GAMBLING_GAME"
  | "HIDDEN_OBJECTS"
  | "HORROR"
  | "INDIE_GAME"
  | "METROIDVANIA"
  | "MMORPG"
  | "MOBA"
  | "OPEN_WORLD"
  | "PINBALL"
  | "PLATFORMER"
  | "POINT_AND_CLICK"
  | "PUZZLE"
  | "RHYTHM_AND_MUSIC_GAME"
  | "ROGUELIKE"
  | "RPG"
  | "RTS"
  | "SERIES_COLON_SOULS"
  | "SHOOT_HYPHEN_EM_UP"
  | "SHOOTER"
  | "SIMULATION"
  | "SPORTS_GAME"
  | "STEALTH"
  | "STRATEGY"
  | "SURVIVAL"
  | "VISUAL_NOVEL";

export type SessionReviewIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type IndividualGamingSessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "slots_ASC"
  | "slots_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GamerRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "addToOccupations_ASC"
  | "addToOccupations_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GamingSessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "length_ASC"
  | "length_DESC"
  | "price_ASC"
  | "price_DESC"
  | "type_ASC"
  | "type_DESC"
  | "slots_ASC"
  | "slots_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "isGamer_ASC"
  | "isGamer_DESC"
  | "name_ASC"
  | "name_DESC"
  | "aboutMe_ASC"
  | "aboutMe_DESC"
  | "buffer_ASC"
  | "buffer_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Occupations =
  | "CELEBRITY"
  | "INFLUENCER"
  | "ENTERTAINER"
  | "STREAMER"
  | "YOUTUBER"
  | "MEDIA"
  | "SPORTS_PERSONALITY"
  | "INTERNET_PERSONALITY"
  | "ATHLETE"
  | "PROFESIONAL_GAMER"
  | "ACTOR"
  | "COMEDIAN"
  | "ROCK_STAR"
  | "RAPPER"
  | "SINGER"
  | "MUSICIAN"
  | "POLITICIAN"
  | "DJ"
  | "MUSIC_PRODUCER"
  | "ENTREPRENEUR"
  | "ARTIST"
  | "ACTRESS"
  | "MODEL"
  | "ADULT_PERFORMER";

export type GameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "numSessions_ASC"
  | "numSessions_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GameIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GamingSessionIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SocialMediaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "twitter_ASC"
  | "twitter_DESC"
  | "facebook_ASC"
  | "facebook_DESC"
  | "youtube_ASC"
  | "youtube_DESC"
  | "instagram_ASC"
  | "instagram_DESC"
  | "twitch_ASC"
  | "twitch_DESC"
  | "snapchat_ASC"
  | "snapchat_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PlayerOrSession = "PLAYER" | "SESSION";

export interface IndividualGamingSessionUpdateManyWithoutGamersInput {
  create?:
    | IndividualGamingSessionCreateWithoutGamersInput[]
    | IndividualGamingSessionCreateWithoutGamersInput;
  delete?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  connect?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  set?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  disconnect?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  update?:
    | IndividualGamingSessionUpdateWithWhereUniqueWithoutGamersInput[]
    | IndividualGamingSessionUpdateWithWhereUniqueWithoutGamersInput;
  upsert?:
    | IndividualGamingSessionUpsertWithWhereUniqueWithoutGamersInput[]
    | IndividualGamingSessionUpsertWithWhereUniqueWithoutGamersInput;
  deleteMany?:
    | IndividualGamingSessionScalarWhereInput[]
    | IndividualGamingSessionScalarWhereInput;
  updateMany?:
    | IndividualGamingSessionUpdateManyWithWhereNestedInput[]
    | IndividualGamingSessionUpdateManyWithWhereNestedInput;
}

export interface DiscountWhereInput {
  percentage?: Int;
  percentage_not?: Int;
  percentage_in?: Int[] | Int;
  percentage_not_in?: Int[] | Int;
  percentage_lt?: Int;
  percentage_lte?: Int;
  percentage_gt?: Int;
  percentage_gte?: Int;
  threshold?: Int;
  threshold_not?: Int;
  threshold_in?: Int[] | Int;
  threshold_not_in?: Int[] | Int;
  threshold_lt?: Int;
  threshold_lte?: Int;
  threshold_gt?: Int;
  threshold_gte?: Int;
  playerOrSession?: PlayerOrSession;
  playerOrSession_not?: PlayerOrSession;
  playerOrSession_in?: PlayerOrSession[] | PlayerOrSession;
  playerOrSession_not_in?: PlayerOrSession[] | PlayerOrSession;
  AND?: DiscountWhereInput[] | DiscountWhereInput;
  OR?: DiscountWhereInput[] | DiscountWhereInput;
  NOT?: DiscountWhereInput[] | DiscountWhereInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface SessionReviewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  session?: GamingSessionWhereInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: SessionReviewWhereInput[] | SessionReviewWhereInput;
  OR?: SessionReviewWhereInput[] | SessionReviewWhereInput;
  NOT?: SessionReviewWhereInput[] | SessionReviewWhereInput;
}

export interface UserUpdateDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  sessions?: GamingSessionUpdateManyWithoutGamersInput;
  individualSessions?: IndividualGamingSessionUpdateManyWithoutGamersInput;
  sessionsBought?: IndividualGamingSessionUpdateManyWithoutPlayersInput;
  buffer?: Int;
}

export interface RequirementWhereInput {
  msg?: String;
  msg_not?: String;
  msg_in?: String[] | String;
  msg_not_in?: String[] | String;
  msg_lt?: String;
  msg_lte?: String;
  msg_gt?: String;
  msg_gte?: String;
  msg_contains?: String;
  msg_not_contains?: String;
  msg_starts_with?: String;
  msg_not_starts_with?: String;
  msg_ends_with?: String;
  msg_not_ends_with?: String;
  AND?: RequirementWhereInput[] | RequirementWhereInput;
  OR?: RequirementWhereInput[] | RequirementWhereInput;
  NOT?: RequirementWhereInput[] | RequirementWhereInput;
}

export interface GamingSessionCreateManyWithoutGamersInput {
  create?:
    | GamingSessionCreateWithoutGamersInput[]
    | GamingSessionCreateWithoutGamersInput;
  connect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
}

export interface GameIndexUpdateManyMutationInput {
  name?: String;
  tags?: GameIndexUpdatetagsInput;
}

export interface GamingSessionCreateWithoutGamersInput {
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  reviews?: SessionReviewCreateManyWithoutSessionInput;
  systems?: GamingSessionCreatesystemsInput;
  type: TypeOfGame;
  slots: Int;
  requirements?: RequirementCreateManyInput;
  discounts?: DiscountCreateManyInput;
  sessions?: IndividualGamingSessionCreateManyWithoutGamingSessionInput;
}

export interface GamingSessionUpdateManyWithoutGamersInput {
  create?:
    | GamingSessionCreateWithoutGamersInput[]
    | GamingSessionCreateWithoutGamersInput;
  delete?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  connect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  set?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  disconnect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  update?:
    | GamingSessionUpdateWithWhereUniqueWithoutGamersInput[]
    | GamingSessionUpdateWithWhereUniqueWithoutGamersInput;
  upsert?:
    | GamingSessionUpsertWithWhereUniqueWithoutGamersInput[]
    | GamingSessionUpsertWithWhereUniqueWithoutGamersInput;
  deleteMany?: GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput;
  updateMany?:
    | GamingSessionUpdateManyWithWhereNestedInput[]
    | GamingSessionUpdateManyWithWhereNestedInput;
}

export interface GamingSessionCreatesystemsInput {
  set?: System[] | System;
}

export interface GameWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  sessions_every?: GamingSessionWhereInput;
  sessions_some?: GamingSessionWhereInput;
  sessions_none?: GamingSessionWhereInput;
  numSessions?: Int;
  numSessions_not?: Int;
  numSessions_in?: Int[] | Int;
  numSessions_not_in?: Int[] | Int;
  numSessions_lt?: Int;
  numSessions_lte?: Int;
  numSessions_gt?: Int;
  numSessions_gte?: Int;
  AND?: GameWhereInput[] | GameWhereInput;
  OR?: GameWhereInput[] | GameWhereInput;
  NOT?: GameWhereInput[] | GameWhereInput;
}

export interface RequirementCreateManyInput {
  create?: RequirementCreateInput[] | RequirementCreateInput;
}

export interface GamingSessionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  gamers_every?: UserWhereInput;
  gamers_some?: UserWhereInput;
  gamers_none?: UserWhereInput;
  game?: GameWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  length?: Int;
  length_not?: Int;
  length_in?: Int[] | Int;
  length_not_in?: Int[] | Int;
  length_lt?: Int;
  length_lte?: Int;
  length_gt?: Int;
  length_gte?: Int;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  reviews_every?: SessionReviewWhereInput;
  reviews_some?: SessionReviewWhereInput;
  reviews_none?: SessionReviewWhereInput;
  type?: TypeOfGame;
  type_not?: TypeOfGame;
  type_in?: TypeOfGame[] | TypeOfGame;
  type_not_in?: TypeOfGame[] | TypeOfGame;
  slots?: Int;
  slots_not?: Int;
  slots_in?: Int[] | Int;
  slots_not_in?: Int[] | Int;
  slots_lt?: Int;
  slots_lte?: Int;
  slots_gt?: Int;
  slots_gte?: Int;
  requirements_every?: RequirementWhereInput;
  requirements_some?: RequirementWhereInput;
  requirements_none?: RequirementWhereInput;
  discounts_every?: DiscountWhereInput;
  discounts_some?: DiscountWhereInput;
  discounts_none?: DiscountWhereInput;
  sessions_every?: IndividualGamingSessionWhereInput;
  sessions_some?: IndividualGamingSessionWhereInput;
  sessions_none?: IndividualGamingSessionWhereInput;
  AND?: GamingSessionWhereInput[] | GamingSessionWhereInput;
  OR?: GamingSessionWhereInput[] | GamingSessionWhereInput;
  NOT?: GamingSessionWhereInput[] | GamingSessionWhereInput;
}

export interface RequirementCreateInput {
  msg: String;
}

export interface SocialMediaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SocialMediaWhereInput;
  AND?: SocialMediaSubscriptionWhereInput[] | SocialMediaSubscriptionWhereInput;
  OR?: SocialMediaSubscriptionWhereInput[] | SocialMediaSubscriptionWhereInput;
  NOT?: SocialMediaSubscriptionWhereInput[] | SocialMediaSubscriptionWhereInput;
}

export interface DiscountCreateManyInput {
  create?: DiscountCreateInput[] | DiscountCreateInput;
}

export interface SessionReviewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SessionReviewWhereInput;
  AND?:
    | SessionReviewSubscriptionWhereInput[]
    | SessionReviewSubscriptionWhereInput;
  OR?:
    | SessionReviewSubscriptionWhereInput[]
    | SessionReviewSubscriptionWhereInput;
  NOT?:
    | SessionReviewSubscriptionWhereInput[]
    | SessionReviewSubscriptionWhereInput;
}

export interface IndividualGamingSessionCreateManyWithoutGamingSessionInput {
  create?:
    | IndividualGamingSessionCreateWithoutGamingSessionInput[]
    | IndividualGamingSessionCreateWithoutGamingSessionInput;
  connect?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
}

export interface RequirementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RequirementWhereInput;
  AND?: RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput;
  OR?: RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput;
  NOT?: RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput;
}

export interface IndividualGamingSessionCreateWithoutGamingSessionInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamers?: UserCreateManyWithoutIndividualSessionsInput;
  players?: UserCreateManyWithoutSessionsBoughtInput;
  slots: Int;
}

export interface GamingSessionIndexSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GamingSessionIndexWhereInput;
  AND?:
    | GamingSessionIndexSubscriptionWhereInput[]
    | GamingSessionIndexSubscriptionWhereInput;
  OR?:
    | GamingSessionIndexSubscriptionWhereInput[]
    | GamingSessionIndexSubscriptionWhereInput;
  NOT?:
    | GamingSessionIndexSubscriptionWhereInput[]
    | GamingSessionIndexSubscriptionWhereInput;
}

export interface UserCreateManyWithoutIndividualSessionsInput {
  create?:
    | UserCreateWithoutIndividualSessionsInput[]
    | UserCreateWithoutIndividualSessionsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export type GameIndexWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserCreateWithoutIndividualSessionsInput {
  email: String;
  username: String;
  password: String;
  isGamer?: Boolean;
  occupations?: UserCreateoccupationsInput;
  name: String;
  aboutMe?: String;
  favoriteGames?: GameCreateManyInput;
  sessions?: GamingSessionCreateManyWithoutGamersInput;
  sessionsBought?: IndividualGamingSessionCreateManyWithoutPlayersInput;
  buffer?: Int;
}

export interface GameIndexWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  game?: GameWhereInput;
  AND?: GameIndexWhereInput[] | GameIndexWhereInput;
  OR?: GameIndexWhereInput[] | GameIndexWhereInput;
  NOT?: GameIndexWhereInput[] | GameIndexWhereInput;
}

export interface IndividualGamingSessionCreateManyWithoutPlayersInput {
  create?:
    | IndividualGamingSessionCreateWithoutPlayersInput[]
    | IndividualGamingSessionCreateWithoutPlayersInput;
  connect?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
}

export interface GameSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GameWhereInput;
  AND?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
  OR?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
  NOT?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
}

export interface IndividualGamingSessionCreateWithoutPlayersInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamingSession: GamingSessionCreateOneWithoutSessionsInput;
  gamers?: UserCreateManyWithoutIndividualSessionsInput;
  slots: Int;
}

export interface UserIndexUpdateManyMutationInput {
  email?: String;
  username?: String;
  name?: String;
}

export interface UserCreateManyWithoutSessionsBoughtInput {
  create?:
    | UserCreateWithoutSessionsBoughtInput[]
    | UserCreateWithoutSessionsBoughtInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserIndexUpdateInput {
  email?: String;
  username?: String;
  name?: String;
  user?: UserUpdateOneRequiredInput;
}

export interface UserCreateWithoutSessionsBoughtInput {
  email: String;
  username: String;
  password: String;
  isGamer?: Boolean;
  occupations?: UserCreateoccupationsInput;
  name: String;
  aboutMe?: String;
  favoriteGames?: GameCreateManyInput;
  sessions?: GamingSessionCreateManyWithoutGamersInput;
  individualSessions?: IndividualGamingSessionCreateManyWithoutGamersInput;
  buffer?: Int;
}

export interface GamerRequestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  addToOccupations?: String;
  addToOccupations_not?: String;
  addToOccupations_in?: String[] | String;
  addToOccupations_not_in?: String[] | String;
  addToOccupations_lt?: String;
  addToOccupations_lte?: String;
  addToOccupations_gt?: String;
  addToOccupations_gte?: String;
  addToOccupations_contains?: String;
  addToOccupations_not_contains?: String;
  addToOccupations_starts_with?: String;
  addToOccupations_not_starts_with?: String;
  addToOccupations_ends_with?: String;
  addToOccupations_not_ends_with?: String;
  socialMedia?: SocialMediaWhereInput;
  AND?: GamerRequestWhereInput[] | GamerRequestWhereInput;
  OR?: GamerRequestWhereInput[] | GamerRequestWhereInput;
  NOT?: GamerRequestWhereInput[] | GamerRequestWhereInput;
}

export interface GameUpdateInput {
  name?: String;
  tags?: GameUpdatetagsInput;
  sessions?: GamingSessionUpdateManyWithoutGameInput;
  numSessions?: Int;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  buffer?: Int;
}

export interface GameUpdatetagsInput {
  set?: Tags[] | Tags;
}

export interface SocialMediaUpdateManyMutationInput {
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface GamingSessionUpdateManyWithoutGameInput {
  create?:
    | GamingSessionCreateWithoutGameInput[]
    | GamingSessionCreateWithoutGameInput;
  delete?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  connect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  set?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  disconnect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  update?:
    | GamingSessionUpdateWithWhereUniqueWithoutGameInput[]
    | GamingSessionUpdateWithWhereUniqueWithoutGameInput;
  upsert?:
    | GamingSessionUpsertWithWhereUniqueWithoutGameInput[]
    | GamingSessionUpsertWithWhereUniqueWithoutGameInput;
  deleteMany?: GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput;
  updateMany?:
    | GamingSessionUpdateManyWithWhereNestedInput[]
    | GamingSessionUpdateManyWithWhereNestedInput;
}

export type GamingSessionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GamingSessionUpdateWithWhereUniqueWithoutGameInput {
  where: GamingSessionWhereUniqueInput;
  data: GamingSessionUpdateWithoutGameDataInput;
}

export interface SessionReviewUpsertNestedInput {
  update: SessionReviewUpdateDataInput;
  create: SessionReviewCreateInput;
}

export interface GamingSessionUpdateWithoutGameDataInput {
  gamers?: UserUpdateManyWithoutSessionsInput;
  title?: String;
  length?: Int;
  price?: Float;
  reviews?: SessionReviewUpdateManyWithoutSessionInput;
  systems?: GamingSessionUpdatesystemsInput;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
  sessions?: IndividualGamingSessionUpdateManyWithoutGamingSessionInput;
}

export type GamingSessionIndexWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateManyWithoutSessionsInput {
  create?: UserCreateWithoutSessionsInput[] | UserCreateWithoutSessionsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutSessionsInput[]
    | UserUpdateWithWhereUniqueWithoutSessionsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutSessionsInput[]
    | UserUpsertWithWhereUniqueWithoutSessionsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface GamingSessionIndexWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  gamingSession?: GamingSessionWhereInput;
  AND?: GamingSessionIndexWhereInput[] | GamingSessionIndexWhereInput;
  OR?: GamingSessionIndexWhereInput[] | GamingSessionIndexWhereInput;
  NOT?: GamingSessionIndexWhereInput[] | GamingSessionIndexWhereInput;
}

export interface UserUpdateWithWhereUniqueWithoutSessionsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSessionsDataInput;
}

export interface SessionReviewCreateOneInput {
  create?: SessionReviewCreateInput;
  connect?: SessionReviewWhereUniqueInput;
}

export interface UserUpdateWithoutSessionsDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  individualSessions?: IndividualGamingSessionUpdateManyWithoutGamersInput;
  sessionsBought?: IndividualGamingSessionUpdateManyWithoutPlayersInput;
  buffer?: Int;
}

export interface SessionReviewUpdateManyMutationInput {
  text?: String;
}

export interface UserUpdateoccupationsInput {
  set?: Occupations[] | Occupations;
}

export interface GamingSessionUpsertWithoutReviewsInput {
  update: GamingSessionUpdateWithoutReviewsDataInput;
  create: GamingSessionCreateWithoutReviewsInput;
}

export interface GameUpdateManyInput {
  create?: GameCreateInput[] | GameCreateInput;
  update?:
    | GameUpdateWithWhereUniqueNestedInput[]
    | GameUpdateWithWhereUniqueNestedInput;
  upsert?:
    | GameUpsertWithWhereUniqueNestedInput[]
    | GameUpsertWithWhereUniqueNestedInput;
  delete?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  connect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  set?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  disconnect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  deleteMany?: GameScalarWhereInput[] | GameScalarWhereInput;
  updateMany?:
    | GameUpdateManyWithWhereNestedInput[]
    | GameUpdateManyWithWhereNestedInput;
}

export interface GamingSessionUpdateOneRequiredWithoutReviewsInput {
  create?: GamingSessionCreateWithoutReviewsInput;
  update?: GamingSessionUpdateWithoutReviewsDataInput;
  upsert?: GamingSessionUpsertWithoutReviewsInput;
  connect?: GamingSessionWhereUniqueInput;
}

export interface GameUpdateWithWhereUniqueNestedInput {
  where: GameWhereUniqueInput;
  data: GameUpdateDataInput;
}

export interface GamingSessionCreateWithoutReviewsInput {
  gamers?: UserCreateManyWithoutSessionsInput;
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  systems?: GamingSessionCreatesystemsInput;
  type: TypeOfGame;
  slots: Int;
  requirements?: RequirementCreateManyInput;
  discounts?: DiscountCreateManyInput;
  sessions?: IndividualGamingSessionCreateManyWithoutGamingSessionInput;
}

export interface GameUpdateDataInput {
  name?: String;
  tags?: GameUpdatetagsInput;
  sessions?: GamingSessionUpdateManyWithoutGameInput;
  numSessions?: Int;
}

export type SessionReviewWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GameUpsertWithWhereUniqueNestedInput {
  where: GameWhereUniqueInput;
  update: GameUpdateDataInput;
  create: GameCreateInput;
}

export interface RequirementUpdateManyMutationInput {
  msg?: String;
}

export interface GameScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  numSessions?: Int;
  numSessions_not?: Int;
  numSessions_in?: Int[] | Int;
  numSessions_not_in?: Int[] | Int;
  numSessions_lt?: Int;
  numSessions_lte?: Int;
  numSessions_gt?: Int;
  numSessions_gte?: Int;
  AND?: GameScalarWhereInput[] | GameScalarWhereInput;
  OR?: GameScalarWhereInput[] | GameScalarWhereInput;
  NOT?: GameScalarWhereInput[] | GameScalarWhereInput;
}

export type SessionReviewIndexWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GameUpdateManyWithWhereNestedInput {
  where: GameScalarWhereInput;
  data: GameUpdateManyDataInput;
}

export interface SessionReviewIndexWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  sessionReview?: SessionReviewWhereInput;
  AND?: SessionReviewIndexWhereInput[] | SessionReviewIndexWhereInput;
  OR?: SessionReviewIndexWhereInput[] | SessionReviewIndexWhereInput;
  NOT?: SessionReviewIndexWhereInput[] | SessionReviewIndexWhereInput;
}

export interface GameUpdateManyDataInput {
  name?: String;
  tags?: GameUpdatetagsInput;
  numSessions?: Int;
}

export interface GamingSessionIndexUpdateManyMutationInput {
  title?: String;
}

export interface SocialMediaCreateOneInput {
  create?: SocialMediaCreateInput;
  connect?: SocialMediaWhereUniqueInput;
}

export interface GamingSessionUpdateDataInput {
  gamers?: UserUpdateManyWithoutSessionsInput;
  game?: GameUpdateOneRequiredWithoutSessionsInput;
  title?: String;
  length?: Int;
  price?: Float;
  reviews?: SessionReviewUpdateManyWithoutSessionInput;
  systems?: GamingSessionUpdatesystemsInput;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
  sessions?: IndividualGamingSessionUpdateManyWithoutGamingSessionInput;
}

export interface IndividualGamingSessionUpdateWithWhereUniqueWithoutGamersInput {
  where: IndividualGamingSessionWhereUniqueInput;
  data: IndividualGamingSessionUpdateWithoutGamersDataInput;
}

export interface GamingSessionUpdateOneRequiredInput {
  create?: GamingSessionCreateInput;
  update?: GamingSessionUpdateDataInput;
  upsert?: GamingSessionUpsertNestedInput;
  connect?: GamingSessionWhereUniqueInput;
}

export interface IndividualGamingSessionUpdateWithoutGamersDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  gamingSession?: GamingSessionUpdateOneRequiredWithoutSessionsInput;
  players?: UserUpdateManyWithoutSessionsBoughtInput;
  slots?: Int;
}

export interface GamingSessionCreateOneInput {
  create?: GamingSessionCreateInput;
  connect?: GamingSessionWhereUniqueInput;
}

export interface GamingSessionUpdateOneRequiredWithoutSessionsInput {
  create?: GamingSessionCreateWithoutSessionsInput;
  update?: GamingSessionUpdateWithoutSessionsDataInput;
  upsert?: GamingSessionUpsertWithoutSessionsInput;
  connect?: GamingSessionWhereUniqueInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  username?: String;
}>;

export interface GamingSessionUpdateWithoutSessionsDataInput {
  gamers?: UserUpdateManyWithoutSessionsInput;
  game?: GameUpdateOneRequiredWithoutSessionsInput;
  title?: String;
  length?: Int;
  price?: Float;
  reviews?: SessionReviewUpdateManyWithoutSessionInput;
  systems?: GamingSessionUpdatesystemsInput;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
}

export interface GamingSessionUpdateInput {
  gamers?: UserUpdateManyWithoutSessionsInput;
  game?: GameUpdateOneRequiredWithoutSessionsInput;
  title?: String;
  length?: Int;
  price?: Float;
  reviews?: SessionReviewUpdateManyWithoutSessionInput;
  systems?: GamingSessionUpdatesystemsInput;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
  sessions?: IndividualGamingSessionUpdateManyWithoutGamingSessionInput;
}

export interface GameUpdateOneRequiredWithoutSessionsInput {
  create?: GameCreateWithoutSessionsInput;
  update?: GameUpdateWithoutSessionsDataInput;
  upsert?: GameUpsertWithoutSessionsInput;
  connect?: GameWhereUniqueInput;
}

export type UserIndexWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  username?: String;
}>;

export interface GameUpdateWithoutSessionsDataInput {
  name?: String;
  tags?: GameUpdatetagsInput;
  numSessions?: Int;
}

export interface UserIndexWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  user?: UserWhereInput;
  AND?: UserIndexWhereInput[] | UserIndexWhereInput;
  OR?: UserIndexWhereInput[] | UserIndexWhereInput;
  NOT?: UserIndexWhereInput[] | UserIndexWhereInput;
}

export interface GameUpsertWithoutSessionsInput {
  update: GameUpdateWithoutSessionsDataInput;
  create: GameCreateWithoutSessionsInput;
}

export interface SocialMediaUpdateDataInput {
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface SessionReviewUpdateManyWithoutSessionInput {
  create?:
    | SessionReviewCreateWithoutSessionInput[]
    | SessionReviewCreateWithoutSessionInput;
  delete?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  connect?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  set?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  disconnect?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  update?:
    | SessionReviewUpdateWithWhereUniqueWithoutSessionInput[]
    | SessionReviewUpdateWithWhereUniqueWithoutSessionInput;
  upsert?:
    | SessionReviewUpsertWithWhereUniqueWithoutSessionInput[]
    | SessionReviewUpsertWithWhereUniqueWithoutSessionInput;
  deleteMany?: SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput;
  updateMany?:
    | SessionReviewUpdateManyWithWhereNestedInput[]
    | SessionReviewUpdateManyWithWhereNestedInput;
}

export interface GamerRequestUpdateoccupationsInput {
  set?: Occupations[] | Occupations;
}

export interface SessionReviewUpdateWithWhereUniqueWithoutSessionInput {
  where: SessionReviewWhereUniqueInput;
  data: SessionReviewUpdateWithoutSessionDataInput;
}

export interface DiscountCreateInput {
  percentage: Int;
  threshold: Int;
  playerOrSession: PlayerOrSession;
}

export interface SessionReviewUpdateWithoutSessionDataInput {
  user?: UserUpdateOneRequiredInput;
  text?: String;
}

export interface GamerRequestUpdateInput {
  user?: UserUpdateOneRequiredInput;
  occupations?: GamerRequestUpdateoccupationsInput;
  addToOccupations?: String;
  socialMedia?: SocialMediaUpdateOneRequiredInput;
}

export interface GamerRequestCreateoccupationsInput {
  set?: Occupations[] | Occupations;
}

export interface GameCreateInput {
  name: String;
  tags?: GameCreatetagsInput;
  sessions?: GamingSessionCreateManyWithoutGameInput;
  numSessions?: Int;
}

export interface GamerRequestCreateInput {
  user: UserCreateOneInput;
  occupations?: GamerRequestCreateoccupationsInput;
  addToOccupations?: String;
  socialMedia: SocialMediaCreateOneInput;
}

export interface GamingSessionCreateManyWithoutGameInput {
  create?:
    | GamingSessionCreateWithoutGameInput[]
    | GamingSessionCreateWithoutGameInput;
  connect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
}

export interface IndividualGamingSessionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  gamingSession?: GamingSessionWhereInput;
  gamers_every?: UserWhereInput;
  gamers_some?: UserWhereInput;
  gamers_none?: UserWhereInput;
  players_every?: UserWhereInput;
  players_some?: UserWhereInput;
  players_none?: UserWhereInput;
  slots?: Int;
  slots_not?: Int;
  slots_in?: Int[] | Int;
  slots_not_in?: Int[] | Int;
  slots_lt?: Int;
  slots_lte?: Int;
  slots_gt?: Int;
  slots_gte?: Int;
  AND?: IndividualGamingSessionWhereInput[] | IndividualGamingSessionWhereInput;
  OR?: IndividualGamingSessionWhereInput[] | IndividualGamingSessionWhereInput;
  NOT?: IndividualGamingSessionWhereInput[] | IndividualGamingSessionWhereInput;
}

export interface UserCreateManyWithoutSessionsInput {
  create?: UserCreateWithoutSessionsInput[] | UserCreateWithoutSessionsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface GamingSessionUpdateWithWhereUniqueWithoutGamersInput {
  where: GamingSessionWhereUniqueInput;
  data: GamingSessionUpdateWithoutGamersDataInput;
}

export interface UserCreateoccupationsInput {
  set?: Occupations[] | Occupations;
}

export interface GamingSessionUpdateWithoutGamersDataInput {
  game?: GameUpdateOneRequiredWithoutSessionsInput;
  title?: String;
  length?: Int;
  price?: Float;
  reviews?: SessionReviewUpdateManyWithoutSessionInput;
  systems?: GamingSessionUpdatesystemsInput;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
  sessions?: IndividualGamingSessionUpdateManyWithoutGamingSessionInput;
}

export interface IndividualGamingSessionCreateManyWithoutGamersInput {
  create?:
    | IndividualGamingSessionCreateWithoutGamersInput[]
    | IndividualGamingSessionCreateWithoutGamersInput;
  connect?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
}

export interface GamingSessionUpdatesystemsInput {
  set?: System[] | System;
}

export interface GamingSessionCreateOneWithoutSessionsInput {
  create?: GamingSessionCreateWithoutSessionsInput;
  connect?: GamingSessionWhereUniqueInput;
}

export interface RequirementUpdateManyInput {
  create?: RequirementCreateInput[] | RequirementCreateInput;
  deleteMany?: RequirementScalarWhereInput[] | RequirementScalarWhereInput;
  updateMany?:
    | RequirementUpdateManyWithWhereNestedInput[]
    | RequirementUpdateManyWithWhereNestedInput;
}

export interface GameCreateOneWithoutSessionsInput {
  create?: GameCreateWithoutSessionsInput;
  connect?: GameWhereUniqueInput;
}

export interface RequirementScalarWhereInput {
  msg?: String;
  msg_not?: String;
  msg_in?: String[] | String;
  msg_not_in?: String[] | String;
  msg_lt?: String;
  msg_lte?: String;
  msg_gt?: String;
  msg_gte?: String;
  msg_contains?: String;
  msg_not_contains?: String;
  msg_starts_with?: String;
  msg_not_starts_with?: String;
  msg_ends_with?: String;
  msg_not_ends_with?: String;
  AND?: RequirementScalarWhereInput[] | RequirementScalarWhereInput;
  OR?: RequirementScalarWhereInput[] | RequirementScalarWhereInput;
  NOT?: RequirementScalarWhereInput[] | RequirementScalarWhereInput;
}

export interface SessionReviewCreateManyWithoutSessionInput {
  create?:
    | SessionReviewCreateWithoutSessionInput[]
    | SessionReviewCreateWithoutSessionInput;
  connect?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
}

export interface RequirementUpdateManyWithWhereNestedInput {
  where: RequirementScalarWhereInput;
  data: RequirementUpdateManyDataInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface RequirementUpdateManyDataInput {
  msg?: String;
}

export interface UserIndexSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserIndexWhereInput;
  AND?: UserIndexSubscriptionWhereInput[] | UserIndexSubscriptionWhereInput;
  OR?: UserIndexSubscriptionWhereInput[] | UserIndexSubscriptionWhereInput;
  NOT?: UserIndexSubscriptionWhereInput[] | UserIndexSubscriptionWhereInput;
}

export interface DiscountUpdateManyInput {
  create?: DiscountCreateInput[] | DiscountCreateInput;
  deleteMany?: DiscountScalarWhereInput[] | DiscountScalarWhereInput;
  updateMany?:
    | DiscountUpdateManyWithWhereNestedInput[]
    | DiscountUpdateManyWithWhereNestedInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface DiscountScalarWhereInput {
  percentage?: Int;
  percentage_not?: Int;
  percentage_in?: Int[] | Int;
  percentage_not_in?: Int[] | Int;
  percentage_lt?: Int;
  percentage_lte?: Int;
  percentage_gt?: Int;
  percentage_gte?: Int;
  threshold?: Int;
  threshold_not?: Int;
  threshold_in?: Int[] | Int;
  threshold_not_in?: Int[] | Int;
  threshold_lt?: Int;
  threshold_lte?: Int;
  threshold_gt?: Int;
  threshold_gte?: Int;
  playerOrSession?: PlayerOrSession;
  playerOrSession_not?: PlayerOrSession;
  playerOrSession_in?: PlayerOrSession[] | PlayerOrSession;
  playerOrSession_not_in?: PlayerOrSession[] | PlayerOrSession;
  AND?: DiscountScalarWhereInput[] | DiscountScalarWhereInput;
  OR?: DiscountScalarWhereInput[] | DiscountScalarWhereInput;
  NOT?: DiscountScalarWhereInput[] | DiscountScalarWhereInput;
}

export type GameWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface DiscountUpdateManyWithWhereNestedInput {
  where: DiscountScalarWhereInput;
  data: DiscountUpdateManyDataInput;
}

export interface GamingSessionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GamingSessionWhereInput;
  AND?:
    | GamingSessionSubscriptionWhereInput[]
    | GamingSessionSubscriptionWhereInput;
  OR?:
    | GamingSessionSubscriptionWhereInput[]
    | GamingSessionSubscriptionWhereInput;
  NOT?:
    | GamingSessionSubscriptionWhereInput[]
    | GamingSessionSubscriptionWhereInput;
}

export interface DiscountUpdateManyDataInput {
  percentage?: Int;
  threshold?: Int;
  playerOrSession?: PlayerOrSession;
}

export interface GameIndexSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GameIndexWhereInput;
  AND?: GameIndexSubscriptionWhereInput[] | GameIndexSubscriptionWhereInput;
  OR?: GameIndexSubscriptionWhereInput[] | GameIndexSubscriptionWhereInput;
  NOT?: GameIndexSubscriptionWhereInput[] | GameIndexSubscriptionWhereInput;
}

export interface IndividualGamingSessionUpdateManyWithoutGamingSessionInput {
  create?:
    | IndividualGamingSessionCreateWithoutGamingSessionInput[]
    | IndividualGamingSessionCreateWithoutGamingSessionInput;
  delete?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  connect?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  set?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  disconnect?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  update?:
    | IndividualGamingSessionUpdateWithWhereUniqueWithoutGamingSessionInput[]
    | IndividualGamingSessionUpdateWithWhereUniqueWithoutGamingSessionInput;
  upsert?:
    | IndividualGamingSessionUpsertWithWhereUniqueWithoutGamingSessionInput[]
    | IndividualGamingSessionUpsertWithWhereUniqueWithoutGamingSessionInput;
  deleteMany?:
    | IndividualGamingSessionScalarWhereInput[]
    | IndividualGamingSessionScalarWhereInput;
  updateMany?:
    | IndividualGamingSessionUpdateManyWithWhereNestedInput[]
    | IndividualGamingSessionUpdateManyWithWhereNestedInput;
}

export type GamerRequestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface IndividualGamingSessionUpdateWithWhereUniqueWithoutGamingSessionInput {
  where: IndividualGamingSessionWhereUniqueInput;
  data: IndividualGamingSessionUpdateWithoutGamingSessionDataInput;
}

export interface SocialMediaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  twitter?: String;
  twitter_not?: String;
  twitter_in?: String[] | String;
  twitter_not_in?: String[] | String;
  twitter_lt?: String;
  twitter_lte?: String;
  twitter_gt?: String;
  twitter_gte?: String;
  twitter_contains?: String;
  twitter_not_contains?: String;
  twitter_starts_with?: String;
  twitter_not_starts_with?: String;
  twitter_ends_with?: String;
  twitter_not_ends_with?: String;
  facebook?: String;
  facebook_not?: String;
  facebook_in?: String[] | String;
  facebook_not_in?: String[] | String;
  facebook_lt?: String;
  facebook_lte?: String;
  facebook_gt?: String;
  facebook_gte?: String;
  facebook_contains?: String;
  facebook_not_contains?: String;
  facebook_starts_with?: String;
  facebook_not_starts_with?: String;
  facebook_ends_with?: String;
  facebook_not_ends_with?: String;
  youtube?: String;
  youtube_not?: String;
  youtube_in?: String[] | String;
  youtube_not_in?: String[] | String;
  youtube_lt?: String;
  youtube_lte?: String;
  youtube_gt?: String;
  youtube_gte?: String;
  youtube_contains?: String;
  youtube_not_contains?: String;
  youtube_starts_with?: String;
  youtube_not_starts_with?: String;
  youtube_ends_with?: String;
  youtube_not_ends_with?: String;
  instagram?: String;
  instagram_not?: String;
  instagram_in?: String[] | String;
  instagram_not_in?: String[] | String;
  instagram_lt?: String;
  instagram_lte?: String;
  instagram_gt?: String;
  instagram_gte?: String;
  instagram_contains?: String;
  instagram_not_contains?: String;
  instagram_starts_with?: String;
  instagram_not_starts_with?: String;
  instagram_ends_with?: String;
  instagram_not_ends_with?: String;
  twitch?: String;
  twitch_not?: String;
  twitch_in?: String[] | String;
  twitch_not_in?: String[] | String;
  twitch_lt?: String;
  twitch_lte?: String;
  twitch_gt?: String;
  twitch_gte?: String;
  twitch_contains?: String;
  twitch_not_contains?: String;
  twitch_starts_with?: String;
  twitch_not_starts_with?: String;
  twitch_ends_with?: String;
  twitch_not_ends_with?: String;
  snapchat?: String;
  snapchat_not?: String;
  snapchat_in?: String[] | String;
  snapchat_not_in?: String[] | String;
  snapchat_lt?: String;
  snapchat_lte?: String;
  snapchat_gt?: String;
  snapchat_gte?: String;
  snapchat_contains?: String;
  snapchat_not_contains?: String;
  snapchat_starts_with?: String;
  snapchat_not_starts_with?: String;
  snapchat_ends_with?: String;
  snapchat_not_ends_with?: String;
  AND?: SocialMediaWhereInput[] | SocialMediaWhereInput;
  OR?: SocialMediaWhereInput[] | SocialMediaWhereInput;
  NOT?: SocialMediaWhereInput[] | SocialMediaWhereInput;
}

export interface IndividualGamingSessionUpdateWithoutGamingSessionDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  gamers?: UserUpdateManyWithoutIndividualSessionsInput;
  players?: UserUpdateManyWithoutSessionsBoughtInput;
  slots?: Int;
}

export interface SocialMediaUpdateInput {
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface UserUpdateManyWithoutIndividualSessionsInput {
  create?:
    | UserCreateWithoutIndividualSessionsInput[]
    | UserCreateWithoutIndividualSessionsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutIndividualSessionsInput[]
    | UserUpdateWithWhereUniqueWithoutIndividualSessionsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutIndividualSessionsInput[]
    | UserUpsertWithWhereUniqueWithoutIndividualSessionsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface SessionReviewUpdateDataInput {
  user?: UserUpdateOneRequiredInput;
  session?: GamingSessionUpdateOneRequiredWithoutReviewsInput;
  text?: String;
}

export interface UserUpdateWithWhereUniqueWithoutIndividualSessionsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutIndividualSessionsDataInput;
}

export interface SessionReviewIndexUpdateInput {
  text?: String;
  sessionReview?: SessionReviewUpdateOneRequiredInput;
}

export interface UserUpdateWithoutIndividualSessionsDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  sessions?: GamingSessionUpdateManyWithoutGamersInput;
  sessionsBought?: IndividualGamingSessionUpdateManyWithoutPlayersInput;
  buffer?: Int;
}

export type IndividualGamingSessionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface IndividualGamingSessionUpdateManyWithoutPlayersInput {
  create?:
    | IndividualGamingSessionCreateWithoutPlayersInput[]
    | IndividualGamingSessionCreateWithoutPlayersInput;
  delete?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  connect?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  set?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  disconnect?:
    | IndividualGamingSessionWhereUniqueInput[]
    | IndividualGamingSessionWhereUniqueInput;
  update?:
    | IndividualGamingSessionUpdateWithWhereUniqueWithoutPlayersInput[]
    | IndividualGamingSessionUpdateWithWhereUniqueWithoutPlayersInput;
  upsert?:
    | IndividualGamingSessionUpsertWithWhereUniqueWithoutPlayersInput[]
    | IndividualGamingSessionUpsertWithWhereUniqueWithoutPlayersInput;
  deleteMany?:
    | IndividualGamingSessionScalarWhereInput[]
    | IndividualGamingSessionScalarWhereInput;
  updateMany?:
    | IndividualGamingSessionUpdateManyWithWhereNestedInput[]
    | IndividualGamingSessionUpdateManyWithWhereNestedInput;
}

export interface SessionReviewUpdateInput {
  user?: UserUpdateOneRequiredInput;
  session?: GamingSessionUpdateOneRequiredWithoutReviewsInput;
  text?: String;
}

export interface IndividualGamingSessionUpdateWithWhereUniqueWithoutPlayersInput {
  where: IndividualGamingSessionWhereUniqueInput;
  data: IndividualGamingSessionUpdateWithoutPlayersDataInput;
}

export interface SessionReviewCreateInput {
  user: UserCreateOneInput;
  session: GamingSessionCreateOneWithoutReviewsInput;
  text: String;
}

export interface IndividualGamingSessionUpdateWithoutPlayersDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  gamingSession?: GamingSessionUpdateOneRequiredWithoutSessionsInput;
  gamers?: UserUpdateManyWithoutIndividualSessionsInput;
  slots?: Int;
}

export interface IndividualGamingSessionUpdateInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  gamingSession?: GamingSessionUpdateOneRequiredWithoutSessionsInput;
  gamers?: UserUpdateManyWithoutIndividualSessionsInput;
  players?: UserUpdateManyWithoutSessionsBoughtInput;
  slots?: Int;
}

export interface IndividualGamingSessionUpsertWithWhereUniqueWithoutPlayersInput {
  where: IndividualGamingSessionWhereUniqueInput;
  update: IndividualGamingSessionUpdateWithoutPlayersDataInput;
  create: IndividualGamingSessionCreateWithoutPlayersInput;
}

export interface GamingSessionUpsertNestedInput {
  update: GamingSessionUpdateDataInput;
  create: GamingSessionCreateInput;
}

export interface IndividualGamingSessionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  slots?: Int;
  slots_not?: Int;
  slots_in?: Int[] | Int;
  slots_not_in?: Int[] | Int;
  slots_lt?: Int;
  slots_lte?: Int;
  slots_gt?: Int;
  slots_gte?: Int;
  AND?:
    | IndividualGamingSessionScalarWhereInput[]
    | IndividualGamingSessionScalarWhereInput;
  OR?:
    | IndividualGamingSessionScalarWhereInput[]
    | IndividualGamingSessionScalarWhereInput;
  NOT?:
    | IndividualGamingSessionScalarWhereInput[]
    | IndividualGamingSessionScalarWhereInput;
}

export interface GamingSessionIndexUpdateInput {
  title?: String;
  gamingSession?: GamingSessionUpdateOneRequiredInput;
}

export interface IndividualGamingSessionUpdateManyWithWhereNestedInput {
  where: IndividualGamingSessionScalarWhereInput;
  data: IndividualGamingSessionUpdateManyDataInput;
}

export interface GamingSessionUpdateManyMutationInput {
  title?: String;
  length?: Int;
  price?: Float;
  systems?: GamingSessionUpdatesystemsInput;
  type?: TypeOfGame;
  slots?: Int;
}

export interface IndividualGamingSessionUpdateManyDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  slots?: Int;
}

export interface GamerRequestUpdateManyMutationInput {
  occupations?: GamerRequestUpdateoccupationsInput;
  addToOccupations?: String;
}

export interface UserUpsertWithWhereUniqueWithoutIndividualSessionsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutIndividualSessionsDataInput;
  create: UserCreateWithoutIndividualSessionsInput;
}

export interface SocialMediaUpdateOneRequiredInput {
  create?: SocialMediaCreateInput;
  update?: SocialMediaUpdateDataInput;
  upsert?: SocialMediaUpsertNestedInput;
  connect?: SocialMediaWhereUniqueInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  isGamer?: Boolean;
  isGamer_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  aboutMe?: String;
  aboutMe_not?: String;
  aboutMe_in?: String[] | String;
  aboutMe_not_in?: String[] | String;
  aboutMe_lt?: String;
  aboutMe_lte?: String;
  aboutMe_gt?: String;
  aboutMe_gte?: String;
  aboutMe_contains?: String;
  aboutMe_not_contains?: String;
  aboutMe_starts_with?: String;
  aboutMe_not_starts_with?: String;
  aboutMe_ends_with?: String;
  aboutMe_not_ends_with?: String;
  buffer?: Int;
  buffer_not?: Int;
  buffer_in?: Int[] | Int;
  buffer_not_in?: Int[] | Int;
  buffer_lt?: Int;
  buffer_lte?: Int;
  buffer_gt?: Int;
  buffer_gte?: Int;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface DiscountUpdateManyMutationInput {
  percentage?: Int;
  threshold?: Int;
  playerOrSession?: PlayerOrSession;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface GameCreatetagsInput {
  set?: Tags[] | Tags;
}

export interface UserUpdateManyDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  buffer?: Int;
}

export interface UserCreateWithoutSessionsInput {
  email: String;
  username: String;
  password: String;
  isGamer?: Boolean;
  occupations?: UserCreateoccupationsInput;
  name: String;
  aboutMe?: String;
  favoriteGames?: GameCreateManyInput;
  individualSessions?: IndividualGamingSessionCreateManyWithoutGamersInput;
  sessionsBought?: IndividualGamingSessionCreateManyWithoutPlayersInput;
  buffer?: Int;
}

export interface UserUpdateManyWithoutSessionsBoughtInput {
  create?:
    | UserCreateWithoutSessionsBoughtInput[]
    | UserCreateWithoutSessionsBoughtInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutSessionsBoughtInput[]
    | UserUpdateWithWhereUniqueWithoutSessionsBoughtInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutSessionsBoughtInput[]
    | UserUpsertWithWhereUniqueWithoutSessionsBoughtInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface IndividualGamingSessionCreateWithoutGamersInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamingSession: GamingSessionCreateOneWithoutSessionsInput;
  players?: UserCreateManyWithoutSessionsBoughtInput;
  slots: Int;
}

export interface UserUpdateWithWhereUniqueWithoutSessionsBoughtInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSessionsBoughtDataInput;
}

export interface GameCreateWithoutSessionsInput {
  name: String;
  tags?: GameCreatetagsInput;
  numSessions?: Int;
}

export interface UserUpdateWithoutSessionsBoughtDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  sessions?: GamingSessionUpdateManyWithoutGamersInput;
  individualSessions?: IndividualGamingSessionUpdateManyWithoutGamersInput;
  buffer?: Int;
}

export interface UserCreateInput {
  email: String;
  username: String;
  password: String;
  isGamer?: Boolean;
  occupations?: UserCreateoccupationsInput;
  name: String;
  aboutMe?: String;
  favoriteGames?: GameCreateManyInput;
  sessions?: GamingSessionCreateManyWithoutGamersInput;
  individualSessions?: IndividualGamingSessionCreateManyWithoutGamersInput;
  sessionsBought?: IndividualGamingSessionCreateManyWithoutPlayersInput;
  buffer?: Int;
}

export interface UserUpsertWithWhereUniqueWithoutSessionsBoughtInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSessionsBoughtDataInput;
  create: UserCreateWithoutSessionsBoughtInput;
}

export interface SessionReviewIndexSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SessionReviewIndexWhereInput;
  AND?:
    | SessionReviewIndexSubscriptionWhereInput[]
    | SessionReviewIndexSubscriptionWhereInput;
  OR?:
    | SessionReviewIndexSubscriptionWhereInput[]
    | SessionReviewIndexSubscriptionWhereInput;
  NOT?:
    | SessionReviewIndexSubscriptionWhereInput[]
    | SessionReviewIndexSubscriptionWhereInput;
}

export interface IndividualGamingSessionUpsertWithWhereUniqueWithoutGamingSessionInput {
  where: IndividualGamingSessionWhereUniqueInput;
  update: IndividualGamingSessionUpdateWithoutGamingSessionDataInput;
  create: IndividualGamingSessionCreateWithoutGamingSessionInput;
}

export interface GamerRequestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GamerRequestWhereInput;
  AND?:
    | GamerRequestSubscriptionWhereInput[]
    | GamerRequestSubscriptionWhereInput;
  OR?:
    | GamerRequestSubscriptionWhereInput[]
    | GamerRequestSubscriptionWhereInput;
  NOT?:
    | GamerRequestSubscriptionWhereInput[]
    | GamerRequestSubscriptionWhereInput;
}

export interface GamingSessionUpsertWithWhereUniqueWithoutGamersInput {
  where: GamingSessionWhereUniqueInput;
  update: GamingSessionUpdateWithoutGamersDataInput;
  create: GamingSessionCreateWithoutGamersInput;
}

export interface UserIndexCreateInput {
  email: String;
  username: String;
  name: String;
  user: UserCreateOneInput;
}

export interface GamingSessionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  length?: Int;
  length_not?: Int;
  length_in?: Int[] | Int;
  length_not_in?: Int[] | Int;
  length_lt?: Int;
  length_lte?: Int;
  length_gt?: Int;
  length_gte?: Int;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  type?: TypeOfGame;
  type_not?: TypeOfGame;
  type_in?: TypeOfGame[] | TypeOfGame;
  type_not_in?: TypeOfGame[] | TypeOfGame;
  slots?: Int;
  slots_not?: Int;
  slots_in?: Int[] | Int;
  slots_not_in?: Int[] | Int;
  slots_lt?: Int;
  slots_lte?: Int;
  slots_gt?: Int;
  slots_gte?: Int;
  AND?: GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput;
  OR?: GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput;
  NOT?: GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput;
}

export interface SessionReviewIndexUpdateManyMutationInput {
  text?: String;
}

export interface GamingSessionUpdateManyWithWhereNestedInput {
  where: GamingSessionScalarWhereInput;
  data: GamingSessionUpdateManyDataInput;
}

export interface SessionReviewIndexCreateInput {
  text: String;
  sessionReview: SessionReviewCreateOneInput;
}

export interface GamingSessionUpdateManyDataInput {
  title?: String;
  length?: Int;
  price?: Float;
  systems?: GamingSessionUpdatesystemsInput;
  type?: TypeOfGame;
  slots?: Int;
}

export interface GamingSessionCreateOneWithoutReviewsInput {
  create?: GamingSessionCreateWithoutReviewsInput;
  connect?: GamingSessionWhereUniqueInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface IndividualGamingSessionCreateInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamingSession: GamingSessionCreateOneWithoutSessionsInput;
  gamers?: UserCreateManyWithoutIndividualSessionsInput;
  players?: UserCreateManyWithoutSessionsBoughtInput;
  slots: Int;
}

export interface SessionReviewUpsertWithWhereUniqueWithoutSessionInput {
  where: SessionReviewWhereUniqueInput;
  update: SessionReviewUpdateWithoutSessionDataInput;
  create: SessionReviewCreateWithoutSessionInput;
}

export interface GamingSessionIndexCreateInput {
  title: String;
  gamingSession: GamingSessionCreateOneInput;
}

export interface SessionReviewScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput;
  OR?: SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput;
  NOT?: SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput;
}

export interface SocialMediaUpsertNestedInput {
  update: SocialMediaUpdateDataInput;
  create: SocialMediaCreateInput;
}

export interface SessionReviewUpdateManyWithWhereNestedInput {
  where: SessionReviewScalarWhereInput;
  data: SessionReviewUpdateManyDataInput;
}

export interface SocialMediaCreateInput {
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface SessionReviewUpdateManyDataInput {
  text?: String;
}

export interface GameCreateManyInput {
  create?: GameCreateInput[] | GameCreateInput;
  connect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
}

export interface GamingSessionUpsertWithoutSessionsInput {
  update: GamingSessionUpdateWithoutSessionsDataInput;
  create: GamingSessionCreateWithoutSessionsInput;
}

export interface SessionReviewCreateWithoutSessionInput {
  user: UserCreateOneInput;
  text: String;
}

export interface IndividualGamingSessionUpsertWithWhereUniqueWithoutGamersInput {
  where: IndividualGamingSessionWhereUniqueInput;
  update: IndividualGamingSessionUpdateWithoutGamersDataInput;
  create: IndividualGamingSessionCreateWithoutGamersInput;
}

export interface IndividualGamingSessionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: IndividualGamingSessionWhereInput;
  AND?:
    | IndividualGamingSessionSubscriptionWhereInput[]
    | IndividualGamingSessionSubscriptionWhereInput;
  OR?:
    | IndividualGamingSessionSubscriptionWhereInput[]
    | IndividualGamingSessionSubscriptionWhereInput;
  NOT?:
    | IndividualGamingSessionSubscriptionWhereInput[]
    | IndividualGamingSessionSubscriptionWhereInput;
}

export interface UserUpsertWithWhereUniqueWithoutSessionsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSessionsDataInput;
  create: UserCreateWithoutSessionsInput;
}

export interface UserUpdateInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  sessions?: GamingSessionUpdateManyWithoutGamersInput;
  individualSessions?: IndividualGamingSessionUpdateManyWithoutGamersInput;
  sessionsBought?: IndividualGamingSessionUpdateManyWithoutPlayersInput;
  buffer?: Int;
}

export interface GamingSessionUpsertWithWhereUniqueWithoutGameInput {
  where: GamingSessionWhereUniqueInput;
  update: GamingSessionUpdateWithoutGameDataInput;
  create: GamingSessionCreateWithoutGameInput;
}

export interface GamingSessionUpdateWithoutReviewsDataInput {
  gamers?: UserUpdateManyWithoutSessionsInput;
  game?: GameUpdateOneRequiredWithoutSessionsInput;
  title?: String;
  length?: Int;
  price?: Float;
  systems?: GamingSessionUpdatesystemsInput;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
  sessions?: IndividualGamingSessionUpdateManyWithoutGamingSessionInput;
}

export interface GameUpdateManyMutationInput {
  name?: String;
  tags?: GameUpdatetagsInput;
  numSessions?: Int;
}

export type SocialMediaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GameIndexCreateInput {
  name: String;
  tags?: GameIndexCreatetagsInput;
  game: GameCreateOneInput;
}

export interface GamingSessionCreateWithoutSessionsInput {
  gamers?: UserCreateManyWithoutSessionsInput;
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  reviews?: SessionReviewCreateManyWithoutSessionInput;
  systems?: GamingSessionCreatesystemsInput;
  type: TypeOfGame;
  slots: Int;
  requirements?: RequirementCreateManyInput;
  discounts?: DiscountCreateManyInput;
}

export interface GameIndexCreatetagsInput {
  set?: String[] | String;
}

export interface DiscountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DiscountWhereInput;
  AND?: DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput;
  OR?: DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput;
  NOT?: DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput;
}

export interface GameCreateOneInput {
  create?: GameCreateInput;
  connect?: GameWhereUniqueInput;
}

export interface IndividualGamingSessionUpdateManyMutationInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  slots?: Int;
}

export interface GameUpsertNestedInput {
  update: GameUpdateDataInput;
  create: GameCreateInput;
}

export interface GameUpdateOneRequiredInput {
  create?: GameCreateInput;
  update?: GameUpdateDataInput;
  upsert?: GameUpsertNestedInput;
  connect?: GameWhereUniqueInput;
}

export interface GameIndexUpdatetagsInput {
  set?: String[] | String;
}

export interface GameIndexUpdateInput {
  name?: String;
  tags?: GameIndexUpdatetagsInput;
  game?: GameUpdateOneRequiredInput;
}

export interface GamingSessionCreateInput {
  gamers?: UserCreateManyWithoutSessionsInput;
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  reviews?: SessionReviewCreateManyWithoutSessionInput;
  systems?: GamingSessionCreatesystemsInput;
  type: TypeOfGame;
  slots: Int;
  requirements?: RequirementCreateManyInput;
  discounts?: DiscountCreateManyInput;
  sessions?: IndividualGamingSessionCreateManyWithoutGamingSessionInput;
}

export interface SessionReviewUpdateOneRequiredInput {
  create?: SessionReviewCreateInput;
  update?: SessionReviewUpdateDataInput;
  upsert?: SessionReviewUpsertNestedInput;
  connect?: SessionReviewWhereUniqueInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  isGamer?: Boolean;
  isGamer_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  aboutMe?: String;
  aboutMe_not?: String;
  aboutMe_in?: String[] | String;
  aboutMe_not_in?: String[] | String;
  aboutMe_lt?: String;
  aboutMe_lte?: String;
  aboutMe_gt?: String;
  aboutMe_gte?: String;
  aboutMe_contains?: String;
  aboutMe_not_contains?: String;
  aboutMe_starts_with?: String;
  aboutMe_not_starts_with?: String;
  aboutMe_ends_with?: String;
  aboutMe_not_ends_with?: String;
  favoriteGames_every?: GameWhereInput;
  favoriteGames_some?: GameWhereInput;
  favoriteGames_none?: GameWhereInput;
  sessions_every?: GamingSessionWhereInput;
  sessions_some?: GamingSessionWhereInput;
  sessions_none?: GamingSessionWhereInput;
  individualSessions_every?: IndividualGamingSessionWhereInput;
  individualSessions_some?: IndividualGamingSessionWhereInput;
  individualSessions_none?: IndividualGamingSessionWhereInput;
  sessionsBought_every?: IndividualGamingSessionWhereInput;
  sessionsBought_some?: IndividualGamingSessionWhereInput;
  sessionsBought_none?: IndividualGamingSessionWhereInput;
  buffer?: Int;
  buffer_not?: Int;
  buffer_in?: Int[] | Int;
  buffer_not_in?: Int[] | Int;
  buffer_lt?: Int;
  buffer_lte?: Int;
  buffer_gt?: Int;
  buffer_gte?: Int;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface GamingSessionCreateWithoutGameInput {
  gamers?: UserCreateManyWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  reviews?: SessionReviewCreateManyWithoutSessionInput;
  systems?: GamingSessionCreatesystemsInput;
  type: TypeOfGame;
  slots: Int;
  requirements?: RequirementCreateManyInput;
  discounts?: DiscountCreateManyInput;
  sessions?: IndividualGamingSessionCreateManyWithoutGamingSessionInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserIndexPreviousValues {
  id: ID_Output;
  email: String;
  username: String;
  name: String;
}

export interface UserIndexPreviousValuesPromise
  extends Promise<UserIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  name: () => Promise<String>;
}

export interface UserIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<UserIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SocialMedia {
  id: ID_Output;
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface SocialMediaPromise extends Promise<SocialMedia>, Fragmentable {
  id: () => Promise<ID_Output>;
  twitter: () => Promise<String>;
  facebook: () => Promise<String>;
  youtube: () => Promise<String>;
  instagram: () => Promise<String>;
  twitch: () => Promise<String>;
  snapchat: () => Promise<String>;
}

export interface SocialMediaSubscription
  extends Promise<AsyncIterator<SocialMedia>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  twitter: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  youtube: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
  twitch: () => Promise<AsyncIterator<String>>;
  snapchat: () => Promise<AsyncIterator<String>>;
}

export interface GamingSession {
  id: ID_Output;
  title: String;
  length: Int;
  price: Float;
  systems: System[];
  type: TypeOfGame;
  slots: Int;
}

export interface GamingSessionPromise
  extends Promise<GamingSession>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  gamers: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  game: <T = GamePromise>() => T;
  title: () => Promise<String>;
  length: () => Promise<Int>;
  price: () => Promise<Float>;
  reviews: <T = FragmentableArray<SessionReview>>(
    args?: {
      where?: SessionReviewWhereInput;
      orderBy?: SessionReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  systems: () => Promise<System[]>;
  type: () => Promise<TypeOfGame>;
  slots: () => Promise<Int>;
  requirements: <T = FragmentableArray<Requirement>>(
    args?: {
      where?: RequirementWhereInput;
      orderBy?: RequirementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  discounts: <T = FragmentableArray<Discount>>(
    args?: {
      where?: DiscountWhereInput;
      orderBy?: DiscountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sessions: <T = FragmentableArray<IndividualGamingSession>>(
    args?: {
      where?: IndividualGamingSessionWhereInput;
      orderBy?: IndividualGamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GamingSessionSubscription
  extends Promise<AsyncIterator<GamingSession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  gamers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  game: <T = GameSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  length: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  reviews: <T = Promise<AsyncIterator<SessionReviewSubscription>>>(
    args?: {
      where?: SessionReviewWhereInput;
      orderBy?: SessionReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  systems: () => Promise<AsyncIterator<System[]>>;
  type: () => Promise<AsyncIterator<TypeOfGame>>;
  slots: () => Promise<AsyncIterator<Int>>;
  requirements: <T = Promise<AsyncIterator<RequirementSubscription>>>(
    args?: {
      where?: RequirementWhereInput;
      orderBy?: RequirementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  discounts: <T = Promise<AsyncIterator<DiscountSubscription>>>(
    args?: {
      where?: DiscountWhereInput;
      orderBy?: DiscountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sessions: <T = Promise<AsyncIterator<IndividualGamingSessionSubscription>>>(
    args?: {
      where?: IndividualGamingSessionWhereInput;
      orderBy?: IndividualGamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GamerRequestConnection {
  pageInfo: PageInfo;
  edges: GamerRequestEdge[];
}

export interface GamerRequestConnectionPromise
  extends Promise<GamerRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamerRequestEdge>>() => T;
  aggregate: <T = AggregateGamerRequestPromise>() => T;
}

export interface GamerRequestConnectionSubscription
  extends Promise<AsyncIterator<GamerRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GamerRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGamerRequestSubscription>() => T;
}

export interface SocialMediaPreviousValues {
  id: ID_Output;
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface SocialMediaPreviousValuesPromise
  extends Promise<SocialMediaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  twitter: () => Promise<String>;
  facebook: () => Promise<String>;
  youtube: () => Promise<String>;
  instagram: () => Promise<String>;
  twitch: () => Promise<String>;
  snapchat: () => Promise<String>;
}

export interface SocialMediaPreviousValuesSubscription
  extends Promise<AsyncIterator<SocialMediaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  twitter: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  youtube: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
  twitch: () => Promise<AsyncIterator<String>>;
  snapchat: () => Promise<AsyncIterator<String>>;
}

export interface DiscountEdge {
  node: Discount;
  cursor: String;
}

export interface DiscountEdgePromise
  extends Promise<DiscountEdge>,
    Fragmentable {
  node: <T = DiscountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiscountEdgeSubscription
  extends Promise<AsyncIterator<DiscountEdge>>,
    Fragmentable {
  node: <T = DiscountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamerRequest {
  id: ID_Output;
  occupations: Occupations[];
  addToOccupations?: String;
}

export interface GamerRequestPromise
  extends Promise<GamerRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  occupations: () => Promise<Occupations[]>;
  addToOccupations: () => Promise<String>;
  socialMedia: <T = SocialMediaPromise>() => T;
}

export interface GamerRequestSubscription
  extends Promise<AsyncIterator<GamerRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  addToOccupations: () => Promise<AsyncIterator<String>>;
  socialMedia: <T = SocialMediaSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email: String;
  username: String;
  password: String;
  isGamer: Boolean;
  occupations: Occupations[];
  name: String;
  aboutMe?: String;
  buffer?: Int;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  isGamer: () => Promise<Boolean>;
  occupations: () => Promise<Occupations[]>;
  name: () => Promise<String>;
  aboutMe: () => Promise<String>;
  favoriteGames: <T = FragmentableArray<Game>>(
    args?: {
      where?: GameWhereInput;
      orderBy?: GameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sessions: <T = FragmentableArray<GamingSession>>(
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  individualSessions: <T = FragmentableArray<IndividualGamingSession>>(
    args?: {
      where?: IndividualGamingSessionWhereInput;
      orderBy?: IndividualGamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sessionsBought: <T = FragmentableArray<IndividualGamingSession>>(
    args?: {
      where?: IndividualGamingSessionWhereInput;
      orderBy?: IndividualGamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  buffer: () => Promise<Int>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  isGamer: () => Promise<AsyncIterator<Boolean>>;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  name: () => Promise<AsyncIterator<String>>;
  aboutMe: () => Promise<AsyncIterator<String>>;
  favoriteGames: <T = Promise<AsyncIterator<GameSubscription>>>(
    args?: {
      where?: GameWhereInput;
      orderBy?: GameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sessions: <T = Promise<AsyncIterator<GamingSessionSubscription>>>(
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  individualSessions: <
    T = Promise<AsyncIterator<IndividualGamingSessionSubscription>>
  >(
    args?: {
      where?: IndividualGamingSessionWhereInput;
      orderBy?: IndividualGamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sessionsBought: <
    T = Promise<AsyncIterator<IndividualGamingSessionSubscription>>
  >(
    args?: {
      where?: IndividualGamingSessionWhereInput;
      orderBy?: IndividualGamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  buffer: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUserIndex {
  count: Int;
}

export interface AggregateUserIndexPromise
  extends Promise<AggregateUserIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserIndexSubscription
  extends Promise<AsyncIterator<AggregateUserIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  username: String;
  password: String;
  isGamer: Boolean;
  occupations: Occupations[];
  name: String;
  aboutMe?: String;
  buffer?: Int;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  isGamer: () => Promise<Boolean>;
  occupations: () => Promise<Occupations[]>;
  name: () => Promise<String>;
  aboutMe: () => Promise<String>;
  buffer: () => Promise<Int>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  isGamer: () => Promise<AsyncIterator<Boolean>>;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  name: () => Promise<AsyncIterator<String>>;
  aboutMe: () => Promise<AsyncIterator<String>>;
  buffer: () => Promise<AsyncIterator<Int>>;
}

export interface UserIndexConnection {
  pageInfo: PageInfo;
  edges: UserIndexEdge[];
}

export interface UserIndexConnectionPromise
  extends Promise<UserIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserIndexEdge>>() => T;
  aggregate: <T = AggregateUserIndexPromise>() => T;
}

export interface UserIndexConnectionSubscription
  extends Promise<AsyncIterator<UserIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserIndexEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserIndexSubscription>() => T;
}

export interface AggregateGameIndex {
  count: Int;
}

export interface AggregateGameIndexPromise
  extends Promise<AggregateGameIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameIndexSubscription
  extends Promise<AsyncIterator<AggregateGameIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserIndex {
  id: ID_Output;
  email: String;
  username: String;
  name: String;
}

export interface UserIndexPromise extends Promise<UserIndex>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  name: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface UserIndexSubscription
  extends Promise<AsyncIterator<UserIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface GameIndexEdge {
  node: GameIndex;
  cursor: String;
}

export interface GameIndexEdgePromise
  extends Promise<GameIndexEdge>,
    Fragmentable {
  node: <T = GameIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameIndexEdgeSubscription
  extends Promise<AsyncIterator<GameIndexEdge>>,
    Fragmentable {
  node: <T = GameIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateSocialMedia {
  count: Int;
}

export interface AggregateSocialMediaPromise
  extends Promise<AggregateSocialMedia>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSocialMediaSubscription
  extends Promise<AsyncIterator<AggregateSocialMedia>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DiscountSubscriptionPayload {
  mutation: MutationType;
  node: Discount;
  updatedFields: String[];
  previousValues: DiscountPreviousValues;
}

export interface DiscountSubscriptionPayloadPromise
  extends Promise<DiscountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiscountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiscountPreviousValuesPromise>() => T;
}

export interface DiscountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiscountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiscountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiscountPreviousValuesSubscription>() => T;
}

export interface SocialMediaConnection {
  pageInfo: PageInfo;
  edges: SocialMediaEdge[];
}

export interface SocialMediaConnectionPromise
  extends Promise<SocialMediaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SocialMediaEdge>>() => T;
  aggregate: <T = AggregateSocialMediaPromise>() => T;
}

export interface SocialMediaConnectionSubscription
  extends Promise<AsyncIterator<SocialMediaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SocialMediaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSocialMediaSubscription>() => T;
}

export interface DiscountPreviousValues {
  percentage: Int;
  threshold: Int;
  playerOrSession: PlayerOrSession;
}

export interface DiscountPreviousValuesPromise
  extends Promise<DiscountPreviousValues>,
    Fragmentable {
  percentage: () => Promise<Int>;
  threshold: () => Promise<Int>;
  playerOrSession: () => Promise<PlayerOrSession>;
}

export interface DiscountPreviousValuesSubscription
  extends Promise<AsyncIterator<DiscountPreviousValues>>,
    Fragmentable {
  percentage: () => Promise<AsyncIterator<Int>>;
  threshold: () => Promise<AsyncIterator<Int>>;
  playerOrSession: () => Promise<AsyncIterator<PlayerOrSession>>;
}

export interface AggregateSessionReviewIndex {
  count: Int;
}

export interface AggregateSessionReviewIndexPromise
  extends Promise<AggregateSessionReviewIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionReviewIndexSubscription
  extends Promise<AsyncIterator<AggregateSessionReviewIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GameIndexConnection {
  pageInfo: PageInfo;
  edges: GameIndexEdge[];
}

export interface GameIndexConnectionPromise
  extends Promise<GameIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameIndexEdge>>() => T;
  aggregate: <T = AggregateGameIndexPromise>() => T;
}

export interface GameIndexConnectionSubscription
  extends Promise<AsyncIterator<GameIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameIndexEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameIndexSubscription>() => T;
}

export interface SessionReviewIndexConnection {
  pageInfo: PageInfo;
  edges: SessionReviewIndexEdge[];
}

export interface SessionReviewIndexConnectionPromise
  extends Promise<SessionReviewIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionReviewIndexEdge>>() => T;
  aggregate: <T = AggregateSessionReviewIndexPromise>() => T;
}

export interface SessionReviewIndexConnectionSubscription
  extends Promise<AsyncIterator<SessionReviewIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SessionReviewIndexEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSessionReviewIndexSubscription>() => T;
}

export interface GameSubscriptionPayload {
  mutation: MutationType;
  node: Game;
  updatedFields: String[];
  previousValues: GamePreviousValues;
}

export interface GameSubscriptionPayloadPromise
  extends Promise<GameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamePreviousValuesPromise>() => T;
}

export interface GameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamePreviousValuesSubscription>() => T;
}

export interface SessionReviewIndex {
  id: ID_Output;
  text: String;
}

export interface SessionReviewIndexPromise
  extends Promise<SessionReviewIndex>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  sessionReview: <T = SessionReviewPromise>() => T;
}

export interface SessionReviewIndexSubscription
  extends Promise<AsyncIterator<SessionReviewIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  sessionReview: <T = SessionReviewSubscription>() => T;
}

export interface GamePreviousValues {
  id: ID_Output;
  name: String;
  tags: Tags[];
  numSessions: Int;
}

export interface GamePreviousValuesPromise
  extends Promise<GamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  tags: () => Promise<Tags[]>;
  numSessions: () => Promise<Int>;
}

export interface GamePreviousValuesSubscription
  extends Promise<AsyncIterator<GamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<Tags[]>>;
  numSessions: () => Promise<AsyncIterator<Int>>;
}

export interface SessionReviewEdge {
  node: SessionReview;
  cursor: String;
}

export interface SessionReviewEdgePromise
  extends Promise<SessionReviewEdge>,
    Fragmentable {
  node: <T = SessionReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionReviewEdgeSubscription
  extends Promise<AsyncIterator<SessionReviewEdge>>,
    Fragmentable {
  node: <T = SessionReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDiscount {
  count: Int;
}

export interface AggregateDiscountPromise
  extends Promise<AggregateDiscount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiscountSubscription
  extends Promise<AsyncIterator<AggregateDiscount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateRequirement {
  count: Int;
}

export interface AggregateRequirementPromise
  extends Promise<AggregateRequirement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRequirementSubscription
  extends Promise<AsyncIterator<AggregateRequirement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GameIndexSubscriptionPayload {
  mutation: MutationType;
  node: GameIndex;
  updatedFields: String[];
  previousValues: GameIndexPreviousValues;
}

export interface GameIndexSubscriptionPayloadPromise
  extends Promise<GameIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GameIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GameIndexPreviousValuesPromise>() => T;
}

export interface GameIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GameIndexPreviousValuesSubscription>() => T;
}

export interface RequirementConnection {
  pageInfo: PageInfo;
  edges: RequirementEdge[];
}

export interface RequirementConnectionPromise
  extends Promise<RequirementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RequirementEdge>>() => T;
  aggregate: <T = AggregateRequirementPromise>() => T;
}

export interface RequirementConnectionSubscription
  extends Promise<AsyncIterator<RequirementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RequirementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRequirementSubscription>() => T;
}

export interface GameIndexPreviousValues {
  id: ID_Output;
  name: String;
  tags: String[];
}

export interface GameIndexPreviousValuesPromise
  extends Promise<GameIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  tags: () => Promise<String[]>;
}

export interface GameIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<GameIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
}

export interface IndividualGamingSessionEdge {
  node: IndividualGamingSession;
  cursor: String;
}

export interface IndividualGamingSessionEdgePromise
  extends Promise<IndividualGamingSessionEdge>,
    Fragmentable {
  node: <T = IndividualGamingSessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IndividualGamingSessionEdgeSubscription
  extends Promise<AsyncIterator<IndividualGamingSessionEdge>>,
    Fragmentable {
  node: <T = IndividualGamingSessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GameIndex {
  id: ID_Output;
  name: String;
  tags: String[];
}

export interface GameIndexPromise extends Promise<GameIndex>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  tags: () => Promise<String[]>;
  game: <T = GamePromise>() => T;
}

export interface GameIndexSubscription
  extends Promise<AsyncIterator<GameIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  game: <T = GameSubscription>() => T;
}

export interface AggregateGamingSessionIndex {
  count: Int;
}

export interface AggregateGamingSessionIndexPromise
  extends Promise<AggregateGamingSessionIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamingSessionIndexSubscription
  extends Promise<AsyncIterator<AggregateGamingSessionIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamerRequestSubscriptionPayload {
  mutation: MutationType;
  node: GamerRequest;
  updatedFields: String[];
  previousValues: GamerRequestPreviousValues;
}

export interface GamerRequestSubscriptionPayloadPromise
  extends Promise<GamerRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamerRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamerRequestPreviousValuesPromise>() => T;
}

export interface GamerRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamerRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamerRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamerRequestPreviousValuesSubscription>() => T;
}

export interface GamingSessionIndexConnection {
  pageInfo: PageInfo;
  edges: GamingSessionIndexEdge[];
}

export interface GamingSessionIndexConnectionPromise
  extends Promise<GamingSessionIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamingSessionIndexEdge>>() => T;
  aggregate: <T = AggregateGamingSessionIndexPromise>() => T;
}

export interface GamingSessionIndexConnectionSubscription
  extends Promise<AsyncIterator<GamingSessionIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<GamingSessionIndexEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateGamingSessionIndexSubscription>() => T;
}

export interface GamerRequestPreviousValues {
  id: ID_Output;
  occupations: Occupations[];
  addToOccupations?: String;
}

export interface GamerRequestPreviousValuesPromise
  extends Promise<GamerRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  occupations: () => Promise<Occupations[]>;
  addToOccupations: () => Promise<String>;
}

export interface GamerRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<GamerRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  addToOccupations: () => Promise<AsyncIterator<String>>;
}

export interface GamingSessionIndex {
  id: ID_Output;
  title: String;
}

export interface GamingSessionIndexPromise
  extends Promise<GamingSessionIndex>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  gamingSession: <T = GamingSessionPromise>() => T;
}

export interface GamingSessionIndexSubscription
  extends Promise<AsyncIterator<GamingSessionIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  gamingSession: <T = GamingSessionSubscription>() => T;
}

export interface AggregateGame {
  count: Int;
}

export interface AggregateGamePromise
  extends Promise<AggregateGame>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameSubscription
  extends Promise<AsyncIterator<AggregateGame>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamingSessionEdge {
  node: GamingSession;
  cursor: String;
}

export interface GamingSessionEdgePromise
  extends Promise<GamingSessionEdge>,
    Fragmentable {
  node: <T = GamingSessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamingSessionEdgeSubscription
  extends Promise<AsyncIterator<GamingSessionEdge>>,
    Fragmentable {
  node: <T = GamingSessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamingSessionSubscriptionPayload {
  mutation: MutationType;
  node: GamingSession;
  updatedFields: String[];
  previousValues: GamingSessionPreviousValues;
}

export interface GamingSessionSubscriptionPayloadPromise
  extends Promise<GamingSessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamingSessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamingSessionPreviousValuesPromise>() => T;
}

export interface GamingSessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamingSessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamingSessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamingSessionPreviousValuesSubscription>() => T;
}

export interface AggregateGamerRequest {
  count: Int;
}

export interface AggregateGamerRequestPromise
  extends Promise<AggregateGamerRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamerRequestSubscription
  extends Promise<AsyncIterator<AggregateGamerRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamingSessionPreviousValues {
  id: ID_Output;
  title: String;
  length: Int;
  price: Float;
  systems: System[];
  type: TypeOfGame;
  slots: Int;
}

export interface GamingSessionPreviousValuesPromise
  extends Promise<GamingSessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  length: () => Promise<Int>;
  price: () => Promise<Float>;
  systems: () => Promise<System[]>;
  type: () => Promise<TypeOfGame>;
  slots: () => Promise<Int>;
}

export interface GamingSessionPreviousValuesSubscription
  extends Promise<AsyncIterator<GamingSessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  length: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  systems: () => Promise<AsyncIterator<System[]>>;
  type: () => Promise<AsyncIterator<TypeOfGame>>;
  slots: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface GameEdge {
  node: Game;
  cursor: String;
}

export interface GameEdgePromise extends Promise<GameEdge>, Fragmentable {
  node: <T = GamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameEdgeSubscription
  extends Promise<AsyncIterator<GameEdge>>,
    Fragmentable {
  node: <T = GameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Discount {
  percentage: Int;
  threshold: Int;
  playerOrSession: PlayerOrSession;
}

export interface DiscountPromise extends Promise<Discount>, Fragmentable {
  percentage: () => Promise<Int>;
  threshold: () => Promise<Int>;
  playerOrSession: () => Promise<PlayerOrSession>;
}

export interface DiscountSubscription
  extends Promise<AsyncIterator<Discount>>,
    Fragmentable {
  percentage: () => Promise<AsyncIterator<Int>>;
  threshold: () => Promise<AsyncIterator<Int>>;
  playerOrSession: () => Promise<AsyncIterator<PlayerOrSession>>;
}

export interface GamingSessionIndexSubscriptionPayload {
  mutation: MutationType;
  node: GamingSessionIndex;
  updatedFields: String[];
  previousValues: GamingSessionIndexPreviousValues;
}

export interface GamingSessionIndexSubscriptionPayloadPromise
  extends Promise<GamingSessionIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamingSessionIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamingSessionIndexPreviousValuesPromise>() => T;
}

export interface GamingSessionIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamingSessionIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamingSessionIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamingSessionIndexPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface GamingSessionIndexPreviousValues {
  id: ID_Output;
  title: String;
}

export interface GamingSessionIndexPreviousValuesPromise
  extends Promise<GamingSessionIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

export interface GamingSessionIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<GamingSessionIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface DiscountConnection {
  pageInfo: PageInfo;
  edges: DiscountEdge[];
}

export interface DiscountConnectionPromise
  extends Promise<DiscountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiscountEdge>>() => T;
  aggregate: <T = AggregateDiscountPromise>() => T;
}

export interface DiscountConnectionSubscription
  extends Promise<AsyncIterator<DiscountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiscountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiscountSubscription>() => T;
}

export interface GameConnection {
  pageInfo: PageInfo;
  edges: GameEdge[];
}

export interface GameConnectionPromise
  extends Promise<GameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameEdge>>() => T;
  aggregate: <T = AggregateGamePromise>() => T;
}

export interface GameConnectionSubscription
  extends Promise<AsyncIterator<GameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface IndividualGamingSessionSubscriptionPayload {
  mutation: MutationType;
  node: IndividualGamingSession;
  updatedFields: String[];
  previousValues: IndividualGamingSessionPreviousValues;
}

export interface IndividualGamingSessionSubscriptionPayloadPromise
  extends Promise<IndividualGamingSessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IndividualGamingSessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IndividualGamingSessionPreviousValuesPromise>() => T;
}

export interface IndividualGamingSessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IndividualGamingSessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IndividualGamingSessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = IndividualGamingSessionPreviousValuesSubscription
  >() => T;
}

export interface SessionReviewConnection {
  pageInfo: PageInfo;
  edges: SessionReviewEdge[];
}

export interface SessionReviewConnectionPromise
  extends Promise<SessionReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionReviewEdge>>() => T;
  aggregate: <T = AggregateSessionReviewPromise>() => T;
}

export interface SessionReviewConnectionSubscription
  extends Promise<AsyncIterator<SessionReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionReviewSubscription>() => T;
}

export interface IndividualGamingSessionPreviousValues {
  id: ID_Output;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  slots: Int;
}

export interface IndividualGamingSessionPreviousValuesPromise
  extends Promise<IndividualGamingSessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  slots: () => Promise<Int>;
}

export interface IndividualGamingSessionPreviousValuesSubscription
  extends Promise<AsyncIterator<IndividualGamingSessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  slots: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateIndividualGamingSession {
  count: Int;
}

export interface AggregateIndividualGamingSessionPromise
  extends Promise<AggregateIndividualGamingSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIndividualGamingSessionSubscription
  extends Promise<AsyncIterator<AggregateIndividualGamingSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Requirement {
  msg: String;
}

export interface RequirementPromise extends Promise<Requirement>, Fragmentable {
  msg: () => Promise<String>;
}

export interface RequirementSubscription
  extends Promise<AsyncIterator<Requirement>>,
    Fragmentable {
  msg: () => Promise<AsyncIterator<String>>;
}

export interface GamingSessionIndexEdge {
  node: GamingSessionIndex;
  cursor: String;
}

export interface GamingSessionIndexEdgePromise
  extends Promise<GamingSessionIndexEdge>,
    Fragmentable {
  node: <T = GamingSessionIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamingSessionIndexEdgeSubscription
  extends Promise<AsyncIterator<GamingSessionIndexEdge>>,
    Fragmentable {
  node: <T = GamingSessionIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RequirementSubscriptionPayload {
  mutation: MutationType;
  node: Requirement;
  updatedFields: String[];
  previousValues: RequirementPreviousValues;
}

export interface RequirementSubscriptionPayloadPromise
  extends Promise<RequirementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RequirementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RequirementPreviousValuesPromise>() => T;
}

export interface RequirementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RequirementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RequirementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RequirementPreviousValuesSubscription>() => T;
}

export interface AggregateGamingSession {
  count: Int;
}

export interface AggregateGamingSessionPromise
  extends Promise<AggregateGamingSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamingSessionSubscription
  extends Promise<AsyncIterator<AggregateGamingSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RequirementPreviousValues {
  msg: String;
}

export interface RequirementPreviousValuesPromise
  extends Promise<RequirementPreviousValues>,
    Fragmentable {
  msg: () => Promise<String>;
}

export interface RequirementPreviousValuesSubscription
  extends Promise<AsyncIterator<RequirementPreviousValues>>,
    Fragmentable {
  msg: () => Promise<AsyncIterator<String>>;
}

export interface GamerRequestEdge {
  node: GamerRequest;
  cursor: String;
}

export interface GamerRequestEdgePromise
  extends Promise<GamerRequestEdge>,
    Fragmentable {
  node: <T = GamerRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamerRequestEdgeSubscription
  extends Promise<AsyncIterator<GamerRequestEdge>>,
    Fragmentable {
  node: <T = GamerRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface IndividualGamingSession {
  id: ID_Output;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  slots: Int;
}

export interface IndividualGamingSessionPromise
  extends Promise<IndividualGamingSession>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  gamingSession: <T = GamingSessionPromise>() => T;
  gamers: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  players: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  slots: () => Promise<Int>;
}

export interface IndividualGamingSessionSubscription
  extends Promise<AsyncIterator<IndividualGamingSession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  gamingSession: <T = GamingSessionSubscription>() => T;
  gamers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  players: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  slots: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SessionReviewSubscriptionPayload {
  mutation: MutationType;
  node: SessionReview;
  updatedFields: String[];
  previousValues: SessionReviewPreviousValues;
}

export interface SessionReviewSubscriptionPayloadPromise
  extends Promise<SessionReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionReviewPreviousValuesPromise>() => T;
}

export interface SessionReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionReviewPreviousValuesSubscription>() => T;
}

export interface SessionReviewIndexEdge {
  node: SessionReviewIndex;
  cursor: String;
}

export interface SessionReviewIndexEdgePromise
  extends Promise<SessionReviewIndexEdge>,
    Fragmentable {
  node: <T = SessionReviewIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionReviewIndexEdgeSubscription
  extends Promise<AsyncIterator<SessionReviewIndexEdge>>,
    Fragmentable {
  node: <T = SessionReviewIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SessionReviewPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
}

export interface SessionReviewPreviousValuesPromise
  extends Promise<SessionReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
}

export interface SessionReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface RequirementEdge {
  node: Requirement;
  cursor: String;
}

export interface RequirementEdgePromise
  extends Promise<RequirementEdge>,
    Fragmentable {
  node: <T = RequirementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RequirementEdgeSubscription
  extends Promise<AsyncIterator<RequirementEdge>>,
    Fragmentable {
  node: <T = RequirementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SessionReview {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
}

export interface SessionReviewPromise
  extends Promise<SessionReview>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  session: <T = GamingSessionPromise>() => T;
  text: () => Promise<String>;
}

export interface SessionReviewSubscription
  extends Promise<AsyncIterator<SessionReview>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  session: <T = GamingSessionSubscription>() => T;
  text: () => Promise<AsyncIterator<String>>;
}

export interface UserIndexSubscriptionPayload {
  mutation: MutationType;
  node: UserIndex;
  updatedFields: String[];
  previousValues: UserIndexPreviousValues;
}

export interface UserIndexSubscriptionPayloadPromise
  extends Promise<UserIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserIndexPreviousValuesPromise>() => T;
}

export interface UserIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserIndexPreviousValuesSubscription>() => T;
}

export interface UserIndexEdge {
  node: UserIndex;
  cursor: String;
}

export interface UserIndexEdgePromise
  extends Promise<UserIndexEdge>,
    Fragmentable {
  node: <T = UserIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserIndexEdgeSubscription
  extends Promise<AsyncIterator<UserIndexEdge>>,
    Fragmentable {
  node: <T = UserIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SocialMediaSubscriptionPayload {
  mutation: MutationType;
  node: SocialMedia;
  updatedFields: String[];
  previousValues: SocialMediaPreviousValues;
}

export interface SocialMediaSubscriptionPayloadPromise
  extends Promise<SocialMediaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SocialMediaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SocialMediaPreviousValuesPromise>() => T;
}

export interface SocialMediaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SocialMediaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SocialMediaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SocialMediaPreviousValuesSubscription>() => T;
}

export interface Game {
  id: ID_Output;
  name: String;
  tags: Tags[];
  numSessions: Int;
}

export interface GamePromise extends Promise<Game>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  tags: () => Promise<Tags[]>;
  sessions: <T = FragmentableArray<GamingSession>>(
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  numSessions: () => Promise<Int>;
}

export interface GameSubscription
  extends Promise<AsyncIterator<Game>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<Tags[]>>;
  sessions: <T = Promise<AsyncIterator<GamingSessionSubscription>>>(
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  numSessions: () => Promise<AsyncIterator<Int>>;
}

export interface SessionReviewIndexPreviousValues {
  id: ID_Output;
  text: String;
}

export interface SessionReviewIndexPreviousValuesPromise
  extends Promise<SessionReviewIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
}

export interface SessionReviewIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionReviewIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface SessionReviewIndexSubscriptionPayload {
  mutation: MutationType;
  node: SessionReviewIndex;
  updatedFields: String[];
  previousValues: SessionReviewIndexPreviousValues;
}

export interface SessionReviewIndexSubscriptionPayloadPromise
  extends Promise<SessionReviewIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionReviewIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionReviewIndexPreviousValuesPromise>() => T;
}

export interface SessionReviewIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionReviewIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionReviewIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionReviewIndexPreviousValuesSubscription>() => T;
}

export interface SocialMediaEdge {
  node: SocialMedia;
  cursor: String;
}

export interface SocialMediaEdgePromise
  extends Promise<SocialMediaEdge>,
    Fragmentable {
  node: <T = SocialMediaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SocialMediaEdgeSubscription
  extends Promise<AsyncIterator<SocialMediaEdge>>,
    Fragmentable {
  node: <T = SocialMediaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamingSessionConnection {
  pageInfo: PageInfo;
  edges: GamingSessionEdge[];
}

export interface GamingSessionConnectionPromise
  extends Promise<GamingSessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamingSessionEdge>>() => T;
  aggregate: <T = AggregateGamingSessionPromise>() => T;
}

export interface GamingSessionConnectionSubscription
  extends Promise<AsyncIterator<GamingSessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GamingSessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGamingSessionSubscription>() => T;
}

export interface IndividualGamingSessionConnection {
  pageInfo: PageInfo;
  edges: IndividualGamingSessionEdge[];
}

export interface IndividualGamingSessionConnectionPromise
  extends Promise<IndividualGamingSessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IndividualGamingSessionEdge>>() => T;
  aggregate: <T = AggregateIndividualGamingSessionPromise>() => T;
}

export interface IndividualGamingSessionConnectionSubscription
  extends Promise<AsyncIterator<IndividualGamingSessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<IndividualGamingSessionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateIndividualGamingSessionSubscription>() => T;
}

export interface AggregateSessionReview {
  count: Int;
}

export interface AggregateSessionReviewPromise
  extends Promise<AggregateSessionReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionReviewSubscription
  extends Promise<AsyncIterator<AggregateSessionReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserIndex",
    embedded: false
  },
  {
    name: "GamerRequest",
    embedded: false
  },
  {
    name: "SocialMedia",
    embedded: false
  },
  {
    name: "Game",
    embedded: false
  },
  {
    name: "GameIndex",
    embedded: false
  },
  {
    name: "GamingSession",
    embedded: false
  },
  {
    name: "GamingSessionIndex",
    embedded: false
  },
  {
    name: "Requirement",
    embedded: false
  },
  {
    name: "Discount",
    embedded: false
  },
  {
    name: "SessionReview",
    embedded: false
  },
  {
    name: "SessionReviewIndex",
    embedded: false
  },
  {
    name: "IndividualGamingSession",
    embedded: false
  },
  {
    name: "Occupations",
    embedded: false
  },
  {
    name: "Tags",
    embedded: false
  },
  {
    name: "TypeOfGame",
    embedded: false
  },
  {
    name: "System",
    embedded: false
  },
  {
    name: "PlayerOrSession",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
