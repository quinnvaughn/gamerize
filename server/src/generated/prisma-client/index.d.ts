// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  bookedPlayer: (where?: BookedPlayerWhereInput) => Promise<boolean>;
  booking: (where?: BookingWhereInput) => Promise<boolean>;
  bookingInvite: (where?: BookingInviteWhereInput) => Promise<boolean>;
  discount: (where?: DiscountWhereInput) => Promise<boolean>;
  friendRequest: (where?: FriendRequestWhereInput) => Promise<boolean>;
  game: (where?: GameWhereInput) => Promise<boolean>;
  gameIndex: (where?: GameIndexWhereInput) => Promise<boolean>;
  gamerRequest: (where?: GamerRequestWhereInput) => Promise<boolean>;
  gamerTag: (where?: GamerTagWhereInput) => Promise<boolean>;
  gamingSession: (where?: GamingSessionWhereInput) => Promise<boolean>;
  gamingSessionIndex: (
    where?: GamingSessionIndexWhereInput
  ) => Promise<boolean>;
  gamingTimeSlot: (where?: GamingTimeSlotWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  pCLauncher: (where?: PCLauncherWhereInput) => Promise<boolean>;
  requirement: (where?: RequirementWhereInput) => Promise<boolean>;
  savedCard: (where?: SavedCardWhereInput) => Promise<boolean>;
  sessionReview: (where?: SessionReviewWhereInput) => Promise<boolean>;
  sessionReviewIndex: (
    where?: SessionReviewIndexWhereInput
  ) => Promise<boolean>;
  socialMedia: (where?: SocialMediaWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userIndex: (where?: UserIndexWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  bookedPlayer: (
    where: BookedPlayerWhereUniqueInput
  ) => BookedPlayerNullablePromise;
  bookedPlayers: (args?: {
    where?: BookedPlayerWhereInput;
    orderBy?: BookedPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BookedPlayer>;
  bookedPlayersConnection: (args?: {
    where?: BookedPlayerWhereInput;
    orderBy?: BookedPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookedPlayerConnectionPromise;
  booking: (where: BookingWhereUniqueInput) => BookingNullablePromise;
  bookings: (args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Booking>;
  bookingsConnection: (args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookingConnectionPromise;
  bookingInvite: (
    where: BookingInviteWhereUniqueInput
  ) => BookingInviteNullablePromise;
  bookingInvites: (args?: {
    where?: BookingInviteWhereInput;
    orderBy?: BookingInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BookingInvite>;
  bookingInvitesConnection: (args?: {
    where?: BookingInviteWhereInput;
    orderBy?: BookingInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookingInviteConnectionPromise;
  discount: (where: DiscountWhereUniqueInput) => DiscountNullablePromise;
  discounts: (args?: {
    where?: DiscountWhereInput;
    orderBy?: DiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Discount>;
  discountsConnection: (args?: {
    where?: DiscountWhereInput;
    orderBy?: DiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DiscountConnectionPromise;
  friendRequest: (
    where: FriendRequestWhereUniqueInput
  ) => FriendRequestNullablePromise;
  friendRequests: (args?: {
    where?: FriendRequestWhereInput;
    orderBy?: FriendRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FriendRequest>;
  friendRequestsConnection: (args?: {
    where?: FriendRequestWhereInput;
    orderBy?: FriendRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FriendRequestConnectionPromise;
  game: (where: GameWhereUniqueInput) => GameNullablePromise;
  games: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Game>;
  gamesConnection: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GameConnectionPromise;
  gameIndex: (where: GameIndexWhereUniqueInput) => GameIndexNullablePromise;
  gameIndexes: (args?: {
    where?: GameIndexWhereInput;
    orderBy?: GameIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GameIndex>;
  gameIndexesConnection: (args?: {
    where?: GameIndexWhereInput;
    orderBy?: GameIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GameIndexConnectionPromise;
  gamerRequest: (
    where: GamerRequestWhereUniqueInput
  ) => GamerRequestNullablePromise;
  gamerRequests: (args?: {
    where?: GamerRequestWhereInput;
    orderBy?: GamerRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GamerRequest>;
  gamerRequestsConnection: (args?: {
    where?: GamerRequestWhereInput;
    orderBy?: GamerRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GamerRequestConnectionPromise;
  gamerTag: (where: GamerTagWhereUniqueInput) => GamerTagNullablePromise;
  gamerTags: (args?: {
    where?: GamerTagWhereInput;
    orderBy?: GamerTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GamerTag>;
  gamerTagsConnection: (args?: {
    where?: GamerTagWhereInput;
    orderBy?: GamerTagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GamerTagConnectionPromise;
  gamingSession: (
    where: GamingSessionWhereUniqueInput
  ) => GamingSessionNullablePromise;
  gamingSessions: (args?: {
    where?: GamingSessionWhereInput;
    orderBy?: GamingSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GamingSession>;
  gamingSessionsConnection: (args?: {
    where?: GamingSessionWhereInput;
    orderBy?: GamingSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GamingSessionConnectionPromise;
  gamingSessionIndex: (
    where: GamingSessionIndexWhereUniqueInput
  ) => GamingSessionIndexNullablePromise;
  gamingSessionIndexes: (args?: {
    where?: GamingSessionIndexWhereInput;
    orderBy?: GamingSessionIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GamingSessionIndex>;
  gamingSessionIndexesConnection: (args?: {
    where?: GamingSessionIndexWhereInput;
    orderBy?: GamingSessionIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GamingSessionIndexConnectionPromise;
  gamingTimeSlot: (
    where: GamingTimeSlotWhereUniqueInput
  ) => GamingTimeSlotNullablePromise;
  gamingTimeSlots: (args?: {
    where?: GamingTimeSlotWhereInput;
    orderBy?: GamingTimeSlotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GamingTimeSlot>;
  gamingTimeSlotsConnection: (args?: {
    where?: GamingTimeSlotWhereInput;
    orderBy?: GamingTimeSlotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GamingTimeSlotConnectionPromise;
  notification: (
    where: NotificationWhereUniqueInput
  ) => NotificationNullablePromise;
  notifications: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Notification>;
  notificationsConnection: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NotificationConnectionPromise;
  pCLauncher: (where: PCLauncherWhereUniqueInput) => PCLauncherNullablePromise;
  pCLaunchers: (args?: {
    where?: PCLauncherWhereInput;
    orderBy?: PCLauncherOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PCLauncher>;
  pCLaunchersConnection: (args?: {
    where?: PCLauncherWhereInput;
    orderBy?: PCLauncherOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PCLauncherConnectionPromise;
  requirement: (
    where: RequirementWhereUniqueInput
  ) => RequirementNullablePromise;
  requirements: (args?: {
    where?: RequirementWhereInput;
    orderBy?: RequirementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Requirement>;
  requirementsConnection: (args?: {
    where?: RequirementWhereInput;
    orderBy?: RequirementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RequirementConnectionPromise;
  savedCard: (where: SavedCardWhereUniqueInput) => SavedCardNullablePromise;
  savedCards: (args?: {
    where?: SavedCardWhereInput;
    orderBy?: SavedCardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SavedCard>;
  savedCardsConnection: (args?: {
    where?: SavedCardWhereInput;
    orderBy?: SavedCardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SavedCardConnectionPromise;
  sessionReview: (
    where: SessionReviewWhereUniqueInput
  ) => SessionReviewNullablePromise;
  sessionReviews: (args?: {
    where?: SessionReviewWhereInput;
    orderBy?: SessionReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SessionReview>;
  sessionReviewsConnection: (args?: {
    where?: SessionReviewWhereInput;
    orderBy?: SessionReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SessionReviewConnectionPromise;
  sessionReviewIndex: (
    where: SessionReviewIndexWhereUniqueInput
  ) => SessionReviewIndexNullablePromise;
  sessionReviewIndexes: (args?: {
    where?: SessionReviewIndexWhereInput;
    orderBy?: SessionReviewIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SessionReviewIndex>;
  sessionReviewIndexesConnection: (args?: {
    where?: SessionReviewIndexWhereInput;
    orderBy?: SessionReviewIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SessionReviewIndexConnectionPromise;
  socialMedia: (
    where: SocialMediaWhereUniqueInput
  ) => SocialMediaNullablePromise;
  socialMedias: (args?: {
    where?: SocialMediaWhereInput;
    orderBy?: SocialMediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SocialMedia>;
  socialMediasConnection: (args?: {
    where?: SocialMediaWhereInput;
    orderBy?: SocialMediaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SocialMediaConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userIndex: (where: UserIndexWhereUniqueInput) => UserIndexNullablePromise;
  userIndexes: (args?: {
    where?: UserIndexWhereInput;
    orderBy?: UserIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserIndex>;
  userIndexesConnection: (args?: {
    where?: UserIndexWhereInput;
    orderBy?: UserIndexOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserIndexConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBookedPlayer: (data: BookedPlayerCreateInput) => BookedPlayerPromise;
  updateBookedPlayer: (args: {
    data: BookedPlayerUpdateInput;
    where: BookedPlayerWhereUniqueInput;
  }) => BookedPlayerPromise;
  upsertBookedPlayer: (args: {
    where: BookedPlayerWhereUniqueInput;
    create: BookedPlayerCreateInput;
    update: BookedPlayerUpdateInput;
  }) => BookedPlayerPromise;
  deleteBookedPlayer: (
    where: BookedPlayerWhereUniqueInput
  ) => BookedPlayerPromise;
  deleteManyBookedPlayers: (
    where?: BookedPlayerWhereInput
  ) => BatchPayloadPromise;
  createBooking: (data: BookingCreateInput) => BookingPromise;
  updateBooking: (args: {
    data: BookingUpdateInput;
    where: BookingWhereUniqueInput;
  }) => BookingPromise;
  updateManyBookings: (args: {
    data: BookingUpdateManyMutationInput;
    where?: BookingWhereInput;
  }) => BatchPayloadPromise;
  upsertBooking: (args: {
    where: BookingWhereUniqueInput;
    create: BookingCreateInput;
    update: BookingUpdateInput;
  }) => BookingPromise;
  deleteBooking: (where: BookingWhereUniqueInput) => BookingPromise;
  deleteManyBookings: (where?: BookingWhereInput) => BatchPayloadPromise;
  createBookingInvite: (data: BookingInviteCreateInput) => BookingInvitePromise;
  updateBookingInvite: (args: {
    data: BookingInviteUpdateInput;
    where: BookingInviteWhereUniqueInput;
  }) => BookingInvitePromise;
  updateManyBookingInvites: (args: {
    data: BookingInviteUpdateManyMutationInput;
    where?: BookingInviteWhereInput;
  }) => BatchPayloadPromise;
  upsertBookingInvite: (args: {
    where: BookingInviteWhereUniqueInput;
    create: BookingInviteCreateInput;
    update: BookingInviteUpdateInput;
  }) => BookingInvitePromise;
  deleteBookingInvite: (
    where: BookingInviteWhereUniqueInput
  ) => BookingInvitePromise;
  deleteManyBookingInvites: (
    where?: BookingInviteWhereInput
  ) => BatchPayloadPromise;
  createDiscount: (data: DiscountCreateInput) => DiscountPromise;
  updateDiscount: (args: {
    data: DiscountUpdateInput;
    where: DiscountWhereUniqueInput;
  }) => DiscountPromise;
  updateManyDiscounts: (args: {
    data: DiscountUpdateManyMutationInput;
    where?: DiscountWhereInput;
  }) => BatchPayloadPromise;
  upsertDiscount: (args: {
    where: DiscountWhereUniqueInput;
    create: DiscountCreateInput;
    update: DiscountUpdateInput;
  }) => DiscountPromise;
  deleteDiscount: (where: DiscountWhereUniqueInput) => DiscountPromise;
  deleteManyDiscounts: (where?: DiscountWhereInput) => BatchPayloadPromise;
  createFriendRequest: (data: FriendRequestCreateInput) => FriendRequestPromise;
  updateFriendRequest: (args: {
    data: FriendRequestUpdateInput;
    where: FriendRequestWhereUniqueInput;
  }) => FriendRequestPromise;
  upsertFriendRequest: (args: {
    where: FriendRequestWhereUniqueInput;
    create: FriendRequestCreateInput;
    update: FriendRequestUpdateInput;
  }) => FriendRequestPromise;
  deleteFriendRequest: (
    where: FriendRequestWhereUniqueInput
  ) => FriendRequestPromise;
  deleteManyFriendRequests: (
    where?: FriendRequestWhereInput
  ) => BatchPayloadPromise;
  createGame: (data: GameCreateInput) => GamePromise;
  updateGame: (args: {
    data: GameUpdateInput;
    where: GameWhereUniqueInput;
  }) => GamePromise;
  updateManyGames: (args: {
    data: GameUpdateManyMutationInput;
    where?: GameWhereInput;
  }) => BatchPayloadPromise;
  upsertGame: (args: {
    where: GameWhereUniqueInput;
    create: GameCreateInput;
    update: GameUpdateInput;
  }) => GamePromise;
  deleteGame: (where: GameWhereUniqueInput) => GamePromise;
  deleteManyGames: (where?: GameWhereInput) => BatchPayloadPromise;
  createGameIndex: (data: GameIndexCreateInput) => GameIndexPromise;
  updateGameIndex: (args: {
    data: GameIndexUpdateInput;
    where: GameIndexWhereUniqueInput;
  }) => GameIndexPromise;
  updateManyGameIndexes: (args: {
    data: GameIndexUpdateManyMutationInput;
    where?: GameIndexWhereInput;
  }) => BatchPayloadPromise;
  upsertGameIndex: (args: {
    where: GameIndexWhereUniqueInput;
    create: GameIndexCreateInput;
    update: GameIndexUpdateInput;
  }) => GameIndexPromise;
  deleteGameIndex: (where: GameIndexWhereUniqueInput) => GameIndexPromise;
  deleteManyGameIndexes: (where?: GameIndexWhereInput) => BatchPayloadPromise;
  createGamerRequest: (data: GamerRequestCreateInput) => GamerRequestPromise;
  updateGamerRequest: (args: {
    data: GamerRequestUpdateInput;
    where: GamerRequestWhereUniqueInput;
  }) => GamerRequestPromise;
  updateManyGamerRequests: (args: {
    data: GamerRequestUpdateManyMutationInput;
    where?: GamerRequestWhereInput;
  }) => BatchPayloadPromise;
  upsertGamerRequest: (args: {
    where: GamerRequestWhereUniqueInput;
    create: GamerRequestCreateInput;
    update: GamerRequestUpdateInput;
  }) => GamerRequestPromise;
  deleteGamerRequest: (
    where: GamerRequestWhereUniqueInput
  ) => GamerRequestPromise;
  deleteManyGamerRequests: (
    where?: GamerRequestWhereInput
  ) => BatchPayloadPromise;
  createGamerTag: (data: GamerTagCreateInput) => GamerTagPromise;
  updateGamerTag: (args: {
    data: GamerTagUpdateInput;
    where: GamerTagWhereUniqueInput;
  }) => GamerTagPromise;
  updateManyGamerTags: (args: {
    data: GamerTagUpdateManyMutationInput;
    where?: GamerTagWhereInput;
  }) => BatchPayloadPromise;
  upsertGamerTag: (args: {
    where: GamerTagWhereUniqueInput;
    create: GamerTagCreateInput;
    update: GamerTagUpdateInput;
  }) => GamerTagPromise;
  deleteGamerTag: (where: GamerTagWhereUniqueInput) => GamerTagPromise;
  deleteManyGamerTags: (where?: GamerTagWhereInput) => BatchPayloadPromise;
  createGamingSession: (data: GamingSessionCreateInput) => GamingSessionPromise;
  updateGamingSession: (args: {
    data: GamingSessionUpdateInput;
    where: GamingSessionWhereUniqueInput;
  }) => GamingSessionPromise;
  updateManyGamingSessions: (args: {
    data: GamingSessionUpdateManyMutationInput;
    where?: GamingSessionWhereInput;
  }) => BatchPayloadPromise;
  upsertGamingSession: (args: {
    where: GamingSessionWhereUniqueInput;
    create: GamingSessionCreateInput;
    update: GamingSessionUpdateInput;
  }) => GamingSessionPromise;
  deleteGamingSession: (
    where: GamingSessionWhereUniqueInput
  ) => GamingSessionPromise;
  deleteManyGamingSessions: (
    where?: GamingSessionWhereInput
  ) => BatchPayloadPromise;
  createGamingSessionIndex: (
    data: GamingSessionIndexCreateInput
  ) => GamingSessionIndexPromise;
  updateGamingSessionIndex: (args: {
    data: GamingSessionIndexUpdateInput;
    where: GamingSessionIndexWhereUniqueInput;
  }) => GamingSessionIndexPromise;
  updateManyGamingSessionIndexes: (args: {
    data: GamingSessionIndexUpdateManyMutationInput;
    where?: GamingSessionIndexWhereInput;
  }) => BatchPayloadPromise;
  upsertGamingSessionIndex: (args: {
    where: GamingSessionIndexWhereUniqueInput;
    create: GamingSessionIndexCreateInput;
    update: GamingSessionIndexUpdateInput;
  }) => GamingSessionIndexPromise;
  deleteGamingSessionIndex: (
    where: GamingSessionIndexWhereUniqueInput
  ) => GamingSessionIndexPromise;
  deleteManyGamingSessionIndexes: (
    where?: GamingSessionIndexWhereInput
  ) => BatchPayloadPromise;
  createGamingTimeSlot: (
    data: GamingTimeSlotCreateInput
  ) => GamingTimeSlotPromise;
  updateGamingTimeSlot: (args: {
    data: GamingTimeSlotUpdateInput;
    where: GamingTimeSlotWhereUniqueInput;
  }) => GamingTimeSlotPromise;
  updateManyGamingTimeSlots: (args: {
    data: GamingTimeSlotUpdateManyMutationInput;
    where?: GamingTimeSlotWhereInput;
  }) => BatchPayloadPromise;
  upsertGamingTimeSlot: (args: {
    where: GamingTimeSlotWhereUniqueInput;
    create: GamingTimeSlotCreateInput;
    update: GamingTimeSlotUpdateInput;
  }) => GamingTimeSlotPromise;
  deleteGamingTimeSlot: (
    where: GamingTimeSlotWhereUniqueInput
  ) => GamingTimeSlotPromise;
  deleteManyGamingTimeSlots: (
    where?: GamingTimeSlotWhereInput
  ) => BatchPayloadPromise;
  createNotification: (data: NotificationCreateInput) => NotificationPromise;
  updateNotification: (args: {
    data: NotificationUpdateInput;
    where: NotificationWhereUniqueInput;
  }) => NotificationPromise;
  updateManyNotifications: (args: {
    data: NotificationUpdateManyMutationInput;
    where?: NotificationWhereInput;
  }) => BatchPayloadPromise;
  upsertNotification: (args: {
    where: NotificationWhereUniqueInput;
    create: NotificationCreateInput;
    update: NotificationUpdateInput;
  }) => NotificationPromise;
  deleteNotification: (
    where: NotificationWhereUniqueInput
  ) => NotificationPromise;
  deleteManyNotifications: (
    where?: NotificationWhereInput
  ) => BatchPayloadPromise;
  createPCLauncher: (data: PCLauncherCreateInput) => PCLauncherPromise;
  updatePCLauncher: (args: {
    data: PCLauncherUpdateInput;
    where: PCLauncherWhereUniqueInput;
  }) => PCLauncherPromise;
  updateManyPCLaunchers: (args: {
    data: PCLauncherUpdateManyMutationInput;
    where?: PCLauncherWhereInput;
  }) => BatchPayloadPromise;
  upsertPCLauncher: (args: {
    where: PCLauncherWhereUniqueInput;
    create: PCLauncherCreateInput;
    update: PCLauncherUpdateInput;
  }) => PCLauncherPromise;
  deletePCLauncher: (where: PCLauncherWhereUniqueInput) => PCLauncherPromise;
  deleteManyPCLaunchers: (where?: PCLauncherWhereInput) => BatchPayloadPromise;
  createRequirement: (data: RequirementCreateInput) => RequirementPromise;
  updateRequirement: (args: {
    data: RequirementUpdateInput;
    where: RequirementWhereUniqueInput;
  }) => RequirementPromise;
  updateManyRequirements: (args: {
    data: RequirementUpdateManyMutationInput;
    where?: RequirementWhereInput;
  }) => BatchPayloadPromise;
  upsertRequirement: (args: {
    where: RequirementWhereUniqueInput;
    create: RequirementCreateInput;
    update: RequirementUpdateInput;
  }) => RequirementPromise;
  deleteRequirement: (where: RequirementWhereUniqueInput) => RequirementPromise;
  deleteManyRequirements: (
    where?: RequirementWhereInput
  ) => BatchPayloadPromise;
  createSavedCard: (data: SavedCardCreateInput) => SavedCardPromise;
  updateSavedCard: (args: {
    data: SavedCardUpdateInput;
    where: SavedCardWhereUniqueInput;
  }) => SavedCardPromise;
  updateManySavedCards: (args: {
    data: SavedCardUpdateManyMutationInput;
    where?: SavedCardWhereInput;
  }) => BatchPayloadPromise;
  upsertSavedCard: (args: {
    where: SavedCardWhereUniqueInput;
    create: SavedCardCreateInput;
    update: SavedCardUpdateInput;
  }) => SavedCardPromise;
  deleteSavedCard: (where: SavedCardWhereUniqueInput) => SavedCardPromise;
  deleteManySavedCards: (where?: SavedCardWhereInput) => BatchPayloadPromise;
  createSessionReview: (data: SessionReviewCreateInput) => SessionReviewPromise;
  updateSessionReview: (args: {
    data: SessionReviewUpdateInput;
    where: SessionReviewWhereUniqueInput;
  }) => SessionReviewPromise;
  updateManySessionReviews: (args: {
    data: SessionReviewUpdateManyMutationInput;
    where?: SessionReviewWhereInput;
  }) => BatchPayloadPromise;
  upsertSessionReview: (args: {
    where: SessionReviewWhereUniqueInput;
    create: SessionReviewCreateInput;
    update: SessionReviewUpdateInput;
  }) => SessionReviewPromise;
  deleteSessionReview: (
    where: SessionReviewWhereUniqueInput
  ) => SessionReviewPromise;
  deleteManySessionReviews: (
    where?: SessionReviewWhereInput
  ) => BatchPayloadPromise;
  createSessionReviewIndex: (
    data: SessionReviewIndexCreateInput
  ) => SessionReviewIndexPromise;
  updateSessionReviewIndex: (args: {
    data: SessionReviewIndexUpdateInput;
    where: SessionReviewIndexWhereUniqueInput;
  }) => SessionReviewIndexPromise;
  updateManySessionReviewIndexes: (args: {
    data: SessionReviewIndexUpdateManyMutationInput;
    where?: SessionReviewIndexWhereInput;
  }) => BatchPayloadPromise;
  upsertSessionReviewIndex: (args: {
    where: SessionReviewIndexWhereUniqueInput;
    create: SessionReviewIndexCreateInput;
    update: SessionReviewIndexUpdateInput;
  }) => SessionReviewIndexPromise;
  deleteSessionReviewIndex: (
    where: SessionReviewIndexWhereUniqueInput
  ) => SessionReviewIndexPromise;
  deleteManySessionReviewIndexes: (
    where?: SessionReviewIndexWhereInput
  ) => BatchPayloadPromise;
  createSocialMedia: (data: SocialMediaCreateInput) => SocialMediaPromise;
  updateSocialMedia: (args: {
    data: SocialMediaUpdateInput;
    where: SocialMediaWhereUniqueInput;
  }) => SocialMediaPromise;
  updateManySocialMedias: (args: {
    data: SocialMediaUpdateManyMutationInput;
    where?: SocialMediaWhereInput;
  }) => BatchPayloadPromise;
  upsertSocialMedia: (args: {
    where: SocialMediaWhereUniqueInput;
    create: SocialMediaCreateInput;
    update: SocialMediaUpdateInput;
  }) => SocialMediaPromise;
  deleteSocialMedia: (where: SocialMediaWhereUniqueInput) => SocialMediaPromise;
  deleteManySocialMedias: (
    where?: SocialMediaWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserIndex: (data: UserIndexCreateInput) => UserIndexPromise;
  updateUserIndex: (args: {
    data: UserIndexUpdateInput;
    where: UserIndexWhereUniqueInput;
  }) => UserIndexPromise;
  updateManyUserIndexes: (args: {
    data: UserIndexUpdateManyMutationInput;
    where?: UserIndexWhereInput;
  }) => BatchPayloadPromise;
  upsertUserIndex: (args: {
    where: UserIndexWhereUniqueInput;
    create: UserIndexCreateInput;
    update: UserIndexUpdateInput;
  }) => UserIndexPromise;
  deleteUserIndex: (where: UserIndexWhereUniqueInput) => UserIndexPromise;
  deleteManyUserIndexes: (where?: UserIndexWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  bookedPlayer: (
    where?: BookedPlayerSubscriptionWhereInput
  ) => BookedPlayerSubscriptionPayloadSubscription;
  booking: (
    where?: BookingSubscriptionWhereInput
  ) => BookingSubscriptionPayloadSubscription;
  bookingInvite: (
    where?: BookingInviteSubscriptionWhereInput
  ) => BookingInviteSubscriptionPayloadSubscription;
  discount: (
    where?: DiscountSubscriptionWhereInput
  ) => DiscountSubscriptionPayloadSubscription;
  friendRequest: (
    where?: FriendRequestSubscriptionWhereInput
  ) => FriendRequestSubscriptionPayloadSubscription;
  game: (
    where?: GameSubscriptionWhereInput
  ) => GameSubscriptionPayloadSubscription;
  gameIndex: (
    where?: GameIndexSubscriptionWhereInput
  ) => GameIndexSubscriptionPayloadSubscription;
  gamerRequest: (
    where?: GamerRequestSubscriptionWhereInput
  ) => GamerRequestSubscriptionPayloadSubscription;
  gamerTag: (
    where?: GamerTagSubscriptionWhereInput
  ) => GamerTagSubscriptionPayloadSubscription;
  gamingSession: (
    where?: GamingSessionSubscriptionWhereInput
  ) => GamingSessionSubscriptionPayloadSubscription;
  gamingSessionIndex: (
    where?: GamingSessionIndexSubscriptionWhereInput
  ) => GamingSessionIndexSubscriptionPayloadSubscription;
  gamingTimeSlot: (
    where?: GamingTimeSlotSubscriptionWhereInput
  ) => GamingTimeSlotSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  pCLauncher: (
    where?: PCLauncherSubscriptionWhereInput
  ) => PCLauncherSubscriptionPayloadSubscription;
  requirement: (
    where?: RequirementSubscriptionWhereInput
  ) => RequirementSubscriptionPayloadSubscription;
  savedCard: (
    where?: SavedCardSubscriptionWhereInput
  ) => SavedCardSubscriptionPayloadSubscription;
  sessionReview: (
    where?: SessionReviewSubscriptionWhereInput
  ) => SessionReviewSubscriptionPayloadSubscription;
  sessionReviewIndex: (
    where?: SessionReviewIndexSubscriptionWhereInput
  ) => SessionReviewIndexSubscriptionPayloadSubscription;
  socialMedia: (
    where?: SocialMediaSubscriptionWhereInput
  ) => SocialMediaSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userIndex: (
    where?: UserIndexSubscriptionWhereInput
  ) => UserIndexSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type BookingInviteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "sent_ASC"
  | "sent_DESC"
  | "accepted_ASC"
  | "accepted_DESC";

export type PlayerOrSession = "PLAYER" | "SESSION";

export type NotificationType =
  | "CANCELLED_BOOKING"
  | "CANCELLED_TIMESLOT"
  | "GAMER_PUSHED_BACK_SLOT"
  | "ACCEPTED_GAMER_REQUEST"
  | "DENIED_GAMER_REQUEST"
  | "FRIEND_REQUEST"
  | "ACCEPTED_TIMESLOT_REQUEST"
  | "TIMESLOT_REQUEST"
  | "BOOKED_TIMESLOT"
  | "TIMESLOT_INVITE"
  | "FRIEND_CANCELLED_BOOKING"
  | "FRIEND_CANCELLED_THEIR_SLOT"
  | "ACCEPTED_TIMESLOT_INVITE"
  | "ACCEPTED_FRIEND_REQUEST";

export type UserIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "username_ASC"
  | "username_DESC"
  | "displayName_ASC"
  | "displayName_DESC"
  | "name_ASC"
  | "name_DESC";

export type BookedPlayerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Gender = "MALE" | "FEMALE" | "OTHER";

export type BookingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "charge_ASC"
  | "charge_DESC"
  | "numSlots_ASC"
  | "numSlots_DESC"
  | "numPlayers_ASC"
  | "numPlayers_DESC"
  | "total_ASC"
  | "total_DESC"
  | "cancelled_ASC"
  | "cancelled_DESC";

export type PCLauncherOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "epic_ASC"
  | "epic_DESC"
  | "steam_ASC"
  | "steam_DESC"
  | "origin_ASC"
  | "origin_DESC"
  | "gog_ASC"
  | "gog_DESC"
  | "battlenet_ASC"
  | "battlenet_DESC"
  | "uplay_ASC"
  | "uplay_DESC"
  | "bethesda_ASC"
  | "bethesda_DESC"
  | "itch_ASC"
  | "itch_DESC"
  | "windows_ASC"
  | "windows_DESC"
  | "riot_ASC"
  | "riot_DESC";

export type GamingTimeSlotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "length_ASC"
  | "length_DESC"
  | "slots_ASC"
  | "slots_DESC";

export type GamingSessionIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "gamer_ASC"
  | "gamer_DESC"
  | "game_ASC"
  | "game_DESC"
  | "launcher_ASC"
  | "launcher_DESC";

export type DiscountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "percentage_ASC"
  | "percentage_DESC"
  | "threshold_ASC"
  | "threshold_DESC"
  | "playerOrSession_ASC"
  | "playerOrSession_DESC";

export type GamerRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "addToOccupations_ASC"
  | "addToOccupations_DESC";

export type RequirementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "msg_ASC"
  | "msg_DESC";

export type GameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "launcher_ASC"
  | "launcher_DESC"
  | "numSessions_ASC"
  | "numSessions_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "banner_ASC"
  | "banner_DESC";

export type Role = "USER" | "GAMER" | "ADMIN";

export type SavedCardOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "cardId_ASC"
  | "cardId_DESC"
  | "default_ASC"
  | "default_DESC"
  | "lastFour_ASC"
  | "lastFour_DESC"
  | "brand_ASC"
  | "brand_DESC";

export type SessionReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "text_ASC"
  | "text_DESC"
  | "rating_ASC"
  | "rating_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type Tags =
  | "ACTION"
  | "ADVENTURE_GAME"
  | "CARD_AND_BOARD_GAME"
  | "COMPILATION"
  | "DRIVING_SLASH_RACING_GAME"
  | "EDUCATIONAL_GAME"
  | "FIGHTING"
  | "FLIGHT_SIMULATOR"
  | "FPS"
  | "GAMBLING_GAME"
  | "HIDDEN_OBJECTS"
  | "HORROR"
  | "INDIE_GAME"
  | "METROIDVANIA"
  | "MMORPG"
  | "MOBA"
  | "OPEN_WORLD"
  | "PINBALL"
  | "PLATFORMER"
  | "POINT_AND_CLICK"
  | "PUZZLE"
  | "RHYTHM_AND_MUSIC_GAME"
  | "ROGUELIKE"
  | "RPG"
  | "RTS"
  | "SERIES_COLON_SOULS"
  | "SHOOT_HYPHEN_EM_UP"
  | "SHOOTER"
  | "SIMULATION"
  | "SPORTS_GAME"
  | "STEALTH"
  | "STRATEGY"
  | "SURVIVAL"
  | "VISUAL_NOVEL";

export type SessionReviewIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "text_ASC"
  | "text_DESC";

export type Launcher =
  | "EPIC"
  | "STEAM"
  | "ORIGIN"
  | "BATTLENET"
  | "GOG"
  | "UPLAY"
  | "BETHESDA"
  | "ITCH"
  | "WINDOWS"
  | "RIOT";

export type GamerTagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "psn_ASC"
  | "psn_DESC"
  | "xbl_ASC"
  | "xbl_DESC"
  | "nso_ASC"
  | "nso_DESC";

export type GamingSessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "length_ASC"
  | "length_DESC"
  | "price_ASC"
  | "price_DESC"
  | "launcher_ASC"
  | "launcher_DESC"
  | "system_ASC"
  | "system_DESC"
  | "type_ASC"
  | "type_DESC"
  | "slots_ASC"
  | "slots_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "views_ASC"
  | "views_DESC"
  | "retired_ASC"
  | "retired_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "email_ASC"
  | "email_DESC"
  | "username_ASC"
  | "username_DESC"
  | "displayName_ASC"
  | "displayName_DESC"
  | "password_ASC"
  | "password_DESC"
  | "profilePicture_ASC"
  | "profilePicture_DESC"
  | "banner_ASC"
  | "banner_DESC"
  | "connectedStripeId_ASC"
  | "connectedStripeId_DESC"
  | "customerStripeId_ASC"
  | "customerStripeId_DESC"
  | "gamerIsSetup_ASC"
  | "gamerIsSetup_DESC"
  | "name_ASC"
  | "name_DESC"
  | "aboutMe_ASC"
  | "aboutMe_DESC"
  | "setup_ASC"
  | "setup_DESC"
  | "resetPasswordToken_ASC"
  | "resetPasswordToken_DESC"
  | "resetPasswordExpires_ASC"
  | "resetPasswordExpires_DESC"
  | "views_ASC"
  | "views_DESC"
  | "role_ASC"
  | "role_DESC";

export type TypeOfGame = "CUSTOM" | "CASUAL" | "COMPETITIVE";

export type System = "PS4" | "PC" | "XBOX_ONE" | "NINTENDO_SWITCH";

export type GameIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "launcher_ASC"
  | "launcher_DESC";

export type Occupations =
  | "CELEBRITY"
  | "INFLUENCER"
  | "ENTERTAINER"
  | "STREAMER"
  | "YOUTUBER"
  | "MEDIA"
  | "SPORTS_PERSONALITY"
  | "INTERNET_PERSONALITY"
  | "ATHLETE"
  | "PROFESIONAL_GAMER"
  | "ACTOR"
  | "COMEDIAN"
  | "ROCK_STAR"
  | "RAPPER"
  | "SINGER"
  | "MUSICIAN"
  | "POLITICIAN"
  | "DJ"
  | "MUSIC_PRODUCER"
  | "ENTREPRENEUR"
  | "ARTIST"
  | "ACTRESS"
  | "MODEL"
  | "ADULT_PERFORMER";

export type SocialMediaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "twitter_ASC"
  | "twitter_DESC"
  | "facebook_ASC"
  | "facebook_DESC"
  | "youtube_ASC"
  | "youtube_DESC"
  | "instagram_ASC"
  | "instagram_DESC"
  | "twitch_ASC"
  | "twitch_DESC"
  | "snapchat_ASC"
  | "snapchat_DESC";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "text_ASC"
  | "text_DESC"
  | "viewed_ASC"
  | "viewed_DESC";

export type FriendRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface UserUpdateOneRequiredWithoutInvitesInput {
  create?: Maybe<UserCreateWithoutInvitesInput>;
  update?: Maybe<UserUpdateWithoutInvitesDataInput>;
  upsert?: Maybe<UserUpsertWithoutInvitesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type BookedPlayerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DiscountUpsertWithWhereUniqueNestedInput {
  where: DiscountWhereUniqueInput;
  update: DiscountUpdateDataInput;
  create: DiscountCreateInput;
}

export interface DiscountWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  percentage?: Maybe<Int>;
  percentage_not?: Maybe<Int>;
  percentage_in?: Maybe<Int[] | Int>;
  percentage_not_in?: Maybe<Int[] | Int>;
  percentage_lt?: Maybe<Int>;
  percentage_lte?: Maybe<Int>;
  percentage_gt?: Maybe<Int>;
  percentage_gte?: Maybe<Int>;
  threshold?: Maybe<Int>;
  threshold_not?: Maybe<Int>;
  threshold_in?: Maybe<Int[] | Int>;
  threshold_not_in?: Maybe<Int[] | Int>;
  threshold_lt?: Maybe<Int>;
  threshold_lte?: Maybe<Int>;
  threshold_gt?: Maybe<Int>;
  threshold_gte?: Maybe<Int>;
  playerOrSession?: Maybe<PlayerOrSession>;
  playerOrSession_not?: Maybe<PlayerOrSession>;
  playerOrSession_in?: Maybe<PlayerOrSession[] | PlayerOrSession>;
  playerOrSession_not_in?: Maybe<PlayerOrSession[] | PlayerOrSession>;
  AND?: Maybe<DiscountWhereInput[] | DiscountWhereInput>;
  OR?: Maybe<DiscountWhereInput[] | DiscountWhereInput>;
  NOT?: Maybe<DiscountWhereInput[] | DiscountWhereInput>;
}

export interface DiscountScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  percentage?: Maybe<Int>;
  percentage_not?: Maybe<Int>;
  percentage_in?: Maybe<Int[] | Int>;
  percentage_not_in?: Maybe<Int[] | Int>;
  percentage_lt?: Maybe<Int>;
  percentage_lte?: Maybe<Int>;
  percentage_gt?: Maybe<Int>;
  percentage_gte?: Maybe<Int>;
  threshold?: Maybe<Int>;
  threshold_not?: Maybe<Int>;
  threshold_in?: Maybe<Int[] | Int>;
  threshold_not_in?: Maybe<Int[] | Int>;
  threshold_lt?: Maybe<Int>;
  threshold_lte?: Maybe<Int>;
  threshold_gt?: Maybe<Int>;
  threshold_gte?: Maybe<Int>;
  playerOrSession?: Maybe<PlayerOrSession>;
  playerOrSession_not?: Maybe<PlayerOrSession>;
  playerOrSession_in?: Maybe<PlayerOrSession[] | PlayerOrSession>;
  playerOrSession_not_in?: Maybe<PlayerOrSession[] | PlayerOrSession>;
  AND?: Maybe<DiscountScalarWhereInput[] | DiscountScalarWhereInput>;
  OR?: Maybe<DiscountScalarWhereInput[] | DiscountScalarWhereInput>;
  NOT?: Maybe<DiscountScalarWhereInput[] | DiscountScalarWhereInput>;
}

export interface RequirementWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  msg?: Maybe<String>;
  msg_not?: Maybe<String>;
  msg_in?: Maybe<String[] | String>;
  msg_not_in?: Maybe<String[] | String>;
  msg_lt?: Maybe<String>;
  msg_lte?: Maybe<String>;
  msg_gt?: Maybe<String>;
  msg_gte?: Maybe<String>;
  msg_contains?: Maybe<String>;
  msg_not_contains?: Maybe<String>;
  msg_starts_with?: Maybe<String>;
  msg_not_starts_with?: Maybe<String>;
  msg_ends_with?: Maybe<String>;
  msg_not_ends_with?: Maybe<String>;
  AND?: Maybe<RequirementWhereInput[] | RequirementWhereInput>;
  OR?: Maybe<RequirementWhereInput[] | RequirementWhereInput>;
  NOT?: Maybe<RequirementWhereInput[] | RequirementWhereInput>;
}

export interface DiscountUpdateManyWithWhereNestedInput {
  where: DiscountScalarWhereInput;
  data: DiscountUpdateManyDataInput;
}

export interface GameWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  sessions_every?: Maybe<GamingSessionWhereInput>;
  sessions_some?: Maybe<GamingSessionWhereInput>;
  sessions_none?: Maybe<GamingSessionWhereInput>;
  launcher?: Maybe<Launcher>;
  launcher_not?: Maybe<Launcher>;
  launcher_in?: Maybe<Launcher[] | Launcher>;
  launcher_not_in?: Maybe<Launcher[] | Launcher>;
  numSessions?: Maybe<Int>;
  numSessions_not?: Maybe<Int>;
  numSessions_in?: Maybe<Int[] | Int>;
  numSessions_not_in?: Maybe<Int[] | Int>;
  numSessions_lt?: Maybe<Int>;
  numSessions_lte?: Maybe<Int>;
  numSessions_gt?: Maybe<Int>;
  numSessions_gte?: Maybe<Int>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  banner?: Maybe<String>;
  banner_not?: Maybe<String>;
  banner_in?: Maybe<String[] | String>;
  banner_not_in?: Maybe<String[] | String>;
  banner_lt?: Maybe<String>;
  banner_lte?: Maybe<String>;
  banner_gt?: Maybe<String>;
  banner_gte?: Maybe<String>;
  banner_contains?: Maybe<String>;
  banner_not_contains?: Maybe<String>;
  banner_starts_with?: Maybe<String>;
  banner_not_starts_with?: Maybe<String>;
  banner_ends_with?: Maybe<String>;
  banner_not_ends_with?: Maybe<String>;
  AND?: Maybe<GameWhereInput[] | GameWhereInput>;
  OR?: Maybe<GameWhereInput[] | GameWhereInput>;
  NOT?: Maybe<GameWhereInput[] | GameWhereInput>;
}

export interface BookedPlayerUpdateInput {
  player?: Maybe<UserUpdateOneRequiredInput>;
  booking?: Maybe<BookingUpdateOneRequiredWithoutPlayersInput>;
  timeslot?: Maybe<GamingTimeSlotUpdateOneRequiredWithoutPlayersInput>;
}

export interface SocialMediaCreateInput {
  twitter?: Maybe<String>;
  facebook?: Maybe<String>;
  youtube?: Maybe<String>;
  instagram?: Maybe<String>;
  twitch?: Maybe<String>;
  snapchat?: Maybe<String>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface DiscountUpdateManyDataInput {
  percentage?: Maybe<Int>;
  threshold?: Maybe<Int>;
  playerOrSession?: Maybe<PlayerOrSession>;
}

export interface UserUpdateDataInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionUpdateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotUpdateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardUpdateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteUpdateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutUserInput>;
  friends?: Maybe<UserUpdateManyInput>;
  gamertags?: Maybe<GamerTagUpdateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index?: Maybe<UserIndexUpdateOneRequiredWithoutUserInput>;
}

export interface GamerTagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  psn?: Maybe<String>;
  psn_not?: Maybe<String>;
  psn_in?: Maybe<String[] | String>;
  psn_not_in?: Maybe<String[] | String>;
  psn_lt?: Maybe<String>;
  psn_lte?: Maybe<String>;
  psn_gt?: Maybe<String>;
  psn_gte?: Maybe<String>;
  psn_contains?: Maybe<String>;
  psn_not_contains?: Maybe<String>;
  psn_starts_with?: Maybe<String>;
  psn_not_starts_with?: Maybe<String>;
  psn_ends_with?: Maybe<String>;
  psn_not_ends_with?: Maybe<String>;
  xbl?: Maybe<String>;
  xbl_not?: Maybe<String>;
  xbl_in?: Maybe<String[] | String>;
  xbl_not_in?: Maybe<String[] | String>;
  xbl_lt?: Maybe<String>;
  xbl_lte?: Maybe<String>;
  xbl_gt?: Maybe<String>;
  xbl_gte?: Maybe<String>;
  xbl_contains?: Maybe<String>;
  xbl_not_contains?: Maybe<String>;
  xbl_starts_with?: Maybe<String>;
  xbl_not_starts_with?: Maybe<String>;
  xbl_ends_with?: Maybe<String>;
  xbl_not_ends_with?: Maybe<String>;
  nso?: Maybe<String>;
  nso_not?: Maybe<String>;
  nso_in?: Maybe<String[] | String>;
  nso_not_in?: Maybe<String[] | String>;
  nso_lt?: Maybe<String>;
  nso_lte?: Maybe<String>;
  nso_gt?: Maybe<String>;
  nso_gte?: Maybe<String>;
  nso_contains?: Maybe<String>;
  nso_not_contains?: Maybe<String>;
  nso_starts_with?: Maybe<String>;
  nso_not_starts_with?: Maybe<String>;
  nso_ends_with?: Maybe<String>;
  nso_not_ends_with?: Maybe<String>;
  pc?: Maybe<PCLauncherWhereInput>;
  AND?: Maybe<GamerTagWhereInput[] | GamerTagWhereInput>;
  OR?: Maybe<GamerTagWhereInput[] | GamerTagWhereInput>;
  NOT?: Maybe<GamerTagWhereInput[] | GamerTagWhereInput>;
}

export interface UserUpdateoccupationsInput {
  set?: Maybe<Occupations[] | Occupations>;
}

export interface SessionReviewWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  session?: Maybe<GamingSessionWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  rating?: Maybe<Int>;
  rating_not?: Maybe<Int>;
  rating_in?: Maybe<Int[] | Int>;
  rating_not_in?: Maybe<Int[] | Int>;
  rating_lt?: Maybe<Int>;
  rating_lte?: Maybe<Int>;
  rating_gt?: Maybe<Int>;
  rating_gte?: Maybe<Int>;
  AND?: Maybe<SessionReviewWhereInput[] | SessionReviewWhereInput>;
  OR?: Maybe<SessionReviewWhereInput[] | SessionReviewWhereInput>;
  NOT?: Maybe<SessionReviewWhereInput[] | SessionReviewWhereInput>;
}

export interface GamingSessionUpdateManyWithoutGamersInput {
  create?: Maybe<
    | GamingSessionCreateWithoutGamersInput[]
    | GamingSessionCreateWithoutGamersInput
  >;
  delete?: Maybe<
    GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput
  >;
  connect?: Maybe<
    GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput
  >;
  set?: Maybe<GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput>;
  disconnect?: Maybe<
    GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput
  >;
  update?: Maybe<
    | GamingSessionUpdateWithWhereUniqueWithoutGamersInput[]
    | GamingSessionUpdateWithWhereUniqueWithoutGamersInput
  >;
  upsert?: Maybe<
    | GamingSessionUpsertWithWhereUniqueWithoutGamersInput[]
    | GamingSessionUpsertWithWhereUniqueWithoutGamersInput
  >;
  deleteMany?: Maybe<
    GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput
  >;
  updateMany?: Maybe<
    | GamingSessionUpdateManyWithWhereNestedInput[]
    | GamingSessionUpdateManyWithWhereNestedInput
  >;
}

export interface SavedCardWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  cardId?: Maybe<String>;
  cardId_not?: Maybe<String>;
  cardId_in?: Maybe<String[] | String>;
  cardId_not_in?: Maybe<String[] | String>;
  cardId_lt?: Maybe<String>;
  cardId_lte?: Maybe<String>;
  cardId_gt?: Maybe<String>;
  cardId_gte?: Maybe<String>;
  cardId_contains?: Maybe<String>;
  cardId_not_contains?: Maybe<String>;
  cardId_starts_with?: Maybe<String>;
  cardId_not_starts_with?: Maybe<String>;
  cardId_ends_with?: Maybe<String>;
  cardId_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  lastFour?: Maybe<String>;
  lastFour_not?: Maybe<String>;
  lastFour_in?: Maybe<String[] | String>;
  lastFour_not_in?: Maybe<String[] | String>;
  lastFour_lt?: Maybe<String>;
  lastFour_lte?: Maybe<String>;
  lastFour_gt?: Maybe<String>;
  lastFour_gte?: Maybe<String>;
  lastFour_contains?: Maybe<String>;
  lastFour_not_contains?: Maybe<String>;
  lastFour_starts_with?: Maybe<String>;
  lastFour_not_starts_with?: Maybe<String>;
  lastFour_ends_with?: Maybe<String>;
  lastFour_not_ends_with?: Maybe<String>;
  brand?: Maybe<String>;
  brand_not?: Maybe<String>;
  brand_in?: Maybe<String[] | String>;
  brand_not_in?: Maybe<String[] | String>;
  brand_lt?: Maybe<String>;
  brand_lte?: Maybe<String>;
  brand_gt?: Maybe<String>;
  brand_gte?: Maybe<String>;
  brand_contains?: Maybe<String>;
  brand_not_contains?: Maybe<String>;
  brand_starts_with?: Maybe<String>;
  brand_not_starts_with?: Maybe<String>;
  brand_ends_with?: Maybe<String>;
  brand_not_ends_with?: Maybe<String>;
  AND?: Maybe<SavedCardWhereInput[] | SavedCardWhereInput>;
  OR?: Maybe<SavedCardWhereInput[] | SavedCardWhereInput>;
  NOT?: Maybe<SavedCardWhereInput[] | SavedCardWhereInput>;
}

export interface GamingSessionUpdateWithWhereUniqueWithoutGamersInput {
  where: GamingSessionWhereUniqueInput;
  data: GamingSessionUpdateWithoutGamersDataInput;
}

export interface FriendRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  to?: Maybe<UserWhereInput>;
  from?: Maybe<UserWhereInput>;
  notification?: Maybe<NotificationWhereInput>;
  AND?: Maybe<FriendRequestWhereInput[] | FriendRequestWhereInput>;
  OR?: Maybe<FriendRequestWhereInput[] | FriendRequestWhereInput>;
  NOT?: Maybe<FriendRequestWhereInput[] | FriendRequestWhereInput>;
}

export interface GamingSessionUpdateWithoutGamersDataInput {
  creator?: Maybe<UserUpdateOneRequiredInput>;
  game?: Maybe<GameUpdateOneRequiredWithoutSessionsInput>;
  title?: Maybe<String>;
  length?: Maybe<Int>;
  price?: Maybe<Float>;
  launcher?: Maybe<Launcher>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutSessionInput>;
  system?: Maybe<System>;
  type?: Maybe<TypeOfGame>;
  slots?: Maybe<Int>;
  requirements?: Maybe<RequirementUpdateManyInput>;
  discounts?: Maybe<DiscountUpdateManyInput>;
  timeslots?: Maybe<GamingTimeSlotUpdateManyWithoutGamingSessionInput>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface SessionReviewSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SessionReviewWhereInput>;
  AND?: Maybe<
    SessionReviewSubscriptionWhereInput[] | SessionReviewSubscriptionWhereInput
  >;
  OR?: Maybe<
    SessionReviewSubscriptionWhereInput[] | SessionReviewSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SessionReviewSubscriptionWhereInput[] | SessionReviewSubscriptionWhereInput
  >;
}

export interface GameUpdateOneRequiredWithoutSessionsInput {
  create?: Maybe<GameCreateWithoutSessionsInput>;
  update?: Maybe<GameUpdateWithoutSessionsDataInput>;
  upsert?: Maybe<GameUpsertWithoutSessionsInput>;
  connect?: Maybe<GameWhereUniqueInput>;
}

export interface RequirementSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RequirementWhereInput>;
  AND?: Maybe<
    RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput
  >;
  OR?: Maybe<
    RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput
  >;
  NOT?: Maybe<
    RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput
  >;
}

export interface GameUpdateWithoutSessionsDataInput {
  name?: Maybe<String>;
  tags?: Maybe<GameUpdatetagsInput>;
  launcher?: Maybe<Launcher>;
  numSessions?: Maybe<Int>;
  picture?: Maybe<String>;
  banner?: Maybe<String>;
}

export interface PCLauncherSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PCLauncherWhereInput>;
  AND?: Maybe<
    PCLauncherSubscriptionWhereInput[] | PCLauncherSubscriptionWhereInput
  >;
  OR?: Maybe<
    PCLauncherSubscriptionWhereInput[] | PCLauncherSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PCLauncherSubscriptionWhereInput[] | PCLauncherSubscriptionWhereInput
  >;
}

export interface GameUpdatetagsInput {
  set?: Maybe<Tags[] | Tags>;
}

export interface GamingTimeSlotSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GamingTimeSlotWhereInput>;
  AND?: Maybe<
    | GamingTimeSlotSubscriptionWhereInput[]
    | GamingTimeSlotSubscriptionWhereInput
  >;
  OR?: Maybe<
    | GamingTimeSlotSubscriptionWhereInput[]
    | GamingTimeSlotSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | GamingTimeSlotSubscriptionWhereInput[]
    | GamingTimeSlotSubscriptionWhereInput
  >;
}

export interface GameUpsertWithoutSessionsInput {
  update: GameUpdateWithoutSessionsDataInput;
  create: GameCreateWithoutSessionsInput;
}

export interface GamingSessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GamingSessionWhereInput>;
  AND?: Maybe<
    GamingSessionSubscriptionWhereInput[] | GamingSessionSubscriptionWhereInput
  >;
  OR?: Maybe<
    GamingSessionSubscriptionWhereInput[] | GamingSessionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    GamingSessionSubscriptionWhereInput[] | GamingSessionSubscriptionWhereInput
  >;
}

export interface SessionReviewUpdateManyWithoutSessionInput {
  create?: Maybe<
    | SessionReviewCreateWithoutSessionInput[]
    | SessionReviewCreateWithoutSessionInput
  >;
  delete?: Maybe<
    SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput
  >;
  connect?: Maybe<
    SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput
  >;
  set?: Maybe<SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput>;
  disconnect?: Maybe<
    SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput
  >;
  update?: Maybe<
    | SessionReviewUpdateWithWhereUniqueWithoutSessionInput[]
    | SessionReviewUpdateWithWhereUniqueWithoutSessionInput
  >;
  upsert?: Maybe<
    | SessionReviewUpsertWithWhereUniqueWithoutSessionInput[]
    | SessionReviewUpsertWithWhereUniqueWithoutSessionInput
  >;
  deleteMany?: Maybe<
    SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput
  >;
  updateMany?: Maybe<
    | SessionReviewUpdateManyWithWhereNestedInput[]
    | SessionReviewUpdateManyWithWhereNestedInput
  >;
}

export interface GamerRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GamerRequestWhereInput>;
  AND?: Maybe<
    GamerRequestSubscriptionWhereInput[] | GamerRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    GamerRequestSubscriptionWhereInput[] | GamerRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    GamerRequestSubscriptionWhereInput[] | GamerRequestSubscriptionWhereInput
  >;
}

export interface SessionReviewUpdateWithWhereUniqueWithoutSessionInput {
  where: SessionReviewWhereUniqueInput;
  data: SessionReviewUpdateWithoutSessionDataInput;
}

export interface GameSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GameWhereInput>;
  AND?: Maybe<GameSubscriptionWhereInput[] | GameSubscriptionWhereInput>;
  OR?: Maybe<GameSubscriptionWhereInput[] | GameSubscriptionWhereInput>;
  NOT?: Maybe<GameSubscriptionWhereInput[] | GameSubscriptionWhereInput>;
}

export interface SessionReviewUpdateWithoutSessionDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutReviewsInput>;
  text?: Maybe<String>;
  rating?: Maybe<Int>;
}

export interface FriendRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FriendRequestWhereInput>;
  AND?: Maybe<
    FriendRequestSubscriptionWhereInput[] | FriendRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    FriendRequestSubscriptionWhereInput[] | FriendRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    FriendRequestSubscriptionWhereInput[] | FriendRequestSubscriptionWhereInput
  >;
}

export interface UserUpdateOneRequiredWithoutReviewsInput {
  create?: Maybe<UserCreateWithoutReviewsInput>;
  update?: Maybe<UserUpdateWithoutReviewsDataInput>;
  upsert?: Maybe<UserUpsertWithoutReviewsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BookingInviteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BookingInviteWhereInput>;
  AND?: Maybe<
    BookingInviteSubscriptionWhereInput[] | BookingInviteSubscriptionWhereInput
  >;
  OR?: Maybe<
    BookingInviteSubscriptionWhereInput[] | BookingInviteSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BookingInviteSubscriptionWhereInput[] | BookingInviteSubscriptionWhereInput
  >;
}

export interface UserUpdateWithoutReviewsDataInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionUpdateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotUpdateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardUpdateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteUpdateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  friends?: Maybe<UserUpdateManyInput>;
  gamertags?: Maybe<GamerTagUpdateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index?: Maybe<UserIndexUpdateOneRequiredWithoutUserInput>;
}

export interface BookingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BookingWhereInput>;
  AND?: Maybe<BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput>;
  OR?: Maybe<BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput>;
  NOT?: Maybe<BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput>;
}

export interface GamingTimeSlotUpdateManyWithoutGamersInput {
  create?: Maybe<
    | GamingTimeSlotCreateWithoutGamersInput[]
    | GamingTimeSlotCreateWithoutGamersInput
  >;
  delete?: Maybe<
    GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput
  >;
  connect?: Maybe<
    GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput
  >;
  set?: Maybe<
    GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput
  >;
  disconnect?: Maybe<
    GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput
  >;
  update?: Maybe<
    | GamingTimeSlotUpdateWithWhereUniqueWithoutGamersInput[]
    | GamingTimeSlotUpdateWithWhereUniqueWithoutGamersInput
  >;
  upsert?: Maybe<
    | GamingTimeSlotUpsertWithWhereUniqueWithoutGamersInput[]
    | GamingTimeSlotUpsertWithWhereUniqueWithoutGamersInput
  >;
  deleteMany?: Maybe<
    GamingTimeSlotScalarWhereInput[] | GamingTimeSlotScalarWhereInput
  >;
  updateMany?: Maybe<
    | GamingTimeSlotUpdateManyWithWhereNestedInput[]
    | GamingTimeSlotUpdateManyWithWhereNestedInput
  >;
}

export interface UserIndexUpdateManyMutationInput {
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  name?: Maybe<String>;
}

export interface GamingTimeSlotUpdateWithWhereUniqueWithoutGamersInput {
  where: GamingTimeSlotWhereUniqueInput;
  data: GamingTimeSlotUpdateWithoutGamersDataInput;
}

export interface UserUpsertWithoutIndexInput {
  update: UserUpdateWithoutIndexDataInput;
  create: UserCreateWithoutIndexInput;
}

export interface GamingTimeSlotUpdateWithoutGamersDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  gamingSession?: Maybe<GamingSessionUpdateOneRequiredWithoutTimeslotsInput>;
  bookings?: Maybe<BookingUpdateManyWithoutTimeslotInput>;
  players?: Maybe<BookedPlayerUpdateManyWithoutTimeslotInput>;
  length?: Maybe<Int>;
  slots?: Maybe<Int>;
}

export interface UserUpdateOneRequiredWithoutIndexInput {
  create?: Maybe<UserCreateWithoutIndexInput>;
  update?: Maybe<UserUpdateWithoutIndexDataInput>;
  upsert?: Maybe<UserUpsertWithoutIndexInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface GamingSessionUpdateOneRequiredWithoutTimeslotsInput {
  create?: Maybe<GamingSessionCreateWithoutTimeslotsInput>;
  update?: Maybe<GamingSessionUpdateWithoutTimeslotsDataInput>;
  upsert?: Maybe<GamingSessionUpsertWithoutTimeslotsInput>;
  connect?: Maybe<GamingSessionWhereUniqueInput>;
}

export interface BookedPlayerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  player?: Maybe<UserWhereInput>;
  booking?: Maybe<BookingWhereInput>;
  timeslot?: Maybe<GamingTimeSlotWhereInput>;
  AND?: Maybe<BookedPlayerWhereInput[] | BookedPlayerWhereInput>;
  OR?: Maybe<BookedPlayerWhereInput[] | BookedPlayerWhereInput>;
  NOT?: Maybe<BookedPlayerWhereInput[] | BookedPlayerWhereInput>;
}

export interface GamingSessionUpdateWithoutTimeslotsDataInput {
  gamers?: Maybe<UserUpdateManyWithoutSessionsInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  game?: Maybe<GameUpdateOneRequiredWithoutSessionsInput>;
  title?: Maybe<String>;
  length?: Maybe<Int>;
  price?: Maybe<Float>;
  launcher?: Maybe<Launcher>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutSessionInput>;
  system?: Maybe<System>;
  type?: Maybe<TypeOfGame>;
  slots?: Maybe<Int>;
  requirements?: Maybe<RequirementUpdateManyInput>;
  discounts?: Maybe<DiscountUpdateManyInput>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface UserCreateWithoutIndexInput {
  gender?: Maybe<Gender>;
  email: String;
  username: String;
  displayName: String;
  password: String;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserCreateoccupationsInput>;
  name: String;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionCreateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotCreateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteCreateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardCreateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteCreateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewCreateManyWithoutUserInput>;
  friends?: Maybe<UserCreateManyInput>;
  gamertags?: Maybe<GamerTagCreateOneWithoutUserInput>;
  role?: Maybe<Role>;
}

export interface UserUpdateManyWithoutSessionsInput {
  create?: Maybe<
    UserCreateWithoutSessionsInput[] | UserCreateWithoutSessionsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutSessionsInput[]
    | UserUpdateWithWhereUniqueWithoutSessionsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutSessionsInput[]
    | UserUpsertWithWhereUniqueWithoutSessionsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export type GameWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface UserUpdateWithWhereUniqueWithoutSessionsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSessionsDataInput;
}

export interface UserUpdateManyMutationInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  role?: Maybe<Role>;
}

export interface UserUpdateWithoutSessionsDataInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  timeSlots?: Maybe<GamingTimeSlotUpdateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardUpdateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteUpdateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutUserInput>;
  friends?: Maybe<UserUpdateManyInput>;
  gamertags?: Maybe<GamerTagUpdateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index?: Maybe<UserIndexUpdateOneRequiredWithoutUserInput>;
}

export interface SocialMediaUpdateManyMutationInput {
  twitter?: Maybe<String>;
  facebook?: Maybe<String>;
  youtube?: Maybe<String>;
  instagram?: Maybe<String>;
  twitch?: Maybe<String>;
  snapchat?: Maybe<String>;
}

export interface BookingInviteUpdateManyWithoutFromInput {
  create?: Maybe<
    BookingInviteCreateWithoutFromInput[] | BookingInviteCreateWithoutFromInput
  >;
  delete?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
  connect?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
  set?: Maybe<BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput>;
  disconnect?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
  update?: Maybe<
    | BookingInviteUpdateWithWhereUniqueWithoutFromInput[]
    | BookingInviteUpdateWithWhereUniqueWithoutFromInput
  >;
  upsert?: Maybe<
    | BookingInviteUpsertWithWhereUniqueWithoutFromInput[]
    | BookingInviteUpsertWithWhereUniqueWithoutFromInput
  >;
  deleteMany?: Maybe<
    BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput
  >;
  updateMany?: Maybe<
    | BookingInviteUpdateManyWithWhereNestedInput[]
    | BookingInviteUpdateManyWithWhereNestedInput
  >;
}

export interface SocialMediaUpdateInput {
  twitter?: Maybe<String>;
  facebook?: Maybe<String>;
  youtube?: Maybe<String>;
  instagram?: Maybe<String>;
  twitch?: Maybe<String>;
  snapchat?: Maybe<String>;
}

export interface BookingInviteUpdateWithWhereUniqueWithoutFromInput {
  where: BookingInviteWhereUniqueInput;
  data: BookingInviteUpdateWithoutFromDataInput;
}

export interface BookingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  charge?: Maybe<String>;
  charge_not?: Maybe<String>;
  charge_in?: Maybe<String[] | String>;
  charge_not_in?: Maybe<String[] | String>;
  charge_lt?: Maybe<String>;
  charge_lte?: Maybe<String>;
  charge_gt?: Maybe<String>;
  charge_gte?: Maybe<String>;
  charge_contains?: Maybe<String>;
  charge_not_contains?: Maybe<String>;
  charge_starts_with?: Maybe<String>;
  charge_not_starts_with?: Maybe<String>;
  charge_ends_with?: Maybe<String>;
  charge_not_ends_with?: Maybe<String>;
  numSlots?: Maybe<Int>;
  numSlots_not?: Maybe<Int>;
  numSlots_in?: Maybe<Int[] | Int>;
  numSlots_not_in?: Maybe<Int[] | Int>;
  numSlots_lt?: Maybe<Int>;
  numSlots_lte?: Maybe<Int>;
  numSlots_gt?: Maybe<Int>;
  numSlots_gte?: Maybe<Int>;
  numPlayers?: Maybe<Int>;
  numPlayers_not?: Maybe<Int>;
  numPlayers_in?: Maybe<Int[] | Int>;
  numPlayers_not_in?: Maybe<Int[] | Int>;
  numPlayers_lt?: Maybe<Int>;
  numPlayers_lte?: Maybe<Int>;
  numPlayers_gt?: Maybe<Int>;
  numPlayers_gte?: Maybe<Int>;
  players_every?: Maybe<BookedPlayerWhereInput>;
  players_some?: Maybe<BookedPlayerWhereInput>;
  players_none?: Maybe<BookedPlayerWhereInput>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  bookee?: Maybe<UserWhereInput>;
  timeslot?: Maybe<GamingTimeSlotWhereInput>;
  invites_every?: Maybe<BookingInviteWhereInput>;
  invites_some?: Maybe<BookingInviteWhereInput>;
  invites_none?: Maybe<BookingInviteWhereInput>;
  cancelled?: Maybe<Boolean>;
  cancelled_not?: Maybe<Boolean>;
  notifications_every?: Maybe<NotificationWhereInput>;
  notifications_some?: Maybe<NotificationWhereInput>;
  notifications_none?: Maybe<NotificationWhereInput>;
  AND?: Maybe<BookingWhereInput[] | BookingWhereInput>;
  OR?: Maybe<BookingWhereInput[] | BookingWhereInput>;
  NOT?: Maybe<BookingWhereInput[] | BookingWhereInput>;
}

export interface BookingInviteUpdateWithoutFromDataInput {
  startTime?: Maybe<DateTimeInput>;
  booking?: Maybe<BookingUpdateOneRequiredWithoutInvitesInput>;
  to?: Maybe<UserUpdateOneWithoutInvitesReceivedInput>;
  sent?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
  notification?: Maybe<NotificationUpdateOneWithoutBookingInviteInput>;
}

export interface SessionReviewUpsertNestedInput {
  update: SessionReviewUpdateDataInput;
  create: SessionReviewCreateInput;
}

export interface BookingUpdateOneRequiredWithoutInvitesInput {
  create?: Maybe<BookingCreateWithoutInvitesInput>;
  update?: Maybe<BookingUpdateWithoutInvitesDataInput>;
  upsert?: Maybe<BookingUpsertWithoutInvitesInput>;
  connect?: Maybe<BookingWhereUniqueInput>;
}

export type GamerRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BookingUpdateWithoutInvitesDataInput {
  charge?: Maybe<String>;
  numSlots?: Maybe<Int>;
  numPlayers?: Maybe<Int>;
  players?: Maybe<BookedPlayerUpdateManyWithoutBookingInput>;
  total?: Maybe<Float>;
  bookee?: Maybe<UserUpdateOneRequiredInput>;
  timeslot?: Maybe<GamingTimeSlotUpdateOneRequiredWithoutBookingsInput>;
  cancelled?: Maybe<Boolean>;
  notifications?: Maybe<NotificationUpdateManyWithoutBookingInput>;
}

export interface SessionReviewIndexUpdateInput {
  text?: Maybe<String>;
  sessionReview?: Maybe<SessionReviewUpdateOneRequiredInput>;
}

export interface BookedPlayerUpdateManyWithoutBookingInput {
  create?: Maybe<
    | BookedPlayerCreateWithoutBookingInput[]
    | BookedPlayerCreateWithoutBookingInput
  >;
  delete?: Maybe<BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput>;
  connect?: Maybe<
    BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput
  >;
  set?: Maybe<BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput>;
  disconnect?: Maybe<
    BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput
  >;
  update?: Maybe<
    | BookedPlayerUpdateWithWhereUniqueWithoutBookingInput[]
    | BookedPlayerUpdateWithWhereUniqueWithoutBookingInput
  >;
  upsert?: Maybe<
    | BookedPlayerUpsertWithWhereUniqueWithoutBookingInput[]
    | BookedPlayerUpsertWithWhereUniqueWithoutBookingInput
  >;
  deleteMany?: Maybe<
    BookedPlayerScalarWhereInput[] | BookedPlayerScalarWhereInput
  >;
}

export interface SocialMediaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  twitter?: Maybe<String>;
  twitter_not?: Maybe<String>;
  twitter_in?: Maybe<String[] | String>;
  twitter_not_in?: Maybe<String[] | String>;
  twitter_lt?: Maybe<String>;
  twitter_lte?: Maybe<String>;
  twitter_gt?: Maybe<String>;
  twitter_gte?: Maybe<String>;
  twitter_contains?: Maybe<String>;
  twitter_not_contains?: Maybe<String>;
  twitter_starts_with?: Maybe<String>;
  twitter_not_starts_with?: Maybe<String>;
  twitter_ends_with?: Maybe<String>;
  twitter_not_ends_with?: Maybe<String>;
  facebook?: Maybe<String>;
  facebook_not?: Maybe<String>;
  facebook_in?: Maybe<String[] | String>;
  facebook_not_in?: Maybe<String[] | String>;
  facebook_lt?: Maybe<String>;
  facebook_lte?: Maybe<String>;
  facebook_gt?: Maybe<String>;
  facebook_gte?: Maybe<String>;
  facebook_contains?: Maybe<String>;
  facebook_not_contains?: Maybe<String>;
  facebook_starts_with?: Maybe<String>;
  facebook_not_starts_with?: Maybe<String>;
  facebook_ends_with?: Maybe<String>;
  facebook_not_ends_with?: Maybe<String>;
  youtube?: Maybe<String>;
  youtube_not?: Maybe<String>;
  youtube_in?: Maybe<String[] | String>;
  youtube_not_in?: Maybe<String[] | String>;
  youtube_lt?: Maybe<String>;
  youtube_lte?: Maybe<String>;
  youtube_gt?: Maybe<String>;
  youtube_gte?: Maybe<String>;
  youtube_contains?: Maybe<String>;
  youtube_not_contains?: Maybe<String>;
  youtube_starts_with?: Maybe<String>;
  youtube_not_starts_with?: Maybe<String>;
  youtube_ends_with?: Maybe<String>;
  youtube_not_ends_with?: Maybe<String>;
  instagram?: Maybe<String>;
  instagram_not?: Maybe<String>;
  instagram_in?: Maybe<String[] | String>;
  instagram_not_in?: Maybe<String[] | String>;
  instagram_lt?: Maybe<String>;
  instagram_lte?: Maybe<String>;
  instagram_gt?: Maybe<String>;
  instagram_gte?: Maybe<String>;
  instagram_contains?: Maybe<String>;
  instagram_not_contains?: Maybe<String>;
  instagram_starts_with?: Maybe<String>;
  instagram_not_starts_with?: Maybe<String>;
  instagram_ends_with?: Maybe<String>;
  instagram_not_ends_with?: Maybe<String>;
  twitch?: Maybe<String>;
  twitch_not?: Maybe<String>;
  twitch_in?: Maybe<String[] | String>;
  twitch_not_in?: Maybe<String[] | String>;
  twitch_lt?: Maybe<String>;
  twitch_lte?: Maybe<String>;
  twitch_gt?: Maybe<String>;
  twitch_gte?: Maybe<String>;
  twitch_contains?: Maybe<String>;
  twitch_not_contains?: Maybe<String>;
  twitch_starts_with?: Maybe<String>;
  twitch_not_starts_with?: Maybe<String>;
  twitch_ends_with?: Maybe<String>;
  twitch_not_ends_with?: Maybe<String>;
  snapchat?: Maybe<String>;
  snapchat_not?: Maybe<String>;
  snapchat_in?: Maybe<String[] | String>;
  snapchat_not_in?: Maybe<String[] | String>;
  snapchat_lt?: Maybe<String>;
  snapchat_lte?: Maybe<String>;
  snapchat_gt?: Maybe<String>;
  snapchat_gte?: Maybe<String>;
  snapchat_contains?: Maybe<String>;
  snapchat_not_contains?: Maybe<String>;
  snapchat_starts_with?: Maybe<String>;
  snapchat_not_starts_with?: Maybe<String>;
  snapchat_ends_with?: Maybe<String>;
  snapchat_not_ends_with?: Maybe<String>;
  AND?: Maybe<SocialMediaWhereInput[] | SocialMediaWhereInput>;
  OR?: Maybe<SocialMediaWhereInput[] | SocialMediaWhereInput>;
  NOT?: Maybe<SocialMediaWhereInput[] | SocialMediaWhereInput>;
}

export interface BookedPlayerUpdateWithWhereUniqueWithoutBookingInput {
  where: BookedPlayerWhereUniqueInput;
  data: BookedPlayerUpdateWithoutBookingDataInput;
}

export interface SessionReviewCreateOneInput {
  create?: Maybe<SessionReviewCreateInput>;
  connect?: Maybe<SessionReviewWhereUniqueInput>;
}

export interface BookedPlayerUpdateWithoutBookingDataInput {
  player?: Maybe<UserUpdateOneRequiredInput>;
  timeslot?: Maybe<GamingTimeSlotUpdateOneRequiredWithoutPlayersInput>;
}

export interface SessionReviewUpdateManyMutationInput {
  text?: Maybe<String>;
  rating?: Maybe<Int>;
}

export interface GamingTimeSlotUpdateOneRequiredWithoutPlayersInput {
  create?: Maybe<GamingTimeSlotCreateWithoutPlayersInput>;
  update?: Maybe<GamingTimeSlotUpdateWithoutPlayersDataInput>;
  upsert?: Maybe<GamingTimeSlotUpsertWithoutPlayersInput>;
  connect?: Maybe<GamingTimeSlotWhereUniqueInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  displayName?: Maybe<String>;
  displayName_not?: Maybe<String>;
  displayName_in?: Maybe<String[] | String>;
  displayName_not_in?: Maybe<String[] | String>;
  displayName_lt?: Maybe<String>;
  displayName_lte?: Maybe<String>;
  displayName_gt?: Maybe<String>;
  displayName_gte?: Maybe<String>;
  displayName_contains?: Maybe<String>;
  displayName_not_contains?: Maybe<String>;
  displayName_starts_with?: Maybe<String>;
  displayName_not_starts_with?: Maybe<String>;
  displayName_ends_with?: Maybe<String>;
  displayName_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  profilePicture?: Maybe<String>;
  profilePicture_not?: Maybe<String>;
  profilePicture_in?: Maybe<String[] | String>;
  profilePicture_not_in?: Maybe<String[] | String>;
  profilePicture_lt?: Maybe<String>;
  profilePicture_lte?: Maybe<String>;
  profilePicture_gt?: Maybe<String>;
  profilePicture_gte?: Maybe<String>;
  profilePicture_contains?: Maybe<String>;
  profilePicture_not_contains?: Maybe<String>;
  profilePicture_starts_with?: Maybe<String>;
  profilePicture_not_starts_with?: Maybe<String>;
  profilePicture_ends_with?: Maybe<String>;
  profilePicture_not_ends_with?: Maybe<String>;
  banner?: Maybe<String>;
  banner_not?: Maybe<String>;
  banner_in?: Maybe<String[] | String>;
  banner_not_in?: Maybe<String[] | String>;
  banner_lt?: Maybe<String>;
  banner_lte?: Maybe<String>;
  banner_gt?: Maybe<String>;
  banner_gte?: Maybe<String>;
  banner_contains?: Maybe<String>;
  banner_not_contains?: Maybe<String>;
  banner_starts_with?: Maybe<String>;
  banner_not_starts_with?: Maybe<String>;
  banner_ends_with?: Maybe<String>;
  banner_not_ends_with?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  connectedStripeId_not?: Maybe<String>;
  connectedStripeId_in?: Maybe<String[] | String>;
  connectedStripeId_not_in?: Maybe<String[] | String>;
  connectedStripeId_lt?: Maybe<String>;
  connectedStripeId_lte?: Maybe<String>;
  connectedStripeId_gt?: Maybe<String>;
  connectedStripeId_gte?: Maybe<String>;
  connectedStripeId_contains?: Maybe<String>;
  connectedStripeId_not_contains?: Maybe<String>;
  connectedStripeId_starts_with?: Maybe<String>;
  connectedStripeId_not_starts_with?: Maybe<String>;
  connectedStripeId_ends_with?: Maybe<String>;
  connectedStripeId_not_ends_with?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  customerStripeId_not?: Maybe<String>;
  customerStripeId_in?: Maybe<String[] | String>;
  customerStripeId_not_in?: Maybe<String[] | String>;
  customerStripeId_lt?: Maybe<String>;
  customerStripeId_lte?: Maybe<String>;
  customerStripeId_gt?: Maybe<String>;
  customerStripeId_gte?: Maybe<String>;
  customerStripeId_contains?: Maybe<String>;
  customerStripeId_not_contains?: Maybe<String>;
  customerStripeId_starts_with?: Maybe<String>;
  customerStripeId_not_starts_with?: Maybe<String>;
  customerStripeId_ends_with?: Maybe<String>;
  customerStripeId_not_ends_with?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  gamerIsSetup_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  aboutMe?: Maybe<String>;
  aboutMe_not?: Maybe<String>;
  aboutMe_in?: Maybe<String[] | String>;
  aboutMe_not_in?: Maybe<String[] | String>;
  aboutMe_lt?: Maybe<String>;
  aboutMe_lte?: Maybe<String>;
  aboutMe_gt?: Maybe<String>;
  aboutMe_gte?: Maybe<String>;
  aboutMe_contains?: Maybe<String>;
  aboutMe_not_contains?: Maybe<String>;
  aboutMe_starts_with?: Maybe<String>;
  aboutMe_not_starts_with?: Maybe<String>;
  aboutMe_ends_with?: Maybe<String>;
  aboutMe_not_ends_with?: Maybe<String>;
  sessions_every?: Maybe<GamingSessionWhereInput>;
  sessions_some?: Maybe<GamingSessionWhereInput>;
  sessions_none?: Maybe<GamingSessionWhereInput>;
  timeSlots_every?: Maybe<GamingTimeSlotWhereInput>;
  timeSlots_some?: Maybe<GamingTimeSlotWhereInput>;
  timeSlots_none?: Maybe<GamingTimeSlotWhereInput>;
  invites_every?: Maybe<BookingInviteWhereInput>;
  invites_some?: Maybe<BookingInviteWhereInput>;
  invites_none?: Maybe<BookingInviteWhereInput>;
  savedCards_every?: Maybe<SavedCardWhereInput>;
  savedCards_some?: Maybe<SavedCardWhereInput>;
  savedCards_none?: Maybe<SavedCardWhereInput>;
  invitesReceived_every?: Maybe<BookingInviteWhereInput>;
  invitesReceived_some?: Maybe<BookingInviteWhereInput>;
  invitesReceived_none?: Maybe<BookingInviteWhereInput>;
  setup?: Maybe<Int>;
  setup_not?: Maybe<Int>;
  setup_in?: Maybe<Int[] | Int>;
  setup_not_in?: Maybe<Int[] | Int>;
  setup_lt?: Maybe<Int>;
  setup_lte?: Maybe<Int>;
  setup_gt?: Maybe<Int>;
  setup_gte?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordToken_not?: Maybe<String>;
  resetPasswordToken_in?: Maybe<String[] | String>;
  resetPasswordToken_not_in?: Maybe<String[] | String>;
  resetPasswordToken_lt?: Maybe<String>;
  resetPasswordToken_lte?: Maybe<String>;
  resetPasswordToken_gt?: Maybe<String>;
  resetPasswordToken_gte?: Maybe<String>;
  resetPasswordToken_contains?: Maybe<String>;
  resetPasswordToken_not_contains?: Maybe<String>;
  resetPasswordToken_starts_with?: Maybe<String>;
  resetPasswordToken_not_starts_with?: Maybe<String>;
  resetPasswordToken_ends_with?: Maybe<String>;
  resetPasswordToken_not_ends_with?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  resetPasswordExpires_not?: Maybe<DateTimeInput>;
  resetPasswordExpires_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  resetPasswordExpires_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  resetPasswordExpires_lt?: Maybe<DateTimeInput>;
  resetPasswordExpires_lte?: Maybe<DateTimeInput>;
  resetPasswordExpires_gt?: Maybe<DateTimeInput>;
  resetPasswordExpires_gte?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  views_not?: Maybe<Int>;
  views_in?: Maybe<Int[] | Int>;
  views_not_in?: Maybe<Int[] | Int>;
  views_lt?: Maybe<Int>;
  views_lte?: Maybe<Int>;
  views_gt?: Maybe<Int>;
  views_gte?: Maybe<Int>;
  reviews_every?: Maybe<SessionReviewWhereInput>;
  reviews_some?: Maybe<SessionReviewWhereInput>;
  reviews_none?: Maybe<SessionReviewWhereInput>;
  friends_every?: Maybe<UserWhereInput>;
  friends_some?: Maybe<UserWhereInput>;
  friends_none?: Maybe<UserWhereInput>;
  gamertags?: Maybe<GamerTagWhereInput>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  index?: Maybe<UserIndexWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface GamingTimeSlotUpdateWithoutPlayersDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  gamingSession?: Maybe<GamingSessionUpdateOneRequiredWithoutTimeslotsInput>;
  gamers?: Maybe<UserUpdateManyWithoutTimeSlotsInput>;
  bookings?: Maybe<BookingUpdateManyWithoutTimeslotInput>;
  length?: Maybe<Int>;
  slots?: Maybe<Int>;
}

export interface SessionReviewCreateInput {
  user: UserCreateOneWithoutReviewsInput;
  session: GamingSessionCreateOneWithoutReviewsInput;
  text: String;
  rating: Int;
}

export interface UserUpdateManyWithoutTimeSlotsInput {
  create?: Maybe<
    UserCreateWithoutTimeSlotsInput[] | UserCreateWithoutTimeSlotsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutTimeSlotsInput[]
    | UserUpdateWithWhereUniqueWithoutTimeSlotsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutTimeSlotsInput[]
    | UserUpsertWithWhereUniqueWithoutTimeSlotsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export type GamingSessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateWithWhereUniqueWithoutTimeSlotsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTimeSlotsDataInput;
}

export interface UserUpdateWithoutSavedCardsDataInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionUpdateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotUpdateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutFromInput>;
  invitesReceived?: Maybe<BookingInviteUpdateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutUserInput>;
  friends?: Maybe<UserUpdateManyInput>;
  gamertags?: Maybe<GamerTagUpdateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index?: Maybe<UserIndexUpdateOneRequiredWithoutUserInput>;
}

export interface UserUpdateWithoutTimeSlotsDataInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionUpdateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardUpdateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteUpdateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutUserInput>;
  friends?: Maybe<UserUpdateManyInput>;
  gamertags?: Maybe<GamerTagUpdateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index?: Maybe<UserIndexUpdateOneRequiredWithoutUserInput>;
}

export type GamingSessionIndexWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SavedCardUpdateManyWithoutUserInput {
  create?: Maybe<
    SavedCardCreateWithoutUserInput[] | SavedCardCreateWithoutUserInput
  >;
  delete?: Maybe<SavedCardWhereUniqueInput[] | SavedCardWhereUniqueInput>;
  connect?: Maybe<SavedCardWhereUniqueInput[] | SavedCardWhereUniqueInput>;
  set?: Maybe<SavedCardWhereUniqueInput[] | SavedCardWhereUniqueInput>;
  disconnect?: Maybe<SavedCardWhereUniqueInput[] | SavedCardWhereUniqueInput>;
  update?: Maybe<
    | SavedCardUpdateWithWhereUniqueWithoutUserInput[]
    | SavedCardUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | SavedCardUpsertWithWhereUniqueWithoutUserInput[]
    | SavedCardUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<SavedCardScalarWhereInput[] | SavedCardScalarWhereInput>;
  updateMany?: Maybe<
    | SavedCardUpdateManyWithWhereNestedInput[]
    | SavedCardUpdateManyWithWhereNestedInput
  >;
}

export interface GamingSessionIndexWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  gamer?: Maybe<String>;
  gamer_not?: Maybe<String>;
  gamer_in?: Maybe<String[] | String>;
  gamer_not_in?: Maybe<String[] | String>;
  gamer_lt?: Maybe<String>;
  gamer_lte?: Maybe<String>;
  gamer_gt?: Maybe<String>;
  gamer_gte?: Maybe<String>;
  gamer_contains?: Maybe<String>;
  gamer_not_contains?: Maybe<String>;
  gamer_starts_with?: Maybe<String>;
  gamer_not_starts_with?: Maybe<String>;
  gamer_ends_with?: Maybe<String>;
  gamer_not_ends_with?: Maybe<String>;
  game?: Maybe<String>;
  game_not?: Maybe<String>;
  game_in?: Maybe<String[] | String>;
  game_not_in?: Maybe<String[] | String>;
  game_lt?: Maybe<String>;
  game_lte?: Maybe<String>;
  game_gt?: Maybe<String>;
  game_gte?: Maybe<String>;
  game_contains?: Maybe<String>;
  game_not_contains?: Maybe<String>;
  game_starts_with?: Maybe<String>;
  game_not_starts_with?: Maybe<String>;
  game_ends_with?: Maybe<String>;
  game_not_ends_with?: Maybe<String>;
  launcher?: Maybe<Launcher>;
  launcher_not?: Maybe<Launcher>;
  launcher_in?: Maybe<Launcher[] | Launcher>;
  launcher_not_in?: Maybe<Launcher[] | Launcher>;
  gamingSession?: Maybe<GamingSessionWhereInput>;
  AND?: Maybe<GamingSessionIndexWhereInput[] | GamingSessionIndexWhereInput>;
  OR?: Maybe<GamingSessionIndexWhereInput[] | GamingSessionIndexWhereInput>;
  NOT?: Maybe<GamingSessionIndexWhereInput[] | GamingSessionIndexWhereInput>;
}

export interface SavedCardUpdateWithWhereUniqueWithoutUserInput {
  where: SavedCardWhereUniqueInput;
  data: SavedCardUpdateWithoutUserDataInput;
}

export interface UserCreateWithoutSavedCardsInput {
  gender?: Maybe<Gender>;
  email: String;
  username: String;
  displayName: String;
  password: String;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserCreateoccupationsInput>;
  name: String;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionCreateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotCreateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteCreateManyWithoutFromInput>;
  invitesReceived?: Maybe<BookingInviteCreateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewCreateManyWithoutUserInput>;
  friends?: Maybe<UserCreateManyInput>;
  gamertags?: Maybe<GamerTagCreateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index: UserIndexCreateOneWithoutUserInput;
}

export interface SavedCardUpdateWithoutUserDataInput {
  cardId?: Maybe<String>;
  default?: Maybe<Boolean>;
  lastFour?: Maybe<String>;
  brand?: Maybe<String>;
}

export interface SavedCardCreateInput {
  user: UserCreateOneWithoutSavedCardsInput;
  cardId: String;
  default: Boolean;
  lastFour: String;
  brand: String;
}

export interface SavedCardUpsertWithWhereUniqueWithoutUserInput {
  where: SavedCardWhereUniqueInput;
  update: SavedCardUpdateWithoutUserDataInput;
  create: SavedCardCreateWithoutUserInput;
}

export interface RequirementUpdateManyMutationInput {
  msg?: Maybe<String>;
}

export interface SavedCardScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  cardId?: Maybe<String>;
  cardId_not?: Maybe<String>;
  cardId_in?: Maybe<String[] | String>;
  cardId_not_in?: Maybe<String[] | String>;
  cardId_lt?: Maybe<String>;
  cardId_lte?: Maybe<String>;
  cardId_gt?: Maybe<String>;
  cardId_gte?: Maybe<String>;
  cardId_contains?: Maybe<String>;
  cardId_not_contains?: Maybe<String>;
  cardId_starts_with?: Maybe<String>;
  cardId_not_starts_with?: Maybe<String>;
  cardId_ends_with?: Maybe<String>;
  cardId_not_ends_with?: Maybe<String>;
  default?: Maybe<Boolean>;
  default_not?: Maybe<Boolean>;
  lastFour?: Maybe<String>;
  lastFour_not?: Maybe<String>;
  lastFour_in?: Maybe<String[] | String>;
  lastFour_not_in?: Maybe<String[] | String>;
  lastFour_lt?: Maybe<String>;
  lastFour_lte?: Maybe<String>;
  lastFour_gt?: Maybe<String>;
  lastFour_gte?: Maybe<String>;
  lastFour_contains?: Maybe<String>;
  lastFour_not_contains?: Maybe<String>;
  lastFour_starts_with?: Maybe<String>;
  lastFour_not_starts_with?: Maybe<String>;
  lastFour_ends_with?: Maybe<String>;
  lastFour_not_ends_with?: Maybe<String>;
  brand?: Maybe<String>;
  brand_not?: Maybe<String>;
  brand_in?: Maybe<String[] | String>;
  brand_not_in?: Maybe<String[] | String>;
  brand_lt?: Maybe<String>;
  brand_lte?: Maybe<String>;
  brand_gt?: Maybe<String>;
  brand_gte?: Maybe<String>;
  brand_contains?: Maybe<String>;
  brand_not_contains?: Maybe<String>;
  brand_starts_with?: Maybe<String>;
  brand_not_starts_with?: Maybe<String>;
  brand_ends_with?: Maybe<String>;
  brand_not_ends_with?: Maybe<String>;
  AND?: Maybe<SavedCardScalarWhereInput[] | SavedCardScalarWhereInput>;
  OR?: Maybe<SavedCardScalarWhereInput[] | SavedCardScalarWhereInput>;
  NOT?: Maybe<SavedCardScalarWhereInput[] | SavedCardScalarWhereInput>;
}

export interface PCLauncherUpdateManyMutationInput {
  epic?: Maybe<String>;
  steam?: Maybe<String>;
  origin?: Maybe<String>;
  gog?: Maybe<String>;
  battlenet?: Maybe<String>;
  uplay?: Maybe<String>;
  bethesda?: Maybe<String>;
  itch?: Maybe<String>;
  windows?: Maybe<String>;
  riot?: Maybe<String>;
}

export interface SavedCardUpdateManyWithWhereNestedInput {
  where: SavedCardScalarWhereInput;
  data: SavedCardUpdateManyDataInput;
}

export interface GamerTagUpsertWithoutPcInput {
  update: GamerTagUpdateWithoutPcDataInput;
  create: GamerTagCreateWithoutPcInput;
}

export interface SavedCardUpdateManyDataInput {
  cardId?: Maybe<String>;
  default?: Maybe<Boolean>;
  lastFour?: Maybe<String>;
  brand?: Maybe<String>;
}

export interface GamerTagUpdateOneRequiredWithoutPcInput {
  create?: Maybe<GamerTagCreateWithoutPcInput>;
  update?: Maybe<GamerTagUpdateWithoutPcDataInput>;
  upsert?: Maybe<GamerTagUpsertWithoutPcInput>;
  connect?: Maybe<GamerTagWhereUniqueInput>;
}

export interface BookingInviteUpdateManyWithoutToInput {
  create?: Maybe<
    BookingInviteCreateWithoutToInput[] | BookingInviteCreateWithoutToInput
  >;
  delete?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
  connect?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
  set?: Maybe<BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput>;
  disconnect?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
  update?: Maybe<
    | BookingInviteUpdateWithWhereUniqueWithoutToInput[]
    | BookingInviteUpdateWithWhereUniqueWithoutToInput
  >;
  upsert?: Maybe<
    | BookingInviteUpsertWithWhereUniqueWithoutToInput[]
    | BookingInviteUpsertWithWhereUniqueWithoutToInput
  >;
  deleteMany?: Maybe<
    BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput
  >;
  updateMany?: Maybe<
    | BookingInviteUpdateManyWithWhereNestedInput[]
    | BookingInviteUpdateManyWithWhereNestedInput
  >;
}

export interface PCLauncherUpdateInput {
  gamerTag?: Maybe<GamerTagUpdateOneRequiredWithoutPcInput>;
  epic?: Maybe<String>;
  steam?: Maybe<String>;
  origin?: Maybe<String>;
  gog?: Maybe<String>;
  battlenet?: Maybe<String>;
  uplay?: Maybe<String>;
  bethesda?: Maybe<String>;
  itch?: Maybe<String>;
  windows?: Maybe<String>;
  riot?: Maybe<String>;
}

export interface BookingInviteUpdateWithWhereUniqueWithoutToInput {
  where: BookingInviteWhereUniqueInput;
  data: BookingInviteUpdateWithoutToDataInput;
}

export interface GamerTagCreateOneWithoutPcInput {
  create?: Maybe<GamerTagCreateWithoutPcInput>;
  connect?: Maybe<GamerTagWhereUniqueInput>;
}

export interface BookingInviteUpdateWithoutToDataInput {
  startTime?: Maybe<DateTimeInput>;
  booking?: Maybe<BookingUpdateOneRequiredWithoutInvitesInput>;
  from?: Maybe<UserUpdateOneRequiredWithoutInvitesInput>;
  sent?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
  notification?: Maybe<NotificationUpdateOneWithoutBookingInviteInput>;
}

export type RequirementWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SocialMediaUpsertNestedInput {
  update: SocialMediaUpdateDataInput;
  create: SocialMediaCreateInput;
}

export interface NotificationUpdateInput {
  type?: Maybe<NotificationType>;
  text?: Maybe<String>;
  for?: Maybe<UserUpdateOneRequiredInput>;
  friendRequest?: Maybe<FriendRequestUpdateOneWithoutNotificationInput>;
  bookingInvite?: Maybe<BookingInviteUpdateOneWithoutNotificationInput>;
  booking?: Maybe<BookingUpdateOneWithoutNotificationsInput>;
  friend?: Maybe<UserUpdateOneInput>;
  viewed?: Maybe<Boolean>;
}

export interface UserUpdateWithoutInvitesDataInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionUpdateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotUpdateManyWithoutGamersInput>;
  savedCards?: Maybe<SavedCardUpdateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteUpdateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutUserInput>;
  friends?: Maybe<UserUpdateManyInput>;
  gamertags?: Maybe<GamerTagUpdateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index?: Maybe<UserIndexUpdateOneRequiredWithoutUserInput>;
}

export type SavedCardWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SessionReviewUpdateManyWithoutUserInput {
  create?: Maybe<
    SessionReviewCreateWithoutUserInput[] | SessionReviewCreateWithoutUserInput
  >;
  delete?: Maybe<
    SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput
  >;
  connect?: Maybe<
    SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput
  >;
  set?: Maybe<SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput>;
  disconnect?: Maybe<
    SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput
  >;
  update?: Maybe<
    | SessionReviewUpdateWithWhereUniqueWithoutUserInput[]
    | SessionReviewUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | SessionReviewUpsertWithWhereUniqueWithoutUserInput[]
    | SessionReviewUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput
  >;
  updateMany?: Maybe<
    | SessionReviewUpdateManyWithWhereNestedInput[]
    | SessionReviewUpdateManyWithWhereNestedInput
  >;
}

export interface GamingTimeSlotUpdateInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  gamingSession?: Maybe<GamingSessionUpdateOneRequiredWithoutTimeslotsInput>;
  gamers?: Maybe<UserUpdateManyWithoutTimeSlotsInput>;
  bookings?: Maybe<BookingUpdateManyWithoutTimeslotInput>;
  players?: Maybe<BookedPlayerUpdateManyWithoutTimeslotInput>;
  length?: Maybe<Int>;
  slots?: Maybe<Int>;
}

export interface SessionReviewUpdateWithWhereUniqueWithoutUserInput {
  where: SessionReviewWhereUniqueInput;
  data: SessionReviewUpdateWithoutUserDataInput;
}

export type SessionReviewWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SessionReviewUpdateWithoutUserDataInput {
  session?: Maybe<GamingSessionUpdateOneRequiredWithoutReviewsInput>;
  text?: Maybe<String>;
  rating?: Maybe<Int>;
}

export interface GamingSessionUpsertNestedInput {
  update: GamingSessionUpdateDataInput;
  create: GamingSessionCreateInput;
}

export interface GamingSessionUpdateOneRequiredWithoutReviewsInput {
  create?: Maybe<GamingSessionCreateWithoutReviewsInput>;
  update?: Maybe<GamingSessionUpdateWithoutReviewsDataInput>;
  upsert?: Maybe<GamingSessionUpsertWithoutReviewsInput>;
  connect?: Maybe<GamingSessionWhereUniqueInput>;
}

export type SessionReviewIndexWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GamingSessionUpdateWithoutReviewsDataInput {
  gamers?: Maybe<UserUpdateManyWithoutSessionsInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  game?: Maybe<GameUpdateOneRequiredWithoutSessionsInput>;
  title?: Maybe<String>;
  length?: Maybe<Int>;
  price?: Maybe<Float>;
  launcher?: Maybe<Launcher>;
  system?: Maybe<System>;
  type?: Maybe<TypeOfGame>;
  slots?: Maybe<Int>;
  requirements?: Maybe<RequirementUpdateManyInput>;
  discounts?: Maybe<DiscountUpdateManyInput>;
  timeslots?: Maybe<GamingTimeSlotUpdateManyWithoutGamingSessionInput>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface SessionReviewIndexWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  sessionReview?: Maybe<SessionReviewWhereInput>;
  AND?: Maybe<SessionReviewIndexWhereInput[] | SessionReviewIndexWhereInput>;
  OR?: Maybe<SessionReviewIndexWhereInput[] | SessionReviewIndexWhereInput>;
  NOT?: Maybe<SessionReviewIndexWhereInput[] | SessionReviewIndexWhereInput>;
}

export interface RequirementUpdateManyInput {
  create?: Maybe<RequirementCreateInput[] | RequirementCreateInput>;
  update?: Maybe<
    | RequirementUpdateWithWhereUniqueNestedInput[]
    | RequirementUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | RequirementUpsertWithWhereUniqueNestedInput[]
    | RequirementUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<RequirementWhereUniqueInput[] | RequirementWhereUniqueInput>;
  connect?: Maybe<RequirementWhereUniqueInput[] | RequirementWhereUniqueInput>;
  set?: Maybe<RequirementWhereUniqueInput[] | RequirementWhereUniqueInput>;
  disconnect?: Maybe<
    RequirementWhereUniqueInput[] | RequirementWhereUniqueInput
  >;
  deleteMany?: Maybe<
    RequirementScalarWhereInput[] | RequirementScalarWhereInput
  >;
  updateMany?: Maybe<
    | RequirementUpdateManyWithWhereNestedInput[]
    | RequirementUpdateManyWithWhereNestedInput
  >;
}

export interface GamingSessionCreateOneInput {
  create?: Maybe<GamingSessionCreateInput>;
  connect?: Maybe<GamingSessionWhereUniqueInput>;
}

export interface RequirementUpdateWithWhereUniqueNestedInput {
  where: RequirementWhereUniqueInput;
  data: RequirementUpdateDataInput;
}

export interface GamingSessionUpdateManyMutationInput {
  title?: Maybe<String>;
  length?: Maybe<Int>;
  price?: Maybe<Float>;
  launcher?: Maybe<Launcher>;
  system?: Maybe<System>;
  type?: Maybe<TypeOfGame>;
  slots?: Maybe<Int>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface RequirementUpdateDataInput {
  msg?: Maybe<String>;
}

export interface GamingSessionUpdateInput {
  gamers?: Maybe<UserUpdateManyWithoutSessionsInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  game?: Maybe<GameUpdateOneRequiredWithoutSessionsInput>;
  title?: Maybe<String>;
  length?: Maybe<Int>;
  price?: Maybe<Float>;
  launcher?: Maybe<Launcher>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutSessionInput>;
  system?: Maybe<System>;
  type?: Maybe<TypeOfGame>;
  slots?: Maybe<Int>;
  requirements?: Maybe<RequirementUpdateManyInput>;
  discounts?: Maybe<DiscountUpdateManyInput>;
  timeslots?: Maybe<GamingTimeSlotUpdateManyWithoutGamingSessionInput>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface RequirementUpsertWithWhereUniqueNestedInput {
  where: RequirementWhereUniqueInput;
  update: RequirementUpdateDataInput;
  create: RequirementCreateInput;
}

export interface GamerTagUpdateManyMutationInput {
  psn?: Maybe<String>;
  xbl?: Maybe<String>;
  nso?: Maybe<String>;
}

export interface RequirementScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  msg?: Maybe<String>;
  msg_not?: Maybe<String>;
  msg_in?: Maybe<String[] | String>;
  msg_not_in?: Maybe<String[] | String>;
  msg_lt?: Maybe<String>;
  msg_lte?: Maybe<String>;
  msg_gt?: Maybe<String>;
  msg_gte?: Maybe<String>;
  msg_contains?: Maybe<String>;
  msg_not_contains?: Maybe<String>;
  msg_starts_with?: Maybe<String>;
  msg_not_starts_with?: Maybe<String>;
  msg_ends_with?: Maybe<String>;
  msg_not_ends_with?: Maybe<String>;
  AND?: Maybe<RequirementScalarWhereInput[] | RequirementScalarWhereInput>;
  OR?: Maybe<RequirementScalarWhereInput[] | RequirementScalarWhereInput>;
  NOT?: Maybe<RequirementScalarWhereInput[] | RequirementScalarWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  username?: Maybe<String>;
}>;

export interface RequirementUpdateManyWithWhereNestedInput {
  where: RequirementScalarWhereInput;
  data: RequirementUpdateManyDataInput;
}

export interface UserUpdateOneRequiredWithoutGamertagsInput {
  create?: Maybe<UserCreateWithoutGamertagsInput>;
  update?: Maybe<UserUpdateWithoutGamertagsDataInput>;
  upsert?: Maybe<UserUpsertWithoutGamertagsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface RequirementUpdateManyDataInput {
  msg?: Maybe<String>;
}

export type UserIndexWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  username?: Maybe<String>;
}>;

export interface DiscountUpdateManyInput {
  create?: Maybe<DiscountCreateInput[] | DiscountCreateInput>;
  update?: Maybe<
    | DiscountUpdateWithWhereUniqueNestedInput[]
    | DiscountUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | DiscountUpsertWithWhereUniqueNestedInput[]
    | DiscountUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<DiscountWhereUniqueInput[] | DiscountWhereUniqueInput>;
  connect?: Maybe<DiscountWhereUniqueInput[] | DiscountWhereUniqueInput>;
  set?: Maybe<DiscountWhereUniqueInput[] | DiscountWhereUniqueInput>;
  disconnect?: Maybe<DiscountWhereUniqueInput[] | DiscountWhereUniqueInput>;
  deleteMany?: Maybe<DiscountScalarWhereInput[] | DiscountScalarWhereInput>;
  updateMany?: Maybe<
    | DiscountUpdateManyWithWhereNestedInput[]
    | DiscountUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateOneWithoutGamertagsInput {
  create?: Maybe<UserCreateWithoutGamertagsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface DiscountUpdateWithWhereUniqueNestedInput {
  where: DiscountWhereUniqueInput;
  data: DiscountUpdateDataInput;
}

export interface GamerRequestUpdateManyMutationInput {
  occupations?: Maybe<GamerRequestUpdateoccupationsInput>;
  addToOccupations?: Maybe<String>;
}

export interface DiscountUpdateDataInput {
  percentage?: Maybe<Int>;
  threshold?: Maybe<Int>;
  playerOrSession?: Maybe<PlayerOrSession>;
}

export interface BookedPlayerCreateInput {
  player: UserCreateOneInput;
  booking: BookingCreateOneWithoutPlayersInput;
  timeslot: GamingTimeSlotCreateOneWithoutPlayersInput;
}

export interface SocialMediaUpdateDataInput {
  twitter?: Maybe<String>;
  facebook?: Maybe<String>;
  youtube?: Maybe<String>;
  instagram?: Maybe<String>;
  twitch?: Maybe<String>;
  snapchat?: Maybe<String>;
}

export interface UserCreateInput {
  gender?: Maybe<Gender>;
  email: String;
  username: String;
  displayName: String;
  password: String;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserCreateoccupationsInput>;
  name: String;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionCreateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotCreateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteCreateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardCreateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteCreateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewCreateManyWithoutUserInput>;
  friends?: Maybe<UserCreateManyInput>;
  gamertags?: Maybe<GamerTagCreateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index: UserIndexCreateOneWithoutUserInput;
}

export interface SocialMediaUpdateOneRequiredInput {
  create?: Maybe<SocialMediaCreateInput>;
  update?: Maybe<SocialMediaUpdateDataInput>;
  upsert?: Maybe<SocialMediaUpsertNestedInput>;
  connect?: Maybe<SocialMediaWhereUniqueInput>;
}

export interface GamingSessionCreateManyWithoutGamersInput {
  create?: Maybe<
    | GamingSessionCreateWithoutGamersInput[]
    | GamingSessionCreateWithoutGamersInput
  >;
  connect?: Maybe<
    GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput
  >;
}

export interface UserIndexWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  displayName?: Maybe<String>;
  displayName_not?: Maybe<String>;
  displayName_in?: Maybe<String[] | String>;
  displayName_not_in?: Maybe<String[] | String>;
  displayName_lt?: Maybe<String>;
  displayName_lte?: Maybe<String>;
  displayName_gt?: Maybe<String>;
  displayName_gte?: Maybe<String>;
  displayName_contains?: Maybe<String>;
  displayName_not_contains?: Maybe<String>;
  displayName_starts_with?: Maybe<String>;
  displayName_not_starts_with?: Maybe<String>;
  displayName_ends_with?: Maybe<String>;
  displayName_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<UserIndexWhereInput[] | UserIndexWhereInput>;
  OR?: Maybe<UserIndexWhereInput[] | UserIndexWhereInput>;
  NOT?: Maybe<UserIndexWhereInput[] | UserIndexWhereInput>;
}

export interface GameCreateOneWithoutSessionsInput {
  create?: Maybe<GameCreateWithoutSessionsInput>;
  connect?: Maybe<GameWhereUniqueInput>;
}

export interface PCLauncherWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  gamerTag?: Maybe<GamerTagWhereInput>;
  epic?: Maybe<String>;
  epic_not?: Maybe<String>;
  epic_in?: Maybe<String[] | String>;
  epic_not_in?: Maybe<String[] | String>;
  epic_lt?: Maybe<String>;
  epic_lte?: Maybe<String>;
  epic_gt?: Maybe<String>;
  epic_gte?: Maybe<String>;
  epic_contains?: Maybe<String>;
  epic_not_contains?: Maybe<String>;
  epic_starts_with?: Maybe<String>;
  epic_not_starts_with?: Maybe<String>;
  epic_ends_with?: Maybe<String>;
  epic_not_ends_with?: Maybe<String>;
  steam?: Maybe<String>;
  steam_not?: Maybe<String>;
  steam_in?: Maybe<String[] | String>;
  steam_not_in?: Maybe<String[] | String>;
  steam_lt?: Maybe<String>;
  steam_lte?: Maybe<String>;
  steam_gt?: Maybe<String>;
  steam_gte?: Maybe<String>;
  steam_contains?: Maybe<String>;
  steam_not_contains?: Maybe<String>;
  steam_starts_with?: Maybe<String>;
  steam_not_starts_with?: Maybe<String>;
  steam_ends_with?: Maybe<String>;
  steam_not_ends_with?: Maybe<String>;
  origin?: Maybe<String>;
  origin_not?: Maybe<String>;
  origin_in?: Maybe<String[] | String>;
  origin_not_in?: Maybe<String[] | String>;
  origin_lt?: Maybe<String>;
  origin_lte?: Maybe<String>;
  origin_gt?: Maybe<String>;
  origin_gte?: Maybe<String>;
  origin_contains?: Maybe<String>;
  origin_not_contains?: Maybe<String>;
  origin_starts_with?: Maybe<String>;
  origin_not_starts_with?: Maybe<String>;
  origin_ends_with?: Maybe<String>;
  origin_not_ends_with?: Maybe<String>;
  gog?: Maybe<String>;
  gog_not?: Maybe<String>;
  gog_in?: Maybe<String[] | String>;
  gog_not_in?: Maybe<String[] | String>;
  gog_lt?: Maybe<String>;
  gog_lte?: Maybe<String>;
  gog_gt?: Maybe<String>;
  gog_gte?: Maybe<String>;
  gog_contains?: Maybe<String>;
  gog_not_contains?: Maybe<String>;
  gog_starts_with?: Maybe<String>;
  gog_not_starts_with?: Maybe<String>;
  gog_ends_with?: Maybe<String>;
  gog_not_ends_with?: Maybe<String>;
  battlenet?: Maybe<String>;
  battlenet_not?: Maybe<String>;
  battlenet_in?: Maybe<String[] | String>;
  battlenet_not_in?: Maybe<String[] | String>;
  battlenet_lt?: Maybe<String>;
  battlenet_lte?: Maybe<String>;
  battlenet_gt?: Maybe<String>;
  battlenet_gte?: Maybe<String>;
  battlenet_contains?: Maybe<String>;
  battlenet_not_contains?: Maybe<String>;
  battlenet_starts_with?: Maybe<String>;
  battlenet_not_starts_with?: Maybe<String>;
  battlenet_ends_with?: Maybe<String>;
  battlenet_not_ends_with?: Maybe<String>;
  uplay?: Maybe<String>;
  uplay_not?: Maybe<String>;
  uplay_in?: Maybe<String[] | String>;
  uplay_not_in?: Maybe<String[] | String>;
  uplay_lt?: Maybe<String>;
  uplay_lte?: Maybe<String>;
  uplay_gt?: Maybe<String>;
  uplay_gte?: Maybe<String>;
  uplay_contains?: Maybe<String>;
  uplay_not_contains?: Maybe<String>;
  uplay_starts_with?: Maybe<String>;
  uplay_not_starts_with?: Maybe<String>;
  uplay_ends_with?: Maybe<String>;
  uplay_not_ends_with?: Maybe<String>;
  bethesda?: Maybe<String>;
  bethesda_not?: Maybe<String>;
  bethesda_in?: Maybe<String[] | String>;
  bethesda_not_in?: Maybe<String[] | String>;
  bethesda_lt?: Maybe<String>;
  bethesda_lte?: Maybe<String>;
  bethesda_gt?: Maybe<String>;
  bethesda_gte?: Maybe<String>;
  bethesda_contains?: Maybe<String>;
  bethesda_not_contains?: Maybe<String>;
  bethesda_starts_with?: Maybe<String>;
  bethesda_not_starts_with?: Maybe<String>;
  bethesda_ends_with?: Maybe<String>;
  bethesda_not_ends_with?: Maybe<String>;
  itch?: Maybe<String>;
  itch_not?: Maybe<String>;
  itch_in?: Maybe<String[] | String>;
  itch_not_in?: Maybe<String[] | String>;
  itch_lt?: Maybe<String>;
  itch_lte?: Maybe<String>;
  itch_gt?: Maybe<String>;
  itch_gte?: Maybe<String>;
  itch_contains?: Maybe<String>;
  itch_not_contains?: Maybe<String>;
  itch_starts_with?: Maybe<String>;
  itch_not_starts_with?: Maybe<String>;
  itch_ends_with?: Maybe<String>;
  itch_not_ends_with?: Maybe<String>;
  windows?: Maybe<String>;
  windows_not?: Maybe<String>;
  windows_in?: Maybe<String[] | String>;
  windows_not_in?: Maybe<String[] | String>;
  windows_lt?: Maybe<String>;
  windows_lte?: Maybe<String>;
  windows_gt?: Maybe<String>;
  windows_gte?: Maybe<String>;
  windows_contains?: Maybe<String>;
  windows_not_contains?: Maybe<String>;
  windows_starts_with?: Maybe<String>;
  windows_not_starts_with?: Maybe<String>;
  windows_ends_with?: Maybe<String>;
  windows_not_ends_with?: Maybe<String>;
  riot?: Maybe<String>;
  riot_not?: Maybe<String>;
  riot_in?: Maybe<String[] | String>;
  riot_not_in?: Maybe<String[] | String>;
  riot_lt?: Maybe<String>;
  riot_lte?: Maybe<String>;
  riot_gt?: Maybe<String>;
  riot_gte?: Maybe<String>;
  riot_contains?: Maybe<String>;
  riot_not_contains?: Maybe<String>;
  riot_starts_with?: Maybe<String>;
  riot_not_starts_with?: Maybe<String>;
  riot_ends_with?: Maybe<String>;
  riot_not_ends_with?: Maybe<String>;
  AND?: Maybe<PCLauncherWhereInput[] | PCLauncherWhereInput>;
  OR?: Maybe<PCLauncherWhereInput[] | PCLauncherWhereInput>;
  NOT?: Maybe<PCLauncherWhereInput[] | PCLauncherWhereInput>;
}

export interface GameCreatetagsInput {
  set?: Maybe<Tags[] | Tags>;
}

export interface GamingTimeSlotUpdateManyWithoutGamingSessionInput {
  create?: Maybe<
    | GamingTimeSlotCreateWithoutGamingSessionInput[]
    | GamingTimeSlotCreateWithoutGamingSessionInput
  >;
  delete?: Maybe<
    GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput
  >;
  connect?: Maybe<
    GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput
  >;
  set?: Maybe<
    GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput
  >;
  disconnect?: Maybe<
    GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput
  >;
  update?: Maybe<
    | GamingTimeSlotUpdateWithWhereUniqueWithoutGamingSessionInput[]
    | GamingTimeSlotUpdateWithWhereUniqueWithoutGamingSessionInput
  >;
  upsert?: Maybe<
    | GamingTimeSlotUpsertWithWhereUniqueWithoutGamingSessionInput[]
    | GamingTimeSlotUpsertWithWhereUniqueWithoutGamingSessionInput
  >;
  deleteMany?: Maybe<
    GamingTimeSlotScalarWhereInput[] | GamingTimeSlotScalarWhereInput
  >;
  updateMany?: Maybe<
    | GamingTimeSlotUpdateManyWithWhereNestedInput[]
    | GamingTimeSlotUpdateManyWithWhereNestedInput
  >;
}

export interface SessionReviewCreateWithoutSessionInput {
  user: UserCreateOneWithoutReviewsInput;
  text: String;
  rating: Int;
}

export interface GamingTimeSlotUpdateWithWhereUniqueWithoutGamingSessionInput {
  where: GamingTimeSlotWhereUniqueInput;
  data: GamingTimeSlotUpdateWithoutGamingSessionDataInput;
}

export interface UserCreateWithoutReviewsInput {
  gender?: Maybe<Gender>;
  email: String;
  username: String;
  displayName: String;
  password: String;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserCreateoccupationsInput>;
  name: String;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionCreateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotCreateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteCreateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardCreateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteCreateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  friends?: Maybe<UserCreateManyInput>;
  gamertags?: Maybe<GamerTagCreateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index: UserIndexCreateOneWithoutUserInput;
}

export interface GamingTimeSlotUpdateWithoutGamingSessionDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  gamers?: Maybe<UserUpdateManyWithoutTimeSlotsInput>;
  bookings?: Maybe<BookingUpdateManyWithoutTimeslotInput>;
  players?: Maybe<BookedPlayerUpdateManyWithoutTimeslotInput>;
  length?: Maybe<Int>;
  slots?: Maybe<Int>;
}

export interface GamingTimeSlotCreateWithoutGamersInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamingSession: GamingSessionCreateOneWithoutTimeslotsInput;
  bookings?: Maybe<BookingCreateManyWithoutTimeslotInput>;
  players?: Maybe<BookedPlayerCreateManyWithoutTimeslotInput>;
  length: Int;
  slots: Int;
}

export interface BookingUpdateManyWithoutTimeslotInput {
  create?: Maybe<
    BookingCreateWithoutTimeslotInput[] | BookingCreateWithoutTimeslotInput
  >;
  delete?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  connect?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  set?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  disconnect?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  update?: Maybe<
    | BookingUpdateWithWhereUniqueWithoutTimeslotInput[]
    | BookingUpdateWithWhereUniqueWithoutTimeslotInput
  >;
  upsert?: Maybe<
    | BookingUpsertWithWhereUniqueWithoutTimeslotInput[]
    | BookingUpsertWithWhereUniqueWithoutTimeslotInput
  >;
  deleteMany?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
  updateMany?: Maybe<
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput
  >;
}

export interface GamingSessionCreateWithoutTimeslotsInput {
  gamers?: Maybe<UserCreateManyWithoutSessionsInput>;
  creator: UserCreateOneInput;
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  launcher?: Maybe<Launcher>;
  reviews?: Maybe<SessionReviewCreateManyWithoutSessionInput>;
  system: System;
  type: TypeOfGame;
  slots: Int;
  requirements?: Maybe<RequirementCreateManyInput>;
  discounts?: Maybe<DiscountCreateManyInput>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface BookingUpdateWithWhereUniqueWithoutTimeslotInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutTimeslotDataInput;
}

export interface UserCreateWithoutSessionsInput {
  gender?: Maybe<Gender>;
  email: String;
  username: String;
  displayName: String;
  password: String;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserCreateoccupationsInput>;
  name: String;
  aboutMe?: Maybe<String>;
  timeSlots?: Maybe<GamingTimeSlotCreateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteCreateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardCreateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteCreateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewCreateManyWithoutUserInput>;
  friends?: Maybe<UserCreateManyInput>;
  gamertags?: Maybe<GamerTagCreateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index: UserIndexCreateOneWithoutUserInput;
}

export interface BookingUpdateWithoutTimeslotDataInput {
  charge?: Maybe<String>;
  numSlots?: Maybe<Int>;
  numPlayers?: Maybe<Int>;
  players?: Maybe<BookedPlayerUpdateManyWithoutBookingInput>;
  total?: Maybe<Float>;
  bookee?: Maybe<UserUpdateOneRequiredInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutBookingInput>;
  cancelled?: Maybe<Boolean>;
  notifications?: Maybe<NotificationUpdateManyWithoutBookingInput>;
}

export interface BookingInviteCreateWithoutFromInput {
  startTime: DateTimeInput;
  booking: BookingCreateOneWithoutInvitesInput;
  to?: Maybe<UserCreateOneWithoutInvitesReceivedInput>;
  sent: Boolean;
  accepted?: Maybe<Boolean>;
  notification?: Maybe<NotificationCreateOneWithoutBookingInviteInput>;
}

export interface BookingInviteUpdateManyWithoutBookingInput {
  create?: Maybe<
    | BookingInviteCreateWithoutBookingInput[]
    | BookingInviteCreateWithoutBookingInput
  >;
  delete?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
  connect?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
  set?: Maybe<BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput>;
  disconnect?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
  update?: Maybe<
    | BookingInviteUpdateWithWhereUniqueWithoutBookingInput[]
    | BookingInviteUpdateWithWhereUniqueWithoutBookingInput
  >;
  upsert?: Maybe<
    | BookingInviteUpsertWithWhereUniqueWithoutBookingInput[]
    | BookingInviteUpsertWithWhereUniqueWithoutBookingInput
  >;
  deleteMany?: Maybe<
    BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput
  >;
  updateMany?: Maybe<
    | BookingInviteUpdateManyWithWhereNestedInput[]
    | BookingInviteUpdateManyWithWhereNestedInput
  >;
}

export interface BookingCreateWithoutInvitesInput {
  charge?: Maybe<String>;
  numSlots: Int;
  numPlayers: Int;
  players?: Maybe<BookedPlayerCreateManyWithoutBookingInput>;
  total: Float;
  bookee: UserCreateOneInput;
  timeslot: GamingTimeSlotCreateOneWithoutBookingsInput;
  cancelled?: Maybe<Boolean>;
  notifications?: Maybe<NotificationCreateManyWithoutBookingInput>;
}

export interface BookingInviteUpdateWithWhereUniqueWithoutBookingInput {
  where: BookingInviteWhereUniqueInput;
  data: BookingInviteUpdateWithoutBookingDataInput;
}

export interface BookedPlayerCreateWithoutBookingInput {
  player: UserCreateOneInput;
  timeslot: GamingTimeSlotCreateOneWithoutPlayersInput;
}

export interface BookingInviteUpdateWithoutBookingDataInput {
  startTime?: Maybe<DateTimeInput>;
  to?: Maybe<UserUpdateOneWithoutInvitesReceivedInput>;
  from?: Maybe<UserUpdateOneRequiredWithoutInvitesInput>;
  sent?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
  notification?: Maybe<NotificationUpdateOneWithoutBookingInviteInput>;
}

export interface GamingTimeSlotCreateWithoutPlayersInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamingSession: GamingSessionCreateOneWithoutTimeslotsInput;
  gamers?: Maybe<UserCreateManyWithoutTimeSlotsInput>;
  bookings?: Maybe<BookingCreateManyWithoutTimeslotInput>;
  length: Int;
  slots: Int;
}

export interface UserUpdateOneWithoutInvitesReceivedInput {
  create?: Maybe<UserCreateWithoutInvitesReceivedInput>;
  update?: Maybe<UserUpdateWithoutInvitesReceivedDataInput>;
  upsert?: Maybe<UserUpsertWithoutInvitesReceivedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutTimeSlotsInput {
  gender?: Maybe<Gender>;
  email: String;
  username: String;
  displayName: String;
  password: String;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserCreateoccupationsInput>;
  name: String;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionCreateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteCreateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardCreateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteCreateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewCreateManyWithoutUserInput>;
  friends?: Maybe<UserCreateManyInput>;
  gamertags?: Maybe<GamerTagCreateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index: UserIndexCreateOneWithoutUserInput;
}

export interface UserUpdateWithoutInvitesReceivedDataInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionUpdateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotUpdateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardUpdateManyWithoutUserInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutUserInput>;
  friends?: Maybe<UserUpdateManyInput>;
  gamertags?: Maybe<GamerTagUpdateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index?: Maybe<UserIndexUpdateOneRequiredWithoutUserInput>;
}

export interface SavedCardCreateWithoutUserInput {
  cardId: String;
  default: Boolean;
  lastFour: String;
  brand: String;
}

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface BookingInviteCreateWithoutToInput {
  startTime: DateTimeInput;
  booking: BookingCreateOneWithoutInvitesInput;
  from: UserCreateOneWithoutInvitesInput;
  sent: Boolean;
  accepted?: Maybe<Boolean>;
  notification?: Maybe<NotificationCreateOneWithoutBookingInviteInput>;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserCreateWithoutInvitesInput {
  gender?: Maybe<Gender>;
  email: String;
  username: String;
  displayName: String;
  password: String;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserCreateoccupationsInput>;
  name: String;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionCreateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotCreateManyWithoutGamersInput>;
  savedCards?: Maybe<SavedCardCreateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteCreateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewCreateManyWithoutUserInput>;
  friends?: Maybe<UserCreateManyInput>;
  gamertags?: Maybe<GamerTagCreateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index: UserIndexCreateOneWithoutUserInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface SessionReviewCreateWithoutUserInput {
  session: GamingSessionCreateOneWithoutReviewsInput;
  text: String;
  rating: Int;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  displayName?: Maybe<String>;
  displayName_not?: Maybe<String>;
  displayName_in?: Maybe<String[] | String>;
  displayName_not_in?: Maybe<String[] | String>;
  displayName_lt?: Maybe<String>;
  displayName_lte?: Maybe<String>;
  displayName_gt?: Maybe<String>;
  displayName_gte?: Maybe<String>;
  displayName_contains?: Maybe<String>;
  displayName_not_contains?: Maybe<String>;
  displayName_starts_with?: Maybe<String>;
  displayName_not_starts_with?: Maybe<String>;
  displayName_ends_with?: Maybe<String>;
  displayName_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  profilePicture?: Maybe<String>;
  profilePicture_not?: Maybe<String>;
  profilePicture_in?: Maybe<String[] | String>;
  profilePicture_not_in?: Maybe<String[] | String>;
  profilePicture_lt?: Maybe<String>;
  profilePicture_lte?: Maybe<String>;
  profilePicture_gt?: Maybe<String>;
  profilePicture_gte?: Maybe<String>;
  profilePicture_contains?: Maybe<String>;
  profilePicture_not_contains?: Maybe<String>;
  profilePicture_starts_with?: Maybe<String>;
  profilePicture_not_starts_with?: Maybe<String>;
  profilePicture_ends_with?: Maybe<String>;
  profilePicture_not_ends_with?: Maybe<String>;
  banner?: Maybe<String>;
  banner_not?: Maybe<String>;
  banner_in?: Maybe<String[] | String>;
  banner_not_in?: Maybe<String[] | String>;
  banner_lt?: Maybe<String>;
  banner_lte?: Maybe<String>;
  banner_gt?: Maybe<String>;
  banner_gte?: Maybe<String>;
  banner_contains?: Maybe<String>;
  banner_not_contains?: Maybe<String>;
  banner_starts_with?: Maybe<String>;
  banner_not_starts_with?: Maybe<String>;
  banner_ends_with?: Maybe<String>;
  banner_not_ends_with?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  connectedStripeId_not?: Maybe<String>;
  connectedStripeId_in?: Maybe<String[] | String>;
  connectedStripeId_not_in?: Maybe<String[] | String>;
  connectedStripeId_lt?: Maybe<String>;
  connectedStripeId_lte?: Maybe<String>;
  connectedStripeId_gt?: Maybe<String>;
  connectedStripeId_gte?: Maybe<String>;
  connectedStripeId_contains?: Maybe<String>;
  connectedStripeId_not_contains?: Maybe<String>;
  connectedStripeId_starts_with?: Maybe<String>;
  connectedStripeId_not_starts_with?: Maybe<String>;
  connectedStripeId_ends_with?: Maybe<String>;
  connectedStripeId_not_ends_with?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  customerStripeId_not?: Maybe<String>;
  customerStripeId_in?: Maybe<String[] | String>;
  customerStripeId_not_in?: Maybe<String[] | String>;
  customerStripeId_lt?: Maybe<String>;
  customerStripeId_lte?: Maybe<String>;
  customerStripeId_gt?: Maybe<String>;
  customerStripeId_gte?: Maybe<String>;
  customerStripeId_contains?: Maybe<String>;
  customerStripeId_not_contains?: Maybe<String>;
  customerStripeId_starts_with?: Maybe<String>;
  customerStripeId_not_starts_with?: Maybe<String>;
  customerStripeId_ends_with?: Maybe<String>;
  customerStripeId_not_ends_with?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  gamerIsSetup_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  aboutMe?: Maybe<String>;
  aboutMe_not?: Maybe<String>;
  aboutMe_in?: Maybe<String[] | String>;
  aboutMe_not_in?: Maybe<String[] | String>;
  aboutMe_lt?: Maybe<String>;
  aboutMe_lte?: Maybe<String>;
  aboutMe_gt?: Maybe<String>;
  aboutMe_gte?: Maybe<String>;
  aboutMe_contains?: Maybe<String>;
  aboutMe_not_contains?: Maybe<String>;
  aboutMe_starts_with?: Maybe<String>;
  aboutMe_not_starts_with?: Maybe<String>;
  aboutMe_ends_with?: Maybe<String>;
  aboutMe_not_ends_with?: Maybe<String>;
  setup?: Maybe<Int>;
  setup_not?: Maybe<Int>;
  setup_in?: Maybe<Int[] | Int>;
  setup_not_in?: Maybe<Int[] | Int>;
  setup_lt?: Maybe<Int>;
  setup_lte?: Maybe<Int>;
  setup_gt?: Maybe<Int>;
  setup_gte?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordToken_not?: Maybe<String>;
  resetPasswordToken_in?: Maybe<String[] | String>;
  resetPasswordToken_not_in?: Maybe<String[] | String>;
  resetPasswordToken_lt?: Maybe<String>;
  resetPasswordToken_lte?: Maybe<String>;
  resetPasswordToken_gt?: Maybe<String>;
  resetPasswordToken_gte?: Maybe<String>;
  resetPasswordToken_contains?: Maybe<String>;
  resetPasswordToken_not_contains?: Maybe<String>;
  resetPasswordToken_starts_with?: Maybe<String>;
  resetPasswordToken_not_starts_with?: Maybe<String>;
  resetPasswordToken_ends_with?: Maybe<String>;
  resetPasswordToken_not_ends_with?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  resetPasswordExpires_not?: Maybe<DateTimeInput>;
  resetPasswordExpires_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  resetPasswordExpires_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  resetPasswordExpires_lt?: Maybe<DateTimeInput>;
  resetPasswordExpires_lte?: Maybe<DateTimeInput>;
  resetPasswordExpires_gt?: Maybe<DateTimeInput>;
  resetPasswordExpires_gte?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  views_not?: Maybe<Int>;
  views_in?: Maybe<Int[] | Int>;
  views_not_in?: Maybe<Int[] | Int>;
  views_lt?: Maybe<Int>;
  views_lte?: Maybe<Int>;
  views_gt?: Maybe<Int>;
  views_gte?: Maybe<Int>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface GamingSessionCreateWithoutReviewsInput {
  gamers?: Maybe<UserCreateManyWithoutSessionsInput>;
  creator: UserCreateOneInput;
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  launcher?: Maybe<Launcher>;
  system: System;
  type: TypeOfGame;
  slots: Int;
  requirements?: Maybe<RequirementCreateManyInput>;
  discounts?: Maybe<DiscountCreateManyInput>;
  timeslots?: Maybe<GamingTimeSlotCreateManyWithoutGamingSessionInput>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface RequirementCreateInput {
  msg: String;
}

export interface UserUpdateManyDataInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  role?: Maybe<Role>;
}

export interface DiscountCreateInput {
  percentage: Int;
  threshold: Int;
  playerOrSession: PlayerOrSession;
}

export interface GamerTagUpdateOneWithoutUserInput {
  create?: Maybe<GamerTagCreateWithoutUserInput>;
  update?: Maybe<GamerTagUpdateWithoutUserDataInput>;
  upsert?: Maybe<GamerTagUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<GamerTagWhereUniqueInput>;
}

export interface GamingTimeSlotCreateWithoutGamingSessionInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamers?: Maybe<UserCreateManyWithoutTimeSlotsInput>;
  bookings?: Maybe<BookingCreateManyWithoutTimeslotInput>;
  players?: Maybe<BookedPlayerCreateManyWithoutTimeslotInput>;
  length: Int;
  slots: Int;
}

export interface GamerTagUpdateWithoutUserDataInput {
  psn?: Maybe<String>;
  xbl?: Maybe<String>;
  nso?: Maybe<String>;
  pc?: Maybe<PCLauncherUpdateOneWithoutGamerTagInput>;
}

export interface BookingCreateWithoutTimeslotInput {
  charge?: Maybe<String>;
  numSlots: Int;
  numPlayers: Int;
  players?: Maybe<BookedPlayerCreateManyWithoutBookingInput>;
  total: Float;
  bookee: UserCreateOneInput;
  invites?: Maybe<BookingInviteCreateManyWithoutBookingInput>;
  cancelled?: Maybe<Boolean>;
  notifications?: Maybe<NotificationCreateManyWithoutBookingInput>;
}

export interface PCLauncherUpdateOneWithoutGamerTagInput {
  create?: Maybe<PCLauncherCreateWithoutGamerTagInput>;
  update?: Maybe<PCLauncherUpdateWithoutGamerTagDataInput>;
  upsert?: Maybe<PCLauncherUpsertWithoutGamerTagInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PCLauncherWhereUniqueInput>;
}

export interface BookingInviteCreateWithoutBookingInput {
  startTime: DateTimeInput;
  to?: Maybe<UserCreateOneWithoutInvitesReceivedInput>;
  from: UserCreateOneWithoutInvitesInput;
  sent: Boolean;
  accepted?: Maybe<Boolean>;
  notification?: Maybe<NotificationCreateOneWithoutBookingInviteInput>;
}

export interface PCLauncherUpdateWithoutGamerTagDataInput {
  epic?: Maybe<String>;
  steam?: Maybe<String>;
  origin?: Maybe<String>;
  gog?: Maybe<String>;
  battlenet?: Maybe<String>;
  uplay?: Maybe<String>;
  bethesda?: Maybe<String>;
  itch?: Maybe<String>;
  windows?: Maybe<String>;
  riot?: Maybe<String>;
}

export interface UserCreateWithoutInvitesReceivedInput {
  gender?: Maybe<Gender>;
  email: String;
  username: String;
  displayName: String;
  password: String;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserCreateoccupationsInput>;
  name: String;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionCreateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotCreateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteCreateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardCreateManyWithoutUserInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewCreateManyWithoutUserInput>;
  friends?: Maybe<UserCreateManyInput>;
  gamertags?: Maybe<GamerTagCreateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index: UserIndexCreateOneWithoutUserInput;
}

export interface PCLauncherUpsertWithoutGamerTagInput {
  update: PCLauncherUpdateWithoutGamerTagDataInput;
  create: PCLauncherCreateWithoutGamerTagInput;
}

export interface GamerTagCreateOneWithoutUserInput {
  create?: Maybe<GamerTagCreateWithoutUserInput>;
  connect?: Maybe<GamerTagWhereUniqueInput>;
}

export interface GamerTagUpsertWithoutUserInput {
  update: GamerTagUpdateWithoutUserDataInput;
  create: GamerTagCreateWithoutUserInput;
}

export interface PCLauncherCreateOneWithoutGamerTagInput {
  create?: Maybe<PCLauncherCreateWithoutGamerTagInput>;
  connect?: Maybe<PCLauncherWhereUniqueInput>;
}

export interface UserIndexUpdateOneRequiredWithoutUserInput {
  create?: Maybe<UserIndexCreateWithoutUserInput>;
  update?: Maybe<UserIndexUpdateWithoutUserDataInput>;
  upsert?: Maybe<UserIndexUpsertWithoutUserInput>;
  connect?: Maybe<UserIndexWhereUniqueInput>;
}

export interface UserIndexCreateOneWithoutUserInput {
  create?: Maybe<UserIndexCreateWithoutUserInput>;
  connect?: Maybe<UserIndexWhereUniqueInput>;
}

export interface UserIndexUpdateWithoutUserDataInput {
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  name?: Maybe<String>;
}

export interface NotificationCreateOneWithoutBookingInviteInput {
  create?: Maybe<NotificationCreateWithoutBookingInviteInput>;
  connect?: Maybe<NotificationWhereUniqueInput>;
}

export interface UserIndexUpsertWithoutUserInput {
  update: UserIndexUpdateWithoutUserDataInput;
  create: UserIndexCreateWithoutUserInput;
}

export interface FriendRequestCreateOneWithoutNotificationInput {
  create?: Maybe<FriendRequestCreateWithoutNotificationInput>;
  connect?: Maybe<FriendRequestWhereUniqueInput>;
}

export interface UserUpsertWithoutInvitesReceivedInput {
  update: UserUpdateWithoutInvitesReceivedDataInput;
  create: UserCreateWithoutInvitesReceivedInput;
}

export interface BookingCreateOneWithoutNotificationsInput {
  create?: Maybe<BookingCreateWithoutNotificationsInput>;
  connect?: Maybe<BookingWhereUniqueInput>;
}

export interface NotificationUpdateOneWithoutBookingInviteInput {
  create?: Maybe<NotificationCreateWithoutBookingInviteInput>;
  update?: Maybe<NotificationUpdateWithoutBookingInviteDataInput>;
  upsert?: Maybe<NotificationUpsertWithoutBookingInviteInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<NotificationWhereUniqueInput>;
}

export interface GamingTimeSlotCreateOneWithoutBookingsInput {
  create?: Maybe<GamingTimeSlotCreateWithoutBookingsInput>;
  connect?: Maybe<GamingTimeSlotWhereUniqueInput>;
}

export interface NotificationUpdateWithoutBookingInviteDataInput {
  type?: Maybe<NotificationType>;
  text?: Maybe<String>;
  for?: Maybe<UserUpdateOneRequiredInput>;
  friendRequest?: Maybe<FriendRequestUpdateOneWithoutNotificationInput>;
  booking?: Maybe<BookingUpdateOneWithoutNotificationsInput>;
  friend?: Maybe<UserUpdateOneInput>;
  viewed?: Maybe<Boolean>;
}

export interface BookedPlayerCreateManyWithoutTimeslotInput {
  create?: Maybe<
    | BookedPlayerCreateWithoutTimeslotInput[]
    | BookedPlayerCreateWithoutTimeslotInput
  >;
  connect?: Maybe<
    BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput
  >;
}

export interface FriendRequestUpdateOneWithoutNotificationInput {
  create?: Maybe<FriendRequestCreateWithoutNotificationInput>;
  update?: Maybe<FriendRequestUpdateWithoutNotificationDataInput>;
  upsert?: Maybe<FriendRequestUpsertWithoutNotificationInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FriendRequestWhereUniqueInput>;
}

export interface BookingCreateOneWithoutPlayersInput {
  create?: Maybe<BookingCreateWithoutPlayersInput>;
  connect?: Maybe<BookingWhereUniqueInput>;
}

export interface FriendRequestUpdateWithoutNotificationDataInput {
  to?: Maybe<UserUpdateOneRequiredInput>;
  from?: Maybe<UserUpdateOneRequiredInput>;
}

export interface NotificationCreateManyWithoutBookingInput {
  create?: Maybe<
    | NotificationCreateWithoutBookingInput[]
    | NotificationCreateWithoutBookingInput
  >;
  connect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
}

export interface FriendRequestUpsertWithoutNotificationInput {
  update: FriendRequestUpdateWithoutNotificationDataInput;
  create: FriendRequestCreateWithoutNotificationInput;
}

export interface BookingInviteCreateOneWithoutNotificationInput {
  create?: Maybe<BookingInviteCreateWithoutNotificationInput>;
  connect?: Maybe<BookingInviteWhereUniqueInput>;
}

export interface BookingUpdateOneWithoutNotificationsInput {
  create?: Maybe<BookingCreateWithoutNotificationsInput>;
  update?: Maybe<BookingUpdateWithoutNotificationsDataInput>;
  upsert?: Maybe<BookingUpsertWithoutNotificationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BookingWhereUniqueInput>;
}

export interface UserIndexSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserIndexWhereInput>;
  AND?: Maybe<
    UserIndexSubscriptionWhereInput[] | UserIndexSubscriptionWhereInput
  >;
  OR?: Maybe<
    UserIndexSubscriptionWhereInput[] | UserIndexSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserIndexSubscriptionWhereInput[] | UserIndexSubscriptionWhereInput
  >;
}

export interface BookingUpdateWithoutNotificationsDataInput {
  charge?: Maybe<String>;
  numSlots?: Maybe<Int>;
  numPlayers?: Maybe<Int>;
  players?: Maybe<BookedPlayerUpdateManyWithoutBookingInput>;
  total?: Maybe<Float>;
  bookee?: Maybe<UserUpdateOneRequiredInput>;
  timeslot?: Maybe<GamingTimeSlotUpdateOneRequiredWithoutBookingsInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutBookingInput>;
  cancelled?: Maybe<Boolean>;
}

export interface SocialMediaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SocialMediaWhereInput>;
  AND?: Maybe<
    SocialMediaSubscriptionWhereInput[] | SocialMediaSubscriptionWhereInput
  >;
  OR?: Maybe<
    SocialMediaSubscriptionWhereInput[] | SocialMediaSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SocialMediaSubscriptionWhereInput[] | SocialMediaSubscriptionWhereInput
  >;
}

export interface GamingTimeSlotUpdateOneRequiredWithoutBookingsInput {
  create?: Maybe<GamingTimeSlotCreateWithoutBookingsInput>;
  update?: Maybe<GamingTimeSlotUpdateWithoutBookingsDataInput>;
  upsert?: Maybe<GamingTimeSlotUpsertWithoutBookingsInput>;
  connect?: Maybe<GamingTimeSlotWhereUniqueInput>;
}

export interface NotificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<NotificationType>;
  type_not?: Maybe<NotificationType>;
  type_in?: Maybe<NotificationType[] | NotificationType>;
  type_not_in?: Maybe<NotificationType[] | NotificationType>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  for?: Maybe<UserWhereInput>;
  friendRequest?: Maybe<FriendRequestWhereInput>;
  bookingInvite?: Maybe<BookingInviteWhereInput>;
  booking?: Maybe<BookingWhereInput>;
  friend?: Maybe<UserWhereInput>;
  viewed?: Maybe<Boolean>;
  viewed_not?: Maybe<Boolean>;
  AND?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
  OR?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
  NOT?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
}

export interface GamingTimeSlotUpdateWithoutBookingsDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  gamingSession?: Maybe<GamingSessionUpdateOneRequiredWithoutTimeslotsInput>;
  gamers?: Maybe<UserUpdateManyWithoutTimeSlotsInput>;
  players?: Maybe<BookedPlayerUpdateManyWithoutTimeslotInput>;
  length?: Maybe<Int>;
  slots?: Maybe<Int>;
}

export interface BookingInviteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  booking?: Maybe<BookingWhereInput>;
  to?: Maybe<UserWhereInput>;
  from?: Maybe<UserWhereInput>;
  sent?: Maybe<Boolean>;
  sent_not?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
  accepted_not?: Maybe<Boolean>;
  notification?: Maybe<NotificationWhereInput>;
  AND?: Maybe<BookingInviteWhereInput[] | BookingInviteWhereInput>;
  OR?: Maybe<BookingInviteWhereInput[] | BookingInviteWhereInput>;
  NOT?: Maybe<BookingInviteWhereInput[] | BookingInviteWhereInput>;
}

export interface BookedPlayerUpdateManyWithoutTimeslotInput {
  create?: Maybe<
    | BookedPlayerCreateWithoutTimeslotInput[]
    | BookedPlayerCreateWithoutTimeslotInput
  >;
  delete?: Maybe<BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput>;
  connect?: Maybe<
    BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput
  >;
  set?: Maybe<BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput>;
  disconnect?: Maybe<
    BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput
  >;
  update?: Maybe<
    | BookedPlayerUpdateWithWhereUniqueWithoutTimeslotInput[]
    | BookedPlayerUpdateWithWhereUniqueWithoutTimeslotInput
  >;
  upsert?: Maybe<
    | BookedPlayerUpsertWithWhereUniqueWithoutTimeslotInput[]
    | BookedPlayerUpsertWithWhereUniqueWithoutTimeslotInput
  >;
  deleteMany?: Maybe<
    BookedPlayerScalarWhereInput[] | BookedPlayerScalarWhereInput
  >;
}

export interface GamingSessionIndexSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GamingSessionIndexWhereInput>;
  AND?: Maybe<
    | GamingSessionIndexSubscriptionWhereInput[]
    | GamingSessionIndexSubscriptionWhereInput
  >;
  OR?: Maybe<
    | GamingSessionIndexSubscriptionWhereInput[]
    | GamingSessionIndexSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | GamingSessionIndexSubscriptionWhereInput[]
    | GamingSessionIndexSubscriptionWhereInput
  >;
}

export interface BookedPlayerUpdateWithWhereUniqueWithoutTimeslotInput {
  where: BookedPlayerWhereUniqueInput;
  data: BookedPlayerUpdateWithoutTimeslotDataInput;
}

export interface GameIndexSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GameIndexWhereInput>;
  AND?: Maybe<
    GameIndexSubscriptionWhereInput[] | GameIndexSubscriptionWhereInput
  >;
  OR?: Maybe<
    GameIndexSubscriptionWhereInput[] | GameIndexSubscriptionWhereInput
  >;
  NOT?: Maybe<
    GameIndexSubscriptionWhereInput[] | GameIndexSubscriptionWhereInput
  >;
}

export interface BookedPlayerUpdateWithoutTimeslotDataInput {
  player?: Maybe<UserUpdateOneRequiredInput>;
  booking?: Maybe<BookingUpdateOneRequiredWithoutPlayersInput>;
}

export interface DiscountSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DiscountWhereInput>;
  AND?: Maybe<
    DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput
  >;
  OR?: Maybe<DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput>;
  NOT?: Maybe<
    DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput
  >;
}

export interface BookingUpdateOneRequiredWithoutPlayersInput {
  create?: Maybe<BookingCreateWithoutPlayersInput>;
  update?: Maybe<BookingUpdateWithoutPlayersDataInput>;
  upsert?: Maybe<BookingUpsertWithoutPlayersInput>;
  connect?: Maybe<BookingWhereUniqueInput>;
}

export interface BookedPlayerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BookedPlayerWhereInput>;
  AND?: Maybe<
    BookedPlayerSubscriptionWhereInput[] | BookedPlayerSubscriptionWhereInput
  >;
  OR?: Maybe<
    BookedPlayerSubscriptionWhereInput[] | BookedPlayerSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BookedPlayerSubscriptionWhereInput[] | BookedPlayerSubscriptionWhereInput
  >;
}

export interface BookingUpdateWithoutPlayersDataInput {
  charge?: Maybe<String>;
  numSlots?: Maybe<Int>;
  numPlayers?: Maybe<Int>;
  total?: Maybe<Float>;
  bookee?: Maybe<UserUpdateOneRequiredInput>;
  timeslot?: Maybe<GamingTimeSlotUpdateOneRequiredWithoutBookingsInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutBookingInput>;
  cancelled?: Maybe<Boolean>;
  notifications?: Maybe<NotificationUpdateManyWithoutBookingInput>;
}

export interface UserUpdateWithoutIndexDataInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionUpdateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotUpdateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardUpdateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteUpdateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutUserInput>;
  friends?: Maybe<UserUpdateManyInput>;
  gamertags?: Maybe<GamerTagUpdateOneWithoutUserInput>;
  role?: Maybe<Role>;
}

export interface NotificationUpdateManyWithoutBookingInput {
  create?: Maybe<
    | NotificationCreateWithoutBookingInput[]
    | NotificationCreateWithoutBookingInput
  >;
  delete?: Maybe<NotificationWhereUniqueInput[] | NotificationWhereUniqueInput>;
  connect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
  set?: Maybe<NotificationWhereUniqueInput[] | NotificationWhereUniqueInput>;
  disconnect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
  update?: Maybe<
    | NotificationUpdateWithWhereUniqueWithoutBookingInput[]
    | NotificationUpdateWithWhereUniqueWithoutBookingInput
  >;
  upsert?: Maybe<
    | NotificationUpsertWithWhereUniqueWithoutBookingInput[]
    | NotificationUpsertWithWhereUniqueWithoutBookingInput
  >;
  deleteMany?: Maybe<
    NotificationScalarWhereInput[] | NotificationScalarWhereInput
  >;
  updateMany?: Maybe<
    | NotificationUpdateManyWithWhereNestedInput[]
    | NotificationUpdateManyWithWhereNestedInput
  >;
}

export interface UserIndexUpdateInput {
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  name?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutIndexInput>;
}

export interface NotificationUpdateWithWhereUniqueWithoutBookingInput {
  where: NotificationWhereUniqueInput;
  data: NotificationUpdateWithoutBookingDataInput;
}

export interface UserIndexCreateInput {
  email: String;
  username: String;
  displayName?: Maybe<String>;
  name: String;
  user: UserCreateOneWithoutIndexInput;
}

export interface NotificationUpdateWithoutBookingDataInput {
  type?: Maybe<NotificationType>;
  text?: Maybe<String>;
  for?: Maybe<UserUpdateOneRequiredInput>;
  friendRequest?: Maybe<FriendRequestUpdateOneWithoutNotificationInput>;
  bookingInvite?: Maybe<BookingInviteUpdateOneWithoutNotificationInput>;
  friend?: Maybe<UserUpdateOneInput>;
  viewed?: Maybe<Boolean>;
}

export type GameIndexWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BookingInviteUpdateOneWithoutNotificationInput {
  create?: Maybe<BookingInviteCreateWithoutNotificationInput>;
  update?: Maybe<BookingInviteUpdateWithoutNotificationDataInput>;
  upsert?: Maybe<BookingInviteUpsertWithoutNotificationInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BookingInviteWhereUniqueInput>;
}

export interface SessionReviewIndexUpdateManyMutationInput {
  text?: Maybe<String>;
}

export interface BookingInviteUpdateWithoutNotificationDataInput {
  startTime?: Maybe<DateTimeInput>;
  booking?: Maybe<BookingUpdateOneRequiredWithoutInvitesInput>;
  to?: Maybe<UserUpdateOneWithoutInvitesReceivedInput>;
  from?: Maybe<UserUpdateOneRequiredWithoutInvitesInput>;
  sent?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
}

export interface SessionReviewUpdateOneRequiredInput {
  create?: Maybe<SessionReviewCreateInput>;
  update?: Maybe<SessionReviewUpdateDataInput>;
  upsert?: Maybe<SessionReviewUpsertNestedInput>;
  connect?: Maybe<SessionReviewWhereUniqueInput>;
}

export interface BookingInviteUpsertWithoutNotificationInput {
  update: BookingInviteUpdateWithoutNotificationDataInput;
  create: BookingInviteCreateWithoutNotificationInput;
}

export interface GamingTimeSlotWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  gamingSession?: Maybe<GamingSessionWhereInput>;
  gamers_every?: Maybe<UserWhereInput>;
  gamers_some?: Maybe<UserWhereInput>;
  gamers_none?: Maybe<UserWhereInput>;
  bookings_every?: Maybe<BookingWhereInput>;
  bookings_some?: Maybe<BookingWhereInput>;
  bookings_none?: Maybe<BookingWhereInput>;
  players_every?: Maybe<BookedPlayerWhereInput>;
  players_some?: Maybe<BookedPlayerWhereInput>;
  players_none?: Maybe<BookedPlayerWhereInput>;
  length?: Maybe<Int>;
  length_not?: Maybe<Int>;
  length_in?: Maybe<Int[] | Int>;
  length_not_in?: Maybe<Int[] | Int>;
  length_lt?: Maybe<Int>;
  length_lte?: Maybe<Int>;
  length_gt?: Maybe<Int>;
  length_gte?: Maybe<Int>;
  slots?: Maybe<Int>;
  slots_not?: Maybe<Int>;
  slots_in?: Maybe<Int[] | Int>;
  slots_not_in?: Maybe<Int[] | Int>;
  slots_lt?: Maybe<Int>;
  slots_lte?: Maybe<Int>;
  slots_gt?: Maybe<Int>;
  slots_gte?: Maybe<Int>;
  AND?: Maybe<GamingTimeSlotWhereInput[] | GamingTimeSlotWhereInput>;
  OR?: Maybe<GamingTimeSlotWhereInput[] | GamingTimeSlotWhereInput>;
  NOT?: Maybe<GamingTimeSlotWhereInput[] | GamingTimeSlotWhereInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type GamerTagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface SavedCardUpdateManyMutationInput {
  cardId?: Maybe<String>;
  default?: Maybe<Boolean>;
  lastFour?: Maybe<String>;
  brand?: Maybe<String>;
}

export interface NotificationUpsertWithWhereUniqueWithoutBookingInput {
  where: NotificationWhereUniqueInput;
  update: NotificationUpdateWithoutBookingDataInput;
  create: NotificationCreateWithoutBookingInput;
}

export interface UserUpdateOneRequiredWithoutSavedCardsInput {
  create?: Maybe<UserCreateWithoutSavedCardsInput>;
  update?: Maybe<UserUpdateWithoutSavedCardsDataInput>;
  upsert?: Maybe<UserUpsertWithoutSavedCardsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface NotificationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<NotificationType>;
  type_not?: Maybe<NotificationType>;
  type_in?: Maybe<NotificationType[] | NotificationType>;
  type_not_in?: Maybe<NotificationType[] | NotificationType>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  viewed?: Maybe<Boolean>;
  viewed_not?: Maybe<Boolean>;
  AND?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
  OR?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
  NOT?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
}

export interface GamingSessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  gamers_every?: Maybe<UserWhereInput>;
  gamers_some?: Maybe<UserWhereInput>;
  gamers_none?: Maybe<UserWhereInput>;
  creator?: Maybe<UserWhereInput>;
  game?: Maybe<GameWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  length?: Maybe<Int>;
  length_not?: Maybe<Int>;
  length_in?: Maybe<Int[] | Int>;
  length_not_in?: Maybe<Int[] | Int>;
  length_lt?: Maybe<Int>;
  length_lte?: Maybe<Int>;
  length_gt?: Maybe<Int>;
  length_gte?: Maybe<Int>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  launcher?: Maybe<Launcher>;
  launcher_not?: Maybe<Launcher>;
  launcher_in?: Maybe<Launcher[] | Launcher>;
  launcher_not_in?: Maybe<Launcher[] | Launcher>;
  reviews_every?: Maybe<SessionReviewWhereInput>;
  reviews_some?: Maybe<SessionReviewWhereInput>;
  reviews_none?: Maybe<SessionReviewWhereInput>;
  system?: Maybe<System>;
  system_not?: Maybe<System>;
  system_in?: Maybe<System[] | System>;
  system_not_in?: Maybe<System[] | System>;
  type?: Maybe<TypeOfGame>;
  type_not?: Maybe<TypeOfGame>;
  type_in?: Maybe<TypeOfGame[] | TypeOfGame>;
  type_not_in?: Maybe<TypeOfGame[] | TypeOfGame>;
  slots?: Maybe<Int>;
  slots_not?: Maybe<Int>;
  slots_in?: Maybe<Int[] | Int>;
  slots_not_in?: Maybe<Int[] | Int>;
  slots_lt?: Maybe<Int>;
  slots_lte?: Maybe<Int>;
  slots_gt?: Maybe<Int>;
  slots_gte?: Maybe<Int>;
  requirements_every?: Maybe<RequirementWhereInput>;
  requirements_some?: Maybe<RequirementWhereInput>;
  requirements_none?: Maybe<RequirementWhereInput>;
  discounts_every?: Maybe<DiscountWhereInput>;
  discounts_some?: Maybe<DiscountWhereInput>;
  discounts_none?: Maybe<DiscountWhereInput>;
  timeslots_every?: Maybe<GamingTimeSlotWhereInput>;
  timeslots_some?: Maybe<GamingTimeSlotWhereInput>;
  timeslots_none?: Maybe<GamingTimeSlotWhereInput>;
  popularity?: Maybe<Int>;
  popularity_not?: Maybe<Int>;
  popularity_in?: Maybe<Int[] | Int>;
  popularity_not_in?: Maybe<Int[] | Int>;
  popularity_lt?: Maybe<Int>;
  popularity_lte?: Maybe<Int>;
  popularity_gt?: Maybe<Int>;
  popularity_gte?: Maybe<Int>;
  views?: Maybe<Int>;
  views_not?: Maybe<Int>;
  views_in?: Maybe<Int[] | Int>;
  views_not_in?: Maybe<Int[] | Int>;
  views_lt?: Maybe<Int>;
  views_lte?: Maybe<Int>;
  views_gt?: Maybe<Int>;
  views_gte?: Maybe<Int>;
  retired?: Maybe<Boolean>;
  retired_not?: Maybe<Boolean>;
  AND?: Maybe<GamingSessionWhereInput[] | GamingSessionWhereInput>;
  OR?: Maybe<GamingSessionWhereInput[] | GamingSessionWhereInput>;
  NOT?: Maybe<GamingSessionWhereInput[] | GamingSessionWhereInput>;
}

export interface NotificationUpdateManyWithWhereNestedInput {
  where: NotificationScalarWhereInput;
  data: NotificationUpdateManyDataInput;
}

export type GamingTimeSlotWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NotificationUpdateManyDataInput {
  type?: Maybe<NotificationType>;
  text?: Maybe<String>;
  viewed?: Maybe<Boolean>;
}

export type NotificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BookingUpsertWithoutPlayersInput {
  update: BookingUpdateWithoutPlayersDataInput;
  create: BookingCreateWithoutPlayersInput;
}

export type PCLauncherWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BookedPlayerUpsertWithWhereUniqueWithoutTimeslotInput {
  where: BookedPlayerWhereUniqueInput;
  update: BookedPlayerUpdateWithoutTimeslotDataInput;
  create: BookedPlayerCreateWithoutTimeslotInput;
}

export interface PCLauncherCreateInput {
  gamerTag: GamerTagCreateOneWithoutPcInput;
  epic?: Maybe<String>;
  steam?: Maybe<String>;
  origin?: Maybe<String>;
  gog?: Maybe<String>;
  battlenet?: Maybe<String>;
  uplay?: Maybe<String>;
  bethesda?: Maybe<String>;
  itch?: Maybe<String>;
  windows?: Maybe<String>;
  riot?: Maybe<String>;
}

export interface BookedPlayerScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BookedPlayerScalarWhereInput[] | BookedPlayerScalarWhereInput>;
  OR?: Maybe<BookedPlayerScalarWhereInput[] | BookedPlayerScalarWhereInput>;
  NOT?: Maybe<BookedPlayerScalarWhereInput[] | BookedPlayerScalarWhereInput>;
}

export interface NotificationCreateInput {
  type: NotificationType;
  text: String;
  for: UserCreateOneInput;
  friendRequest?: Maybe<FriendRequestCreateOneWithoutNotificationInput>;
  bookingInvite?: Maybe<BookingInviteCreateOneWithoutNotificationInput>;
  booking?: Maybe<BookingCreateOneWithoutNotificationsInput>;
  friend?: Maybe<UserCreateOneInput>;
  viewed?: Maybe<Boolean>;
}

export interface GamingTimeSlotUpsertWithoutBookingsInput {
  update: GamingTimeSlotUpdateWithoutBookingsDataInput;
  create: GamingTimeSlotCreateWithoutBookingsInput;
}

export interface GamingTimeSlotCreateInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamingSession: GamingSessionCreateOneWithoutTimeslotsInput;
  gamers?: Maybe<UserCreateManyWithoutTimeSlotsInput>;
  bookings?: Maybe<BookingCreateManyWithoutTimeslotInput>;
  players?: Maybe<BookedPlayerCreateManyWithoutTimeslotInput>;
  length: Int;
  slots: Int;
}

export interface BookingUpsertWithoutNotificationsInput {
  update: BookingUpdateWithoutNotificationsDataInput;
  create: BookingCreateWithoutNotificationsInput;
}

export interface GamingSessionUpdateDataInput {
  gamers?: Maybe<UserUpdateManyWithoutSessionsInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  game?: Maybe<GameUpdateOneRequiredWithoutSessionsInput>;
  title?: Maybe<String>;
  length?: Maybe<Int>;
  price?: Maybe<Float>;
  launcher?: Maybe<Launcher>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutSessionInput>;
  system?: Maybe<System>;
  type?: Maybe<TypeOfGame>;
  slots?: Maybe<Int>;
  requirements?: Maybe<RequirementUpdateManyInput>;
  discounts?: Maybe<DiscountUpdateManyInput>;
  timeslots?: Maybe<GamingTimeSlotUpdateManyWithoutGamingSessionInput>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface NotificationUpsertWithoutBookingInviteInput {
  update: NotificationUpdateWithoutBookingInviteDataInput;
  create: NotificationCreateWithoutBookingInviteInput;
}

export interface GamingSessionIndexUpdateInput {
  title?: Maybe<String>;
  gamer?: Maybe<String>;
  game?: Maybe<String>;
  launcher?: Maybe<Launcher>;
  gamingSession?: Maybe<GamingSessionUpdateOneRequiredInput>;
}

export interface BookingInviteUpsertWithWhereUniqueWithoutBookingInput {
  where: BookingInviteWhereUniqueInput;
  update: BookingInviteUpdateWithoutBookingDataInput;
  create: BookingInviteCreateWithoutBookingInput;
}

export type SocialMediaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BookingInviteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  sent?: Maybe<Boolean>;
  sent_not?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
  accepted_not?: Maybe<Boolean>;
  AND?: Maybe<BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput>;
  OR?: Maybe<BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput>;
  NOT?: Maybe<BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput>;
}

export interface UserUpsertWithoutGamertagsInput {
  update: UserUpdateWithoutGamertagsDataInput;
  create: UserCreateWithoutGamertagsInput;
}

export interface BookingInviteUpdateManyWithWhereNestedInput {
  where: BookingInviteScalarWhereInput;
  data: BookingInviteUpdateManyDataInput;
}

export interface GamerTagUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutGamertagsInput>;
  psn?: Maybe<String>;
  xbl?: Maybe<String>;
  nso?: Maybe<String>;
  pc?: Maybe<PCLauncherUpdateOneWithoutGamerTagInput>;
}

export interface BookingInviteUpdateManyDataInput {
  startTime?: Maybe<DateTimeInput>;
  sent?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
}

export interface GamerTagCreateInput {
  user: UserCreateOneWithoutGamertagsInput;
  psn?: Maybe<String>;
  xbl?: Maybe<String>;
  nso?: Maybe<String>;
  pc?: Maybe<PCLauncherCreateOneWithoutGamerTagInput>;
}

export interface BookingUpsertWithWhereUniqueWithoutTimeslotInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutTimeslotDataInput;
  create: BookingCreateWithoutTimeslotInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BookingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  charge?: Maybe<String>;
  charge_not?: Maybe<String>;
  charge_in?: Maybe<String[] | String>;
  charge_not_in?: Maybe<String[] | String>;
  charge_lt?: Maybe<String>;
  charge_lte?: Maybe<String>;
  charge_gt?: Maybe<String>;
  charge_gte?: Maybe<String>;
  charge_contains?: Maybe<String>;
  charge_not_contains?: Maybe<String>;
  charge_starts_with?: Maybe<String>;
  charge_not_starts_with?: Maybe<String>;
  charge_ends_with?: Maybe<String>;
  charge_not_ends_with?: Maybe<String>;
  numSlots?: Maybe<Int>;
  numSlots_not?: Maybe<Int>;
  numSlots_in?: Maybe<Int[] | Int>;
  numSlots_not_in?: Maybe<Int[] | Int>;
  numSlots_lt?: Maybe<Int>;
  numSlots_lte?: Maybe<Int>;
  numSlots_gt?: Maybe<Int>;
  numSlots_gte?: Maybe<Int>;
  numPlayers?: Maybe<Int>;
  numPlayers_not?: Maybe<Int>;
  numPlayers_in?: Maybe<Int[] | Int>;
  numPlayers_not_in?: Maybe<Int[] | Int>;
  numPlayers_lt?: Maybe<Int>;
  numPlayers_lte?: Maybe<Int>;
  numPlayers_gt?: Maybe<Int>;
  numPlayers_gte?: Maybe<Int>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  cancelled?: Maybe<Boolean>;
  cancelled_not?: Maybe<Boolean>;
  AND?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
  OR?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
  NOT?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
}

export interface GamingSessionCreateWithoutGamersInput {
  creator: UserCreateOneInput;
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  launcher?: Maybe<Launcher>;
  reviews?: Maybe<SessionReviewCreateManyWithoutSessionInput>;
  system: System;
  type: TypeOfGame;
  slots: Int;
  requirements?: Maybe<RequirementCreateManyInput>;
  discounts?: Maybe<DiscountCreateManyInput>;
  timeslots?: Maybe<GamingTimeSlotCreateManyWithoutGamingSessionInput>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface BookingUpdateManyWithWhereNestedInput {
  where: BookingScalarWhereInput;
  data: BookingUpdateManyDataInput;
}

export interface SessionReviewCreateManyWithoutSessionInput {
  create?: Maybe<
    | SessionReviewCreateWithoutSessionInput[]
    | SessionReviewCreateWithoutSessionInput
  >;
  connect?: Maybe<
    SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput
  >;
}

export interface BookingUpdateManyDataInput {
  charge?: Maybe<String>;
  numSlots?: Maybe<Int>;
  numPlayers?: Maybe<Int>;
  total?: Maybe<Float>;
  cancelled?: Maybe<Boolean>;
}

export interface GamingTimeSlotCreateManyWithoutGamersInput {
  create?: Maybe<
    | GamingTimeSlotCreateWithoutGamersInput[]
    | GamingTimeSlotCreateWithoutGamersInput
  >;
  connect?: Maybe<
    GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput
  >;
}

export interface GamingTimeSlotUpsertWithWhereUniqueWithoutGamingSessionInput {
  where: GamingTimeSlotWhereUniqueInput;
  update: GamingTimeSlotUpdateWithoutGamingSessionDataInput;
  create: GamingTimeSlotCreateWithoutGamingSessionInput;
}

export interface UserCreateManyWithoutSessionsInput {
  create?: Maybe<
    UserCreateWithoutSessionsInput[] | UserCreateWithoutSessionsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface GamingTimeSlotScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  length?: Maybe<Int>;
  length_not?: Maybe<Int>;
  length_in?: Maybe<Int[] | Int>;
  length_not_in?: Maybe<Int[] | Int>;
  length_lt?: Maybe<Int>;
  length_lte?: Maybe<Int>;
  length_gt?: Maybe<Int>;
  length_gte?: Maybe<Int>;
  slots?: Maybe<Int>;
  slots_not?: Maybe<Int>;
  slots_in?: Maybe<Int[] | Int>;
  slots_not_in?: Maybe<Int[] | Int>;
  slots_lt?: Maybe<Int>;
  slots_lte?: Maybe<Int>;
  slots_gt?: Maybe<Int>;
  slots_gte?: Maybe<Int>;
  AND?: Maybe<
    GamingTimeSlotScalarWhereInput[] | GamingTimeSlotScalarWhereInput
  >;
  OR?: Maybe<GamingTimeSlotScalarWhereInput[] | GamingTimeSlotScalarWhereInput>;
  NOT?: Maybe<
    GamingTimeSlotScalarWhereInput[] | GamingTimeSlotScalarWhereInput
  >;
}

export interface BookingCreateOneWithoutInvitesInput {
  create?: Maybe<BookingCreateWithoutInvitesInput>;
  connect?: Maybe<BookingWhereUniqueInput>;
}

export interface GamingTimeSlotUpdateManyWithWhereNestedInput {
  where: GamingTimeSlotScalarWhereInput;
  data: GamingTimeSlotUpdateManyDataInput;
}

export interface GamingTimeSlotCreateOneWithoutPlayersInput {
  create?: Maybe<GamingTimeSlotCreateWithoutPlayersInput>;
  connect?: Maybe<GamingTimeSlotWhereUniqueInput>;
}

export interface GamingTimeSlotUpdateManyDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  length?: Maybe<Int>;
  slots?: Maybe<Int>;
}

export interface SavedCardCreateManyWithoutUserInput {
  create?: Maybe<
    SavedCardCreateWithoutUserInput[] | SavedCardCreateWithoutUserInput
  >;
  connect?: Maybe<SavedCardWhereUniqueInput[] | SavedCardWhereUniqueInput>;
}

export interface GamingSessionUpsertWithoutReviewsInput {
  update: GamingSessionUpdateWithoutReviewsDataInput;
  create: GamingSessionCreateWithoutReviewsInput;
}

export interface UserCreateOneWithoutInvitesInput {
  create?: Maybe<UserCreateWithoutInvitesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SessionReviewUpsertWithWhereUniqueWithoutUserInput {
  where: SessionReviewWhereUniqueInput;
  update: SessionReviewUpdateWithoutUserDataInput;
  create: SessionReviewCreateWithoutUserInput;
}

export interface GamingSessionCreateOneWithoutReviewsInput {
  create?: Maybe<GamingSessionCreateWithoutReviewsInput>;
  connect?: Maybe<GamingSessionWhereUniqueInput>;
}

export interface SessionReviewScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  rating?: Maybe<Int>;
  rating_not?: Maybe<Int>;
  rating_in?: Maybe<Int[] | Int>;
  rating_not_in?: Maybe<Int[] | Int>;
  rating_lt?: Maybe<Int>;
  rating_lte?: Maybe<Int>;
  rating_gt?: Maybe<Int>;
  rating_gte?: Maybe<Int>;
  AND?: Maybe<SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput>;
  OR?: Maybe<SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput>;
  NOT?: Maybe<SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput>;
}

export interface DiscountCreateManyInput {
  create?: Maybe<DiscountCreateInput[] | DiscountCreateInput>;
  connect?: Maybe<DiscountWhereUniqueInput[] | DiscountWhereUniqueInput>;
}

export interface SessionReviewUpdateManyWithWhereNestedInput {
  where: SessionReviewScalarWhereInput;
  data: SessionReviewUpdateManyDataInput;
}

export interface BookingCreateManyWithoutTimeslotInput {
  create?: Maybe<
    BookingCreateWithoutTimeslotInput[] | BookingCreateWithoutTimeslotInput
  >;
  connect?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
}

export interface SessionReviewUpdateManyDataInput {
  text?: Maybe<String>;
  rating?: Maybe<Int>;
}

export interface UserCreateOneWithoutInvitesReceivedInput {
  create?: Maybe<UserCreateWithoutInvitesReceivedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpsertWithoutInvitesInput {
  update: UserUpdateWithoutInvitesDataInput;
  create: UserCreateWithoutInvitesInput;
}

export interface GamerTagCreateWithoutUserInput {
  psn?: Maybe<String>;
  xbl?: Maybe<String>;
  nso?: Maybe<String>;
  pc?: Maybe<PCLauncherCreateOneWithoutGamerTagInput>;
}

export interface BookingInviteUpsertWithWhereUniqueWithoutToInput {
  where: BookingInviteWhereUniqueInput;
  update: BookingInviteUpdateWithoutToDataInput;
  create: BookingInviteCreateWithoutToInput;
}

export interface UserIndexCreateWithoutUserInput {
  email: String;
  username: String;
  displayName?: Maybe<String>;
  name: String;
}

export interface UserUpsertWithWhereUniqueWithoutTimeSlotsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTimeSlotsDataInput;
  create: UserCreateWithoutTimeSlotsInput;
}

export interface FriendRequestCreateWithoutNotificationInput {
  to: UserCreateOneInput;
  from: UserCreateOneInput;
}

export interface GamingTimeSlotUpsertWithoutPlayersInput {
  update: GamingTimeSlotUpdateWithoutPlayersDataInput;
  create: GamingTimeSlotCreateWithoutPlayersInput;
}

export interface GamingTimeSlotCreateWithoutBookingsInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamingSession: GamingSessionCreateOneWithoutTimeslotsInput;
  gamers?: Maybe<UserCreateManyWithoutTimeSlotsInput>;
  players?: Maybe<BookedPlayerCreateManyWithoutTimeslotInput>;
  length: Int;
  slots: Int;
}

export interface BookedPlayerUpsertWithWhereUniqueWithoutBookingInput {
  where: BookedPlayerWhereUniqueInput;
  update: BookedPlayerUpdateWithoutBookingDataInput;
  create: BookedPlayerCreateWithoutBookingInput;
}

export interface BookingCreateWithoutPlayersInput {
  charge?: Maybe<String>;
  numSlots: Int;
  numPlayers: Int;
  total: Float;
  bookee: UserCreateOneInput;
  timeslot: GamingTimeSlotCreateOneWithoutBookingsInput;
  invites?: Maybe<BookingInviteCreateManyWithoutBookingInput>;
  cancelled?: Maybe<Boolean>;
  notifications?: Maybe<NotificationCreateManyWithoutBookingInput>;
}

export interface BookingUpsertWithoutInvitesInput {
  update: BookingUpdateWithoutInvitesDataInput;
  create: BookingCreateWithoutInvitesInput;
}

export interface BookingInviteCreateWithoutNotificationInput {
  startTime: DateTimeInput;
  booking: BookingCreateOneWithoutInvitesInput;
  to?: Maybe<UserCreateOneWithoutInvitesReceivedInput>;
  from: UserCreateOneWithoutInvitesInput;
  sent: Boolean;
  accepted?: Maybe<Boolean>;
}

export interface BookingInviteUpsertWithWhereUniqueWithoutFromInput {
  where: BookingInviteWhereUniqueInput;
  update: BookingInviteUpdateWithoutFromDataInput;
  create: BookingInviteCreateWithoutFromInput;
}

export interface SessionReviewIndexSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SessionReviewIndexWhereInput>;
  AND?: Maybe<
    | SessionReviewIndexSubscriptionWhereInput[]
    | SessionReviewIndexSubscriptionWhereInput
  >;
  OR?: Maybe<
    | SessionReviewIndexSubscriptionWhereInput[]
    | SessionReviewIndexSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | SessionReviewIndexSubscriptionWhereInput[]
    | SessionReviewIndexSubscriptionWhereInput
  >;
}

export interface UserUpsertWithWhereUniqueWithoutSessionsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSessionsDataInput;
  create: UserCreateWithoutSessionsInput;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NotificationWhereInput>;
  AND?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
}

export interface GamingSessionUpsertWithoutTimeslotsInput {
  update: GamingSessionUpdateWithoutTimeslotsDataInput;
  create: GamingSessionCreateWithoutTimeslotsInput;
}

export type BookingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GamingTimeSlotUpsertWithWhereUniqueWithoutGamersInput {
  where: GamingTimeSlotWhereUniqueInput;
  update: GamingTimeSlotUpdateWithoutGamersDataInput;
  create: GamingTimeSlotCreateWithoutGamersInput;
}

export type DiscountWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpsertWithoutReviewsInput {
  update: UserUpdateWithoutReviewsDataInput;
  create: UserCreateWithoutReviewsInput;
}

export interface UserCreateOneWithoutIndexInput {
  create?: Maybe<UserCreateWithoutIndexInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SessionReviewUpsertWithWhereUniqueWithoutSessionInput {
  where: SessionReviewWhereUniqueInput;
  update: SessionReviewUpdateWithoutSessionDataInput;
  create: SessionReviewCreateWithoutSessionInput;
}

export interface GameIndexWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  launcher?: Maybe<String>;
  launcher_not?: Maybe<String>;
  launcher_in?: Maybe<String[] | String>;
  launcher_not_in?: Maybe<String[] | String>;
  launcher_lt?: Maybe<String>;
  launcher_lte?: Maybe<String>;
  launcher_gt?: Maybe<String>;
  launcher_gte?: Maybe<String>;
  launcher_contains?: Maybe<String>;
  launcher_not_contains?: Maybe<String>;
  launcher_starts_with?: Maybe<String>;
  launcher_not_starts_with?: Maybe<String>;
  launcher_ends_with?: Maybe<String>;
  launcher_not_ends_with?: Maybe<String>;
  game?: Maybe<GameWhereInput>;
  AND?: Maybe<GameIndexWhereInput[] | GameIndexWhereInput>;
  OR?: Maybe<GameIndexWhereInput[] | GameIndexWhereInput>;
  NOT?: Maybe<GameIndexWhereInput[] | GameIndexWhereInput>;
}

export interface GamingSessionUpsertWithWhereUniqueWithoutGamersInput {
  where: GamingSessionWhereUniqueInput;
  update: GamingSessionUpdateWithoutGamersDataInput;
  create: GamingSessionCreateWithoutGamersInput;
}

export interface GamerRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  addToOccupations?: Maybe<String>;
  addToOccupations_not?: Maybe<String>;
  addToOccupations_in?: Maybe<String[] | String>;
  addToOccupations_not_in?: Maybe<String[] | String>;
  addToOccupations_lt?: Maybe<String>;
  addToOccupations_lte?: Maybe<String>;
  addToOccupations_gt?: Maybe<String>;
  addToOccupations_gte?: Maybe<String>;
  addToOccupations_contains?: Maybe<String>;
  addToOccupations_not_contains?: Maybe<String>;
  addToOccupations_starts_with?: Maybe<String>;
  addToOccupations_not_starts_with?: Maybe<String>;
  addToOccupations_ends_with?: Maybe<String>;
  addToOccupations_not_ends_with?: Maybe<String>;
  socialMedia?: Maybe<SocialMediaWhereInput>;
  AND?: Maybe<GamerRequestWhereInput[] | GamerRequestWhereInput>;
  OR?: Maybe<GamerRequestWhereInput[] | GamerRequestWhereInput>;
  NOT?: Maybe<GamerRequestWhereInput[] | GamerRequestWhereInput>;
}

export interface GamingSessionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  length?: Maybe<Int>;
  length_not?: Maybe<Int>;
  length_in?: Maybe<Int[] | Int>;
  length_not_in?: Maybe<Int[] | Int>;
  length_lt?: Maybe<Int>;
  length_lte?: Maybe<Int>;
  length_gt?: Maybe<Int>;
  length_gte?: Maybe<Int>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  launcher?: Maybe<Launcher>;
  launcher_not?: Maybe<Launcher>;
  launcher_in?: Maybe<Launcher[] | Launcher>;
  launcher_not_in?: Maybe<Launcher[] | Launcher>;
  system?: Maybe<System>;
  system_not?: Maybe<System>;
  system_in?: Maybe<System[] | System>;
  system_not_in?: Maybe<System[] | System>;
  type?: Maybe<TypeOfGame>;
  type_not?: Maybe<TypeOfGame>;
  type_in?: Maybe<TypeOfGame[] | TypeOfGame>;
  type_not_in?: Maybe<TypeOfGame[] | TypeOfGame>;
  slots?: Maybe<Int>;
  slots_not?: Maybe<Int>;
  slots_in?: Maybe<Int[] | Int>;
  slots_not_in?: Maybe<Int[] | Int>;
  slots_lt?: Maybe<Int>;
  slots_lte?: Maybe<Int>;
  slots_gt?: Maybe<Int>;
  slots_gte?: Maybe<Int>;
  popularity?: Maybe<Int>;
  popularity_not?: Maybe<Int>;
  popularity_in?: Maybe<Int[] | Int>;
  popularity_not_in?: Maybe<Int[] | Int>;
  popularity_lt?: Maybe<Int>;
  popularity_lte?: Maybe<Int>;
  popularity_gt?: Maybe<Int>;
  popularity_gte?: Maybe<Int>;
  views?: Maybe<Int>;
  views_not?: Maybe<Int>;
  views_in?: Maybe<Int[] | Int>;
  views_not_in?: Maybe<Int[] | Int>;
  views_lt?: Maybe<Int>;
  views_lte?: Maybe<Int>;
  views_gt?: Maybe<Int>;
  views_gte?: Maybe<Int>;
  retired?: Maybe<Boolean>;
  retired_not?: Maybe<Boolean>;
  AND?: Maybe<GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput>;
  OR?: Maybe<GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput>;
  NOT?: Maybe<GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput>;
}

export interface SessionReviewUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutReviewsInput>;
  session?: Maybe<GamingSessionUpdateOneRequiredWithoutReviewsInput>;
  text?: Maybe<String>;
  rating?: Maybe<Int>;
}

export interface GamingSessionUpdateManyWithWhereNestedInput {
  where: GamingSessionScalarWhereInput;
  data: GamingSessionUpdateManyDataInput;
}

export interface SavedCardUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutSavedCardsInput>;
  cardId?: Maybe<String>;
  default?: Maybe<Boolean>;
  lastFour?: Maybe<String>;
  brand?: Maybe<String>;
}

export interface GamingSessionUpdateManyDataInput {
  title?: Maybe<String>;
  length?: Maybe<Int>;
  price?: Maybe<Float>;
  launcher?: Maybe<Launcher>;
  system?: Maybe<System>;
  type?: Maybe<TypeOfGame>;
  slots?: Maybe<Int>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface RequirementUpdateInput {
  msg?: Maybe<String>;
}

export interface GamerRequestUpdateoccupationsInput {
  set?: Maybe<Occupations[] | Occupations>;
}

export interface GamerTagCreateWithoutPcInput {
  user: UserCreateOneWithoutGamertagsInput;
  psn?: Maybe<String>;
  xbl?: Maybe<String>;
  nso?: Maybe<String>;
}

export interface GamerRequestUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  occupations?: Maybe<GamerRequestUpdateoccupationsInput>;
  addToOccupations?: Maybe<String>;
  socialMedia?: Maybe<SocialMediaUpdateOneRequiredInput>;
}

export interface GamingTimeSlotUpdateManyMutationInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  length?: Maybe<Int>;
  slots?: Maybe<Int>;
}

export interface BookingCreateInput {
  charge?: Maybe<String>;
  numSlots: Int;
  numPlayers: Int;
  players?: Maybe<BookedPlayerCreateManyWithoutBookingInput>;
  total: Float;
  bookee: UserCreateOneInput;
  timeslot: GamingTimeSlotCreateOneWithoutBookingsInput;
  invites?: Maybe<BookingInviteCreateManyWithoutBookingInput>;
  cancelled?: Maybe<Boolean>;
  notifications?: Maybe<NotificationCreateManyWithoutBookingInput>;
}

export interface GamingSessionUpdateOneRequiredInput {
  create?: Maybe<GamingSessionCreateInput>;
  update?: Maybe<GamingSessionUpdateDataInput>;
  upsert?: Maybe<GamingSessionUpsertNestedInput>;
  connect?: Maybe<GamingSessionWhereUniqueInput>;
}

export interface BookingUpdateInput {
  charge?: Maybe<String>;
  numSlots?: Maybe<Int>;
  numPlayers?: Maybe<Int>;
  players?: Maybe<BookedPlayerUpdateManyWithoutBookingInput>;
  total?: Maybe<Float>;
  bookee?: Maybe<UserUpdateOneRequiredInput>;
  timeslot?: Maybe<GamingTimeSlotUpdateOneRequiredWithoutBookingsInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutBookingInput>;
  cancelled?: Maybe<Boolean>;
  notifications?: Maybe<NotificationUpdateManyWithoutBookingInput>;
}

export interface GamingSessionCreateInput {
  gamers?: Maybe<UserCreateManyWithoutSessionsInput>;
  creator: UserCreateOneInput;
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  launcher?: Maybe<Launcher>;
  reviews?: Maybe<SessionReviewCreateManyWithoutSessionInput>;
  system: System;
  type: TypeOfGame;
  slots: Int;
  requirements?: Maybe<RequirementCreateManyInput>;
  discounts?: Maybe<DiscountCreateManyInput>;
  timeslots?: Maybe<GamingTimeSlotCreateManyWithoutGamingSessionInput>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface BookingUpdateManyMutationInput {
  charge?: Maybe<String>;
  numSlots?: Maybe<Int>;
  numPlayers?: Maybe<Int>;
  total?: Maybe<Float>;
  cancelled?: Maybe<Boolean>;
}

export interface UserCreateWithoutGamertagsInput {
  gender?: Maybe<Gender>;
  email: String;
  username: String;
  displayName: String;
  password: String;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserCreateoccupationsInput>;
  name: String;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionCreateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotCreateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteCreateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardCreateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteCreateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewCreateManyWithoutUserInput>;
  friends?: Maybe<UserCreateManyInput>;
  role?: Maybe<Role>;
  index: UserIndexCreateOneWithoutUserInput;
}

export interface BookingInviteCreateInput {
  startTime: DateTimeInput;
  booking: BookingCreateOneWithoutInvitesInput;
  to?: Maybe<UserCreateOneWithoutInvitesReceivedInput>;
  from: UserCreateOneWithoutInvitesInput;
  sent: Boolean;
  accepted?: Maybe<Boolean>;
  notification?: Maybe<NotificationCreateOneWithoutBookingInviteInput>;
}

export interface UserCreateoccupationsInput {
  set?: Maybe<Occupations[] | Occupations>;
}

export interface BookingInviteUpdateInput {
  startTime?: Maybe<DateTimeInput>;
  booking?: Maybe<BookingUpdateOneRequiredWithoutInvitesInput>;
  to?: Maybe<UserUpdateOneWithoutInvitesReceivedInput>;
  from?: Maybe<UserUpdateOneRequiredWithoutInvitesInput>;
  sent?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
  notification?: Maybe<NotificationUpdateOneWithoutBookingInviteInput>;
}

export interface UserCreateOneWithoutReviewsInput {
  create?: Maybe<UserCreateWithoutReviewsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BookingInviteUpdateManyMutationInput {
  startTime?: Maybe<DateTimeInput>;
  sent?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
}

export interface BookingInviteCreateManyWithoutFromInput {
  create?: Maybe<
    BookingInviteCreateWithoutFromInput[] | BookingInviteCreateWithoutFromInput
  >;
  connect?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
}

export interface DiscountUpdateInput {
  percentage?: Maybe<Int>;
  threshold?: Maybe<Int>;
  playerOrSession?: Maybe<PlayerOrSession>;
}

export interface UserCreateManyWithoutTimeSlotsInput {
  create?: Maybe<
    UserCreateWithoutTimeSlotsInput[] | UserCreateWithoutTimeSlotsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface DiscountUpdateManyMutationInput {
  percentage?: Maybe<Int>;
  threshold?: Maybe<Int>;
  playerOrSession?: Maybe<PlayerOrSession>;
}

export interface SessionReviewCreateManyWithoutUserInput {
  create?: Maybe<
    SessionReviewCreateWithoutUserInput[] | SessionReviewCreateWithoutUserInput
  >;
  connect?: Maybe<
    SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput
  >;
}

export interface FriendRequestCreateInput {
  to: UserCreateOneInput;
  from: UserCreateOneInput;
  notification: NotificationCreateOneWithoutFriendRequestInput;
}

export interface GamingTimeSlotCreateManyWithoutGamingSessionInput {
  create?: Maybe<
    | GamingTimeSlotCreateWithoutGamingSessionInput[]
    | GamingTimeSlotCreateWithoutGamingSessionInput
  >;
  connect?: Maybe<
    GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput
  >;
}

export interface NotificationCreateOneWithoutFriendRequestInput {
  create?: Maybe<NotificationCreateWithoutFriendRequestInput>;
  connect?: Maybe<NotificationWhereUniqueInput>;
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface NotificationCreateWithoutFriendRequestInput {
  type: NotificationType;
  text: String;
  for: UserCreateOneInput;
  bookingInvite?: Maybe<BookingInviteCreateOneWithoutNotificationInput>;
  booking?: Maybe<BookingCreateOneWithoutNotificationsInput>;
  friend?: Maybe<UserCreateOneInput>;
  viewed?: Maybe<Boolean>;
}

export interface NotificationCreateWithoutBookingInviteInput {
  type: NotificationType;
  text: String;
  for: UserCreateOneInput;
  friendRequest?: Maybe<FriendRequestCreateOneWithoutNotificationInput>;
  booking?: Maybe<BookingCreateOneWithoutNotificationsInput>;
  friend?: Maybe<UserCreateOneInput>;
  viewed?: Maybe<Boolean>;
}

export interface FriendRequestUpdateInput {
  to?: Maybe<UserUpdateOneRequiredInput>;
  from?: Maybe<UserUpdateOneRequiredInput>;
  notification?: Maybe<NotificationUpdateOneRequiredWithoutFriendRequestInput>;
}

export interface BookedPlayerCreateWithoutTimeslotInput {
  player: UserCreateOneInput;
  booking: BookingCreateOneWithoutPlayersInput;
}

export interface NotificationUpdateOneRequiredWithoutFriendRequestInput {
  create?: Maybe<NotificationCreateWithoutFriendRequestInput>;
  update?: Maybe<NotificationUpdateWithoutFriendRequestDataInput>;
  upsert?: Maybe<NotificationUpsertWithoutFriendRequestInput>;
  connect?: Maybe<NotificationWhereUniqueInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NotificationUpdateWithoutFriendRequestDataInput {
  type?: Maybe<NotificationType>;
  text?: Maybe<String>;
  for?: Maybe<UserUpdateOneRequiredInput>;
  bookingInvite?: Maybe<BookingInviteUpdateOneWithoutNotificationInput>;
  booking?: Maybe<BookingUpdateOneWithoutNotificationsInput>;
  friend?: Maybe<UserUpdateOneInput>;
  viewed?: Maybe<Boolean>;
}

export interface GamerTagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GamerTagWhereInput>;
  AND?: Maybe<
    GamerTagSubscriptionWhereInput[] | GamerTagSubscriptionWhereInput
  >;
  OR?: Maybe<GamerTagSubscriptionWhereInput[] | GamerTagSubscriptionWhereInput>;
  NOT?: Maybe<
    GamerTagSubscriptionWhereInput[] | GamerTagSubscriptionWhereInput
  >;
}

export interface NotificationUpsertWithoutFriendRequestInput {
  update: NotificationUpdateWithoutFriendRequestDataInput;
  create: NotificationCreateWithoutFriendRequestInput;
}

export type FriendRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GameCreateInput {
  name: String;
  tags?: Maybe<GameCreatetagsInput>;
  sessions?: Maybe<GamingSessionCreateManyWithoutGameInput>;
  launcher?: Maybe<Launcher>;
  numSessions?: Maybe<Int>;
  picture: String;
  banner: String;
}

export interface SessionReviewUpdateDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutReviewsInput>;
  session?: Maybe<GamingSessionUpdateOneRequiredWithoutReviewsInput>;
  text?: Maybe<String>;
  rating?: Maybe<Int>;
}

export interface GamingSessionCreateManyWithoutGameInput {
  create?: Maybe<
    GamingSessionCreateWithoutGameInput[] | GamingSessionCreateWithoutGameInput
  >;
  connect?: Maybe<
    GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput
  >;
}

export interface UserUpsertWithoutSavedCardsInput {
  update: UserUpdateWithoutSavedCardsDataInput;
  create: UserCreateWithoutSavedCardsInput;
}

export interface GamingSessionCreateWithoutGameInput {
  gamers?: Maybe<UserCreateManyWithoutSessionsInput>;
  creator: UserCreateOneInput;
  title: String;
  length: Int;
  price: Float;
  launcher?: Maybe<Launcher>;
  reviews?: Maybe<SessionReviewCreateManyWithoutSessionInput>;
  system: System;
  type: TypeOfGame;
  slots: Int;
  requirements?: Maybe<RequirementCreateManyInput>;
  discounts?: Maybe<DiscountCreateManyInput>;
  timeslots?: Maybe<GamingTimeSlotCreateManyWithoutGamingSessionInput>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface GamerTagUpdateWithoutPcDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutGamertagsInput>;
  psn?: Maybe<String>;
  xbl?: Maybe<String>;
  nso?: Maybe<String>;
}

export interface GameUpdateInput {
  name?: Maybe<String>;
  tags?: Maybe<GameUpdatetagsInput>;
  sessions?: Maybe<GamingSessionUpdateManyWithoutGameInput>;
  launcher?: Maybe<Launcher>;
  numSessions?: Maybe<Int>;
  picture?: Maybe<String>;
  banner?: Maybe<String>;
}

export interface GamingSessionIndexUpdateManyMutationInput {
  title?: Maybe<String>;
  gamer?: Maybe<String>;
  game?: Maybe<String>;
  launcher?: Maybe<Launcher>;
}

export interface GamingSessionUpdateManyWithoutGameInput {
  create?: Maybe<
    GamingSessionCreateWithoutGameInput[] | GamingSessionCreateWithoutGameInput
  >;
  delete?: Maybe<
    GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput
  >;
  connect?: Maybe<
    GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput
  >;
  set?: Maybe<GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput>;
  disconnect?: Maybe<
    GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput
  >;
  update?: Maybe<
    | GamingSessionUpdateWithWhereUniqueWithoutGameInput[]
    | GamingSessionUpdateWithWhereUniqueWithoutGameInput
  >;
  upsert?: Maybe<
    | GamingSessionUpsertWithWhereUniqueWithoutGameInput[]
    | GamingSessionUpsertWithWhereUniqueWithoutGameInput
  >;
  deleteMany?: Maybe<
    GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput
  >;
  updateMany?: Maybe<
    | GamingSessionUpdateManyWithWhereNestedInput[]
    | GamingSessionUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithoutGamertagsDataInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionUpdateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotUpdateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardUpdateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteUpdateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutUserInput>;
  friends?: Maybe<UserUpdateManyInput>;
  role?: Maybe<Role>;
  index?: Maybe<UserIndexUpdateOneRequiredWithoutUserInput>;
}

export interface GamingSessionUpdateWithWhereUniqueWithoutGameInput {
  where: GamingSessionWhereUniqueInput;
  data: GamingSessionUpdateWithoutGameDataInput;
}

export interface GameCreateWithoutSessionsInput {
  name: String;
  tags?: Maybe<GameCreatetagsInput>;
  launcher?: Maybe<Launcher>;
  numSessions?: Maybe<Int>;
  picture: String;
  banner: String;
}

export interface GamingSessionUpdateWithoutGameDataInput {
  gamers?: Maybe<UserUpdateManyWithoutSessionsInput>;
  creator?: Maybe<UserUpdateOneRequiredInput>;
  title?: Maybe<String>;
  length?: Maybe<Int>;
  price?: Maybe<Float>;
  launcher?: Maybe<Launcher>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutSessionInput>;
  system?: Maybe<System>;
  type?: Maybe<TypeOfGame>;
  slots?: Maybe<Int>;
  requirements?: Maybe<RequirementUpdateManyInput>;
  discounts?: Maybe<DiscountUpdateManyInput>;
  timeslots?: Maybe<GamingTimeSlotUpdateManyWithoutGamingSessionInput>;
  popularity?: Maybe<Int>;
  views?: Maybe<Int>;
  retired?: Maybe<Boolean>;
}

export interface BookedPlayerCreateManyWithoutBookingInput {
  create?: Maybe<
    | BookedPlayerCreateWithoutBookingInput[]
    | BookedPlayerCreateWithoutBookingInput
  >;
  connect?: Maybe<
    BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput
  >;
}

export interface GamingSessionUpsertWithWhereUniqueWithoutGameInput {
  where: GamingSessionWhereUniqueInput;
  update: GamingSessionUpdateWithoutGameDataInput;
  create: GamingSessionCreateWithoutGameInput;
}

export interface RequirementCreateManyInput {
  create?: Maybe<RequirementCreateInput[] | RequirementCreateInput>;
  connect?: Maybe<RequirementWhereUniqueInput[] | RequirementWhereUniqueInput>;
}

export interface GameUpdateManyMutationInput {
  name?: Maybe<String>;
  tags?: Maybe<GameUpdatetagsInput>;
  launcher?: Maybe<Launcher>;
  numSessions?: Maybe<Int>;
  picture?: Maybe<String>;
  banner?: Maybe<String>;
}

export interface PCLauncherCreateWithoutGamerTagInput {
  epic?: Maybe<String>;
  steam?: Maybe<String>;
  origin?: Maybe<String>;
  gog?: Maybe<String>;
  battlenet?: Maybe<String>;
  uplay?: Maybe<String>;
  bethesda?: Maybe<String>;
  itch?: Maybe<String>;
  windows?: Maybe<String>;
  riot?: Maybe<String>;
}

export interface GameIndexCreateInput {
  name: String;
  launcher?: Maybe<String>;
  tags?: Maybe<GameIndexCreatetagsInput>;
  game: GameCreateOneInput;
}

export interface NotificationCreateWithoutBookingInput {
  type: NotificationType;
  text: String;
  for: UserCreateOneInput;
  friendRequest?: Maybe<FriendRequestCreateOneWithoutNotificationInput>;
  bookingInvite?: Maybe<BookingInviteCreateOneWithoutNotificationInput>;
  friend?: Maybe<UserCreateOneInput>;
  viewed?: Maybe<Boolean>;
}

export interface GameIndexCreatetagsInput {
  set?: Maybe<String[] | String>;
}

export type BookingInviteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GameCreateOneInput {
  create?: Maybe<GameCreateInput>;
  connect?: Maybe<GameWhereUniqueInput>;
}

export interface SessionReviewIndexCreateInput {
  text: String;
  sessionReview: SessionReviewCreateOneInput;
}

export interface GameIndexUpdateInput {
  name?: Maybe<String>;
  launcher?: Maybe<String>;
  tags?: Maybe<GameIndexUpdatetagsInput>;
  game?: Maybe<GameUpdateOneRequiredInput>;
}

export interface NotificationUpdateManyMutationInput {
  type?: Maybe<NotificationType>;
  text?: Maybe<String>;
  viewed?: Maybe<Boolean>;
}

export interface GameIndexUpdatetagsInput {
  set?: Maybe<String[] | String>;
}

export interface BookingInviteCreateManyWithoutToInput {
  create?: Maybe<
    BookingInviteCreateWithoutToInput[] | BookingInviteCreateWithoutToInput
  >;
  connect?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
}

export interface GameUpdateOneRequiredInput {
  create?: Maybe<GameCreateInput>;
  update?: Maybe<GameUpdateDataInput>;
  upsert?: Maybe<GameUpsertNestedInput>;
  connect?: Maybe<GameWhereUniqueInput>;
}

export interface BookingCreateWithoutNotificationsInput {
  charge?: Maybe<String>;
  numSlots: Int;
  numPlayers: Int;
  players?: Maybe<BookedPlayerCreateManyWithoutBookingInput>;
  total: Float;
  bookee: UserCreateOneInput;
  timeslot: GamingTimeSlotCreateOneWithoutBookingsInput;
  invites?: Maybe<BookingInviteCreateManyWithoutBookingInput>;
  cancelled?: Maybe<Boolean>;
}

export interface GameUpdateDataInput {
  name?: Maybe<String>;
  tags?: Maybe<GameUpdatetagsInput>;
  sessions?: Maybe<GamingSessionUpdateManyWithoutGameInput>;
  launcher?: Maybe<Launcher>;
  numSessions?: Maybe<Int>;
  picture?: Maybe<String>;
  banner?: Maybe<String>;
}

export interface UserUpdateInput {
  gender?: Maybe<Gender>;
  email?: Maybe<String>;
  username?: Maybe<String>;
  displayName?: Maybe<String>;
  password?: Maybe<String>;
  profilePicture?: Maybe<String>;
  banner?: Maybe<String>;
  connectedStripeId?: Maybe<String>;
  customerStripeId?: Maybe<String>;
  gamerIsSetup?: Maybe<Boolean>;
  occupations?: Maybe<UserUpdateoccupationsInput>;
  name?: Maybe<String>;
  aboutMe?: Maybe<String>;
  sessions?: Maybe<GamingSessionUpdateManyWithoutGamersInput>;
  timeSlots?: Maybe<GamingTimeSlotUpdateManyWithoutGamersInput>;
  invites?: Maybe<BookingInviteUpdateManyWithoutFromInput>;
  savedCards?: Maybe<SavedCardUpdateManyWithoutUserInput>;
  invitesReceived?: Maybe<BookingInviteUpdateManyWithoutToInput>;
  setup?: Maybe<Int>;
  resetPasswordToken?: Maybe<String>;
  resetPasswordExpires?: Maybe<DateTimeInput>;
  views?: Maybe<Int>;
  reviews?: Maybe<SessionReviewUpdateManyWithoutUserInput>;
  friends?: Maybe<UserUpdateManyInput>;
  gamertags?: Maybe<GamerTagUpdateOneWithoutUserInput>;
  role?: Maybe<Role>;
  index?: Maybe<UserIndexUpdateOneRequiredWithoutUserInput>;
}

export interface GameUpsertNestedInput {
  update: GameUpdateDataInput;
  create: GameCreateInput;
}

export interface GamingSessionIndexCreateInput {
  title: String;
  gamer: String;
  game?: Maybe<String>;
  launcher?: Maybe<Launcher>;
  gamingSession: GamingSessionCreateOneInput;
}

export interface SocialMediaCreateOneInput {
  create?: Maybe<SocialMediaCreateInput>;
  connect?: Maybe<SocialMediaWhereUniqueInput>;
}

export interface GamerRequestCreateoccupationsInput {
  set?: Maybe<Occupations[] | Occupations>;
}

export interface GamerRequestCreateInput {
  user: UserCreateOneInput;
  occupations?: Maybe<GamerRequestCreateoccupationsInput>;
  addToOccupations?: Maybe<String>;
  socialMedia: SocialMediaCreateOneInput;
}

export interface GameIndexUpdateManyMutationInput {
  name?: Maybe<String>;
  launcher?: Maybe<String>;
  tags?: Maybe<GameIndexUpdatetagsInput>;
}

export interface GamingSessionCreateOneWithoutTimeslotsInput {
  create?: Maybe<GamingSessionCreateWithoutTimeslotsInput>;
  connect?: Maybe<GamingSessionWhereUniqueInput>;
}

export interface UserCreateOneWithoutSavedCardsInput {
  create?: Maybe<UserCreateWithoutSavedCardsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SavedCardSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SavedCardWhereInput>;
  AND?: Maybe<
    SavedCardSubscriptionWhereInput[] | SavedCardSubscriptionWhereInput
  >;
  OR?: Maybe<
    SavedCardSubscriptionWhereInput[] | SavedCardSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SavedCardSubscriptionWhereInput[] | SavedCardSubscriptionWhereInput
  >;
}

export interface BookingInviteCreateManyWithoutBookingInput {
  create?: Maybe<
    | BookingInviteCreateWithoutBookingInput[]
    | BookingInviteCreateWithoutBookingInput
  >;
  connect?: Maybe<
    BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserIndexPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  username: String;
  displayName?: String;
  name: String;
}

export interface UserIndexPreviousValuesPromise
  extends Promise<UserIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  displayName: () => Promise<String>;
  name: () => Promise<String>;
}

export interface UserIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<UserIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface DiscountEdge {
  node: Discount;
  cursor: String;
}

export interface DiscountEdgePromise
  extends Promise<DiscountEdge>,
    Fragmentable {
  node: <T = DiscountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiscountEdgeSubscription
  extends Promise<AsyncIterator<DiscountEdge>>,
    Fragmentable {
  node: <T = DiscountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SessionReview {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  text: String;
  rating: Int;
}

export interface SessionReviewPromise
  extends Promise<SessionReview>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  session: <T = GamingSessionPromise>() => T;
  text: () => Promise<String>;
  rating: () => Promise<Int>;
}

export interface SessionReviewSubscription
  extends Promise<AsyncIterator<SessionReview>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  session: <T = GamingSessionSubscription>() => T;
  text: () => Promise<AsyncIterator<String>>;
  rating: () => Promise<AsyncIterator<Int>>;
}

export interface SessionReviewNullablePromise
  extends Promise<SessionReview | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  session: <T = GamingSessionPromise>() => T;
  text: () => Promise<String>;
  rating: () => Promise<Int>;
}

export interface DiscountConnection {
  pageInfo: PageInfo;
  edges: DiscountEdge[];
}

export interface DiscountConnectionPromise
  extends Promise<DiscountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiscountEdge>>() => T;
  aggregate: <T = AggregateDiscountPromise>() => T;
}

export interface DiscountConnectionSubscription
  extends Promise<AsyncIterator<DiscountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiscountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiscountSubscription>() => T;
}

export interface Game {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  tags: Tags[];
  launcher?: Launcher;
  numSessions: Int;
  picture: String;
  banner: String;
}

export interface GamePromise extends Promise<Game>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  tags: () => Promise<Tags[]>;
  sessions: <T = FragmentableArray<GamingSession>>(args?: {
    where?: GamingSessionWhereInput;
    orderBy?: GamingSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  launcher: () => Promise<Launcher>;
  numSessions: () => Promise<Int>;
  picture: () => Promise<String>;
  banner: () => Promise<String>;
}

export interface GameSubscription
  extends Promise<AsyncIterator<Game>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<Tags[]>>;
  sessions: <T = Promise<AsyncIterator<GamingSessionSubscription>>>(args?: {
    where?: GamingSessionWhereInput;
    orderBy?: GamingSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  launcher: () => Promise<AsyncIterator<Launcher>>;
  numSessions: () => Promise<AsyncIterator<Int>>;
  picture: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
}

export interface GameNullablePromise
  extends Promise<Game | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  tags: () => Promise<Tags[]>;
  sessions: <T = FragmentableArray<GamingSession>>(args?: {
    where?: GamingSessionWhereInput;
    orderBy?: GamingSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  launcher: () => Promise<Launcher>;
  numSessions: () => Promise<Int>;
  picture: () => Promise<String>;
  banner: () => Promise<String>;
}

export interface AggregateDiscount {
  count: Int;
}

export interface AggregateDiscountPromise
  extends Promise<AggregateDiscount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiscountSubscription
  extends Promise<AsyncIterator<AggregateDiscount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SocialMediaPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface SocialMediaPreviousValuesPromise
  extends Promise<SocialMediaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  twitter: () => Promise<String>;
  facebook: () => Promise<String>;
  youtube: () => Promise<String>;
  instagram: () => Promise<String>;
  twitch: () => Promise<String>;
  snapchat: () => Promise<String>;
}

export interface SocialMediaPreviousValuesSubscription
  extends Promise<AsyncIterator<SocialMediaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  twitter: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  youtube: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
  twitch: () => Promise<AsyncIterator<String>>;
  snapchat: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateBookingInvite {
  count: Int;
}

export interface AggregateBookingInvitePromise
  extends Promise<AggregateBookingInvite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingInviteSubscription
  extends Promise<AsyncIterator<AggregateBookingInvite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamingSession {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  length: Int;
  price: Float;
  launcher?: Launcher;
  system: System;
  type: TypeOfGame;
  slots: Int;
  popularity?: Int;
  views?: Int;
  retired: Boolean;
}

export interface GamingSessionPromise
  extends Promise<GamingSession>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  gamers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  creator: <T = UserPromise>() => T;
  game: <T = GamePromise>() => T;
  title: () => Promise<String>;
  length: () => Promise<Int>;
  price: () => Promise<Float>;
  launcher: () => Promise<Launcher>;
  reviews: <T = FragmentableArray<SessionReview>>(args?: {
    where?: SessionReviewWhereInput;
    orderBy?: SessionReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  system: () => Promise<System>;
  type: () => Promise<TypeOfGame>;
  slots: () => Promise<Int>;
  requirements: <T = FragmentableArray<Requirement>>(args?: {
    where?: RequirementWhereInput;
    orderBy?: RequirementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  discounts: <T = FragmentableArray<Discount>>(args?: {
    where?: DiscountWhereInput;
    orderBy?: DiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  timeslots: <T = FragmentableArray<GamingTimeSlot>>(args?: {
    where?: GamingTimeSlotWhereInput;
    orderBy?: GamingTimeSlotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  popularity: () => Promise<Int>;
  views: () => Promise<Int>;
  retired: () => Promise<Boolean>;
}

export interface GamingSessionSubscription
  extends Promise<AsyncIterator<GamingSession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  gamers: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  creator: <T = UserSubscription>() => T;
  game: <T = GameSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  length: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  launcher: () => Promise<AsyncIterator<Launcher>>;
  reviews: <T = Promise<AsyncIterator<SessionReviewSubscription>>>(args?: {
    where?: SessionReviewWhereInput;
    orderBy?: SessionReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  system: () => Promise<AsyncIterator<System>>;
  type: () => Promise<AsyncIterator<TypeOfGame>>;
  slots: () => Promise<AsyncIterator<Int>>;
  requirements: <T = Promise<AsyncIterator<RequirementSubscription>>>(args?: {
    where?: RequirementWhereInput;
    orderBy?: RequirementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  discounts: <T = Promise<AsyncIterator<DiscountSubscription>>>(args?: {
    where?: DiscountWhereInput;
    orderBy?: DiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  timeslots: <T = Promise<AsyncIterator<GamingTimeSlotSubscription>>>(args?: {
    where?: GamingTimeSlotWhereInput;
    orderBy?: GamingTimeSlotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  popularity: () => Promise<AsyncIterator<Int>>;
  views: () => Promise<AsyncIterator<Int>>;
  retired: () => Promise<AsyncIterator<Boolean>>;
}

export interface GamingSessionNullablePromise
  extends Promise<GamingSession | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  gamers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  creator: <T = UserPromise>() => T;
  game: <T = GamePromise>() => T;
  title: () => Promise<String>;
  length: () => Promise<Int>;
  price: () => Promise<Float>;
  launcher: () => Promise<Launcher>;
  reviews: <T = FragmentableArray<SessionReview>>(args?: {
    where?: SessionReviewWhereInput;
    orderBy?: SessionReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  system: () => Promise<System>;
  type: () => Promise<TypeOfGame>;
  slots: () => Promise<Int>;
  requirements: <T = FragmentableArray<Requirement>>(args?: {
    where?: RequirementWhereInput;
    orderBy?: RequirementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  discounts: <T = FragmentableArray<Discount>>(args?: {
    where?: DiscountWhereInput;
    orderBy?: DiscountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  timeslots: <T = FragmentableArray<GamingTimeSlot>>(args?: {
    where?: GamingTimeSlotWhereInput;
    orderBy?: GamingTimeSlotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  popularity: () => Promise<Int>;
  views: () => Promise<Int>;
  retired: () => Promise<Boolean>;
}

export interface UserIndexConnection {
  pageInfo: PageInfo;
  edges: UserIndexEdge[];
}

export interface UserIndexConnectionPromise
  extends Promise<UserIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserIndexEdge>>() => T;
  aggregate: <T = AggregateUserIndexPromise>() => T;
}

export interface UserIndexConnectionSubscription
  extends Promise<AsyncIterator<UserIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserIndexEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserIndexSubscription>() => T;
}

export interface AggregateUserIndex {
  count: Int;
}

export interface AggregateUserIndexPromise
  extends Promise<AggregateUserIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserIndexSubscription
  extends Promise<AsyncIterator<AggregateUserIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingInviteEdge {
  node: BookingInvite;
  cursor: String;
}

export interface BookingInviteEdgePromise
  extends Promise<BookingInviteEdge>,
    Fragmentable {
  node: <T = BookingInvitePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookingInviteEdgeSubscription
  extends Promise<AsyncIterator<BookingInviteEdge>>,
    Fragmentable {
  node: <T = BookingInviteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface BookedPlayer {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookedPlayerPromise
  extends Promise<BookedPlayer>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  player: <T = UserPromise>() => T;
  booking: <T = BookingPromise>() => T;
  timeslot: <T = GamingTimeSlotPromise>() => T;
}

export interface BookedPlayerSubscription
  extends Promise<AsyncIterator<BookedPlayer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  player: <T = UserSubscription>() => T;
  booking: <T = BookingSubscription>() => T;
  timeslot: <T = GamingTimeSlotSubscription>() => T;
}

export interface BookedPlayerNullablePromise
  extends Promise<BookedPlayer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  player: <T = UserPromise>() => T;
  booking: <T = BookingPromise>() => T;
  timeslot: <T = GamingTimeSlotPromise>() => T;
}

export interface SocialMediaEdge {
  node: SocialMedia;
  cursor: String;
}

export interface SocialMediaEdgePromise
  extends Promise<SocialMediaEdge>,
    Fragmentable {
  node: <T = SocialMediaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SocialMediaEdgeSubscription
  extends Promise<AsyncIterator<SocialMediaEdge>>,
    Fragmentable {
  node: <T = SocialMediaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookedPlayerSubscriptionPayload {
  mutation: MutationType;
  node: BookedPlayer;
  updatedFields: String[];
  previousValues: BookedPlayerPreviousValues;
}

export interface BookedPlayerSubscriptionPayloadPromise
  extends Promise<BookedPlayerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookedPlayerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookedPlayerPreviousValuesPromise>() => T;
}

export interface BookedPlayerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookedPlayerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookedPlayerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookedPlayerPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  gender: Gender;
  email: String;
  username: String;
  displayName: String;
  password: String;
  profilePicture?: String;
  banner?: String;
  connectedStripeId?: String;
  customerStripeId?: String;
  gamerIsSetup: Boolean;
  occupations: Occupations[];
  name: String;
  aboutMe?: String;
  setup?: Int;
  resetPasswordToken?: String;
  resetPasswordExpires?: DateTimeOutput;
  views?: Int;
  role: Role;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  gender: () => Promise<Gender>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  displayName: () => Promise<String>;
  password: () => Promise<String>;
  profilePicture: () => Promise<String>;
  banner: () => Promise<String>;
  connectedStripeId: () => Promise<String>;
  customerStripeId: () => Promise<String>;
  gamerIsSetup: () => Promise<Boolean>;
  occupations: () => Promise<Occupations[]>;
  name: () => Promise<String>;
  aboutMe: () => Promise<String>;
  sessions: <T = FragmentableArray<GamingSession>>(args?: {
    where?: GamingSessionWhereInput;
    orderBy?: GamingSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  timeSlots: <T = FragmentableArray<GamingTimeSlot>>(args?: {
    where?: GamingTimeSlotWhereInput;
    orderBy?: GamingTimeSlotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invites: <T = FragmentableArray<BookingInvite>>(args?: {
    where?: BookingInviteWhereInput;
    orderBy?: BookingInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedCards: <T = FragmentableArray<SavedCard>>(args?: {
    where?: SavedCardWhereInput;
    orderBy?: SavedCardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitesReceived: <T = FragmentableArray<BookingInvite>>(args?: {
    where?: BookingInviteWhereInput;
    orderBy?: BookingInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  setup: () => Promise<Int>;
  resetPasswordToken: () => Promise<String>;
  resetPasswordExpires: () => Promise<DateTimeOutput>;
  views: () => Promise<Int>;
  reviews: <T = FragmentableArray<SessionReview>>(args?: {
    where?: SessionReviewWhereInput;
    orderBy?: SessionReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  friends: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gamertags: <T = GamerTagPromise>() => T;
  role: () => Promise<Role>;
  index: <T = UserIndexPromise>() => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  profilePicture: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
  connectedStripeId: () => Promise<AsyncIterator<String>>;
  customerStripeId: () => Promise<AsyncIterator<String>>;
  gamerIsSetup: () => Promise<AsyncIterator<Boolean>>;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  name: () => Promise<AsyncIterator<String>>;
  aboutMe: () => Promise<AsyncIterator<String>>;
  sessions: <T = Promise<AsyncIterator<GamingSessionSubscription>>>(args?: {
    where?: GamingSessionWhereInput;
    orderBy?: GamingSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  timeSlots: <T = Promise<AsyncIterator<GamingTimeSlotSubscription>>>(args?: {
    where?: GamingTimeSlotWhereInput;
    orderBy?: GamingTimeSlotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invites: <T = Promise<AsyncIterator<BookingInviteSubscription>>>(args?: {
    where?: BookingInviteWhereInput;
    orderBy?: BookingInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedCards: <T = Promise<AsyncIterator<SavedCardSubscription>>>(args?: {
    where?: SavedCardWhereInput;
    orderBy?: SavedCardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitesReceived: <
    T = Promise<AsyncIterator<BookingInviteSubscription>>
  >(args?: {
    where?: BookingInviteWhereInput;
    orderBy?: BookingInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  setup: () => Promise<AsyncIterator<Int>>;
  resetPasswordToken: () => Promise<AsyncIterator<String>>;
  resetPasswordExpires: () => Promise<AsyncIterator<DateTimeOutput>>;
  views: () => Promise<AsyncIterator<Int>>;
  reviews: <T = Promise<AsyncIterator<SessionReviewSubscription>>>(args?: {
    where?: SessionReviewWhereInput;
    orderBy?: SessionReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  friends: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gamertags: <T = GamerTagSubscription>() => T;
  role: () => Promise<AsyncIterator<Role>>;
  index: <T = UserIndexSubscription>() => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  gender: () => Promise<Gender>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  displayName: () => Promise<String>;
  password: () => Promise<String>;
  profilePicture: () => Promise<String>;
  banner: () => Promise<String>;
  connectedStripeId: () => Promise<String>;
  customerStripeId: () => Promise<String>;
  gamerIsSetup: () => Promise<Boolean>;
  occupations: () => Promise<Occupations[]>;
  name: () => Promise<String>;
  aboutMe: () => Promise<String>;
  sessions: <T = FragmentableArray<GamingSession>>(args?: {
    where?: GamingSessionWhereInput;
    orderBy?: GamingSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  timeSlots: <T = FragmentableArray<GamingTimeSlot>>(args?: {
    where?: GamingTimeSlotWhereInput;
    orderBy?: GamingTimeSlotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invites: <T = FragmentableArray<BookingInvite>>(args?: {
    where?: BookingInviteWhereInput;
    orderBy?: BookingInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedCards: <T = FragmentableArray<SavedCard>>(args?: {
    where?: SavedCardWhereInput;
    orderBy?: SavedCardOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitesReceived: <T = FragmentableArray<BookingInvite>>(args?: {
    where?: BookingInviteWhereInput;
    orderBy?: BookingInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  setup: () => Promise<Int>;
  resetPasswordToken: () => Promise<String>;
  resetPasswordExpires: () => Promise<DateTimeOutput>;
  views: () => Promise<Int>;
  reviews: <T = FragmentableArray<SessionReview>>(args?: {
    where?: SessionReviewWhereInput;
    orderBy?: SessionReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  friends: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  gamertags: <T = GamerTagPromise>() => T;
  role: () => Promise<Role>;
  index: <T = UserIndexPromise>() => T;
}

export interface BookedPlayerPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookedPlayerPreviousValuesPromise
  extends Promise<BookedPlayerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookedPlayerPreviousValuesSubscription
  extends Promise<AsyncIterator<BookedPlayerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SessionReviewIndexEdge {
  node: SessionReviewIndex;
  cursor: String;
}

export interface SessionReviewIndexEdgePromise
  extends Promise<SessionReviewIndexEdge>,
    Fragmentable {
  node: <T = SessionReviewIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionReviewIndexEdgeSubscription
  extends Promise<AsyncIterator<SessionReviewIndexEdge>>,
    Fragmentable {
  node: <T = SessionReviewIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookingInviteConnection {
  pageInfo: PageInfo;
  edges: BookingInviteEdge[];
}

export interface BookingInviteConnectionPromise
  extends Promise<BookingInviteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookingInviteEdge>>() => T;
  aggregate: <T = AggregateBookingInvitePromise>() => T;
}

export interface BookingInviteConnectionSubscription
  extends Promise<AsyncIterator<BookingInviteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingInviteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingInviteSubscription>() => T;
}

export interface Requirement {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  msg: String;
}

export interface RequirementPromise extends Promise<Requirement>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  msg: () => Promise<String>;
}

export interface RequirementSubscription
  extends Promise<AsyncIterator<Requirement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  msg: () => Promise<AsyncIterator<String>>;
}

export interface RequirementNullablePromise
  extends Promise<Requirement | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  msg: () => Promise<String>;
}

export interface BookingSubscriptionPayload {
  mutation: MutationType;
  node: Booking;
  updatedFields: String[];
  previousValues: BookingPreviousValues;
}

export interface BookingSubscriptionPayloadPromise
  extends Promise<BookingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingPreviousValuesPromise>() => T;
}

export interface BookingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingPreviousValuesSubscription>() => T;
}

export interface AggregateSessionReview {
  count: Int;
}

export interface AggregateSessionReviewPromise
  extends Promise<AggregateSessionReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionReviewSubscription
  extends Promise<AsyncIterator<AggregateSessionReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  charge?: String;
  numSlots: Int;
  numPlayers: Int;
  total: Float;
  cancelled?: Boolean;
}

export interface BookingPreviousValuesPromise
  extends Promise<BookingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  charge: () => Promise<String>;
  numSlots: () => Promise<Int>;
  numPlayers: () => Promise<Int>;
  total: () => Promise<Float>;
  cancelled: () => Promise<Boolean>;
}

export interface BookingPreviousValuesSubscription
  extends Promise<AsyncIterator<BookingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  charge: () => Promise<AsyncIterator<String>>;
  numSlots: () => Promise<AsyncIterator<Int>>;
  numPlayers: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Float>>;
  cancelled: () => Promise<AsyncIterator<Boolean>>;
}

export interface SessionReviewConnection {
  pageInfo: PageInfo;
  edges: SessionReviewEdge[];
}

export interface SessionReviewConnectionPromise
  extends Promise<SessionReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionReviewEdge>>() => T;
  aggregate: <T = AggregateSessionReviewPromise>() => T;
}

export interface SessionReviewConnectionSubscription
  extends Promise<AsyncIterator<SessionReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionReviewSubscription>() => T;
}

export interface AggregateBooking {
  count: Int;
}

export interface AggregateBookingPromise
  extends Promise<AggregateBooking>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingSubscription
  extends Promise<AsyncIterator<AggregateBooking>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SavedCardEdge {
  node: SavedCard;
  cursor: String;
}

export interface SavedCardEdgePromise
  extends Promise<SavedCardEdge>,
    Fragmentable {
  node: <T = SavedCardPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SavedCardEdgeSubscription
  extends Promise<AsyncIterator<SavedCardEdge>>,
    Fragmentable {
  node: <T = SavedCardSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookingInviteSubscriptionPayload {
  mutation: MutationType;
  node: BookingInvite;
  updatedFields: String[];
  previousValues: BookingInvitePreviousValues;
}

export interface BookingInviteSubscriptionPayloadPromise
  extends Promise<BookingInviteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookingInvitePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingInvitePreviousValuesPromise>() => T;
}

export interface BookingInviteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingInviteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingInviteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingInvitePreviousValuesSubscription>() => T;
}

export interface AggregateRequirement {
  count: Int;
}

export interface AggregateRequirementPromise
  extends Promise<AggregateRequirement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRequirementSubscription
  extends Promise<AsyncIterator<AggregateRequirement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingInvitePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  startTime: DateTimeOutput;
  sent: Boolean;
  accepted?: Boolean;
}

export interface BookingInvitePreviousValuesPromise
  extends Promise<BookingInvitePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  sent: () => Promise<Boolean>;
  accepted: () => Promise<Boolean>;
}

export interface BookingInvitePreviousValuesSubscription
  extends Promise<AsyncIterator<BookingInvitePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  sent: () => Promise<AsyncIterator<Boolean>>;
  accepted: () => Promise<AsyncIterator<Boolean>>;
}

export interface RequirementConnection {
  pageInfo: PageInfo;
  edges: RequirementEdge[];
}

export interface RequirementConnectionPromise
  extends Promise<RequirementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RequirementEdge>>() => T;
  aggregate: <T = AggregateRequirementPromise>() => T;
}

export interface RequirementConnectionSubscription
  extends Promise<AsyncIterator<RequirementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RequirementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRequirementSubscription>() => T;
}

export interface BookingEdge {
  node: Booking;
  cursor: String;
}

export interface BookingEdgePromise extends Promise<BookingEdge>, Fragmentable {
  node: <T = BookingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookingEdgeSubscription
  extends Promise<AsyncIterator<BookingEdge>>,
    Fragmentable {
  node: <T = BookingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PCLauncherEdge {
  node: PCLauncher;
  cursor: String;
}

export interface PCLauncherEdgePromise
  extends Promise<PCLauncherEdge>,
    Fragmentable {
  node: <T = PCLauncherPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PCLauncherEdgeSubscription
  extends Promise<AsyncIterator<PCLauncherEdge>>,
    Fragmentable {
  node: <T = PCLauncherSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DiscountSubscriptionPayload {
  mutation: MutationType;
  node: Discount;
  updatedFields: String[];
  previousValues: DiscountPreviousValues;
}

export interface DiscountSubscriptionPayloadPromise
  extends Promise<DiscountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiscountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiscountPreviousValuesPromise>() => T;
}

export interface DiscountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiscountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiscountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiscountPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  gender: Gender;
  email: String;
  username: String;
  displayName: String;
  password: String;
  profilePicture?: String;
  banner?: String;
  connectedStripeId?: String;
  customerStripeId?: String;
  gamerIsSetup: Boolean;
  occupations: Occupations[];
  name: String;
  aboutMe?: String;
  setup?: Int;
  resetPasswordToken?: String;
  resetPasswordExpires?: DateTimeOutput;
  views?: Int;
  role: Role;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  gender: () => Promise<Gender>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  displayName: () => Promise<String>;
  password: () => Promise<String>;
  profilePicture: () => Promise<String>;
  banner: () => Promise<String>;
  connectedStripeId: () => Promise<String>;
  customerStripeId: () => Promise<String>;
  gamerIsSetup: () => Promise<Boolean>;
  occupations: () => Promise<Occupations[]>;
  name: () => Promise<String>;
  aboutMe: () => Promise<String>;
  setup: () => Promise<Int>;
  resetPasswordToken: () => Promise<String>;
  resetPasswordExpires: () => Promise<DateTimeOutput>;
  views: () => Promise<Int>;
  role: () => Promise<Role>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  profilePicture: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
  connectedStripeId: () => Promise<AsyncIterator<String>>;
  customerStripeId: () => Promise<AsyncIterator<String>>;
  gamerIsSetup: () => Promise<AsyncIterator<Boolean>>;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  name: () => Promise<AsyncIterator<String>>;
  aboutMe: () => Promise<AsyncIterator<String>>;
  setup: () => Promise<AsyncIterator<Int>>;
  resetPasswordToken: () => Promise<AsyncIterator<String>>;
  resetPasswordExpires: () => Promise<AsyncIterator<DateTimeOutput>>;
  views: () => Promise<AsyncIterator<Int>>;
  role: () => Promise<AsyncIterator<Role>>;
}

export interface DiscountPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  percentage: Int;
  threshold: Int;
  playerOrSession: PlayerOrSession;
}

export interface DiscountPreviousValuesPromise
  extends Promise<DiscountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  percentage: () => Promise<Int>;
  threshold: () => Promise<Int>;
  playerOrSession: () => Promise<PlayerOrSession>;
}

export interface DiscountPreviousValuesSubscription
  extends Promise<AsyncIterator<DiscountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  percentage: () => Promise<AsyncIterator<Int>>;
  threshold: () => Promise<AsyncIterator<Int>>;
  playerOrSession: () => Promise<AsyncIterator<PlayerOrSession>>;
}

export interface NotificationEdge {
  node: Notification;
  cursor: String;
}

export interface NotificationEdgePromise
  extends Promise<NotificationEdge>,
    Fragmentable {
  node: <T = NotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdge>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookingConnection {
  pageInfo: PageInfo;
  edges: BookingEdge[];
}

export interface BookingConnectionPromise
  extends Promise<BookingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookingEdge>>() => T;
  aggregate: <T = AggregateBookingPromise>() => T;
}

export interface BookingConnectionSubscription
  extends Promise<AsyncIterator<BookingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingSubscription>() => T;
}

export interface AggregateGamingTimeSlot {
  count: Int;
}

export interface AggregateGamingTimeSlotPromise
  extends Promise<AggregateGamingTimeSlot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamingTimeSlotSubscription
  extends Promise<AsyncIterator<AggregateGamingTimeSlot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FriendRequestSubscriptionPayload {
  mutation: MutationType;
  node: FriendRequest;
  updatedFields: String[];
  previousValues: FriendRequestPreviousValues;
}

export interface FriendRequestSubscriptionPayloadPromise
  extends Promise<FriendRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FriendRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FriendRequestPreviousValuesPromise>() => T;
}

export interface FriendRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FriendRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FriendRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FriendRequestPreviousValuesSubscription>() => T;
}

export interface GamingTimeSlotConnection {
  pageInfo: PageInfo;
  edges: GamingTimeSlotEdge[];
}

export interface GamingTimeSlotConnectionPromise
  extends Promise<GamingTimeSlotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamingTimeSlotEdge>>() => T;
  aggregate: <T = AggregateGamingTimeSlotPromise>() => T;
}

export interface GamingTimeSlotConnectionSubscription
  extends Promise<AsyncIterator<GamingTimeSlotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GamingTimeSlotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGamingTimeSlotSubscription>() => T;
}

export interface FriendRequestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FriendRequestPreviousValuesPromise
  extends Promise<FriendRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FriendRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<FriendRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GamingSessionIndexEdge {
  node: GamingSessionIndex;
  cursor: String;
}

export interface GamingSessionIndexEdgePromise
  extends Promise<GamingSessionIndexEdge>,
    Fragmentable {
  node: <T = GamingSessionIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamingSessionIndexEdgeSubscription
  extends Promise<AsyncIterator<GamingSessionIndexEdge>>,
    Fragmentable {
  node: <T = GamingSessionIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBookedPlayer {
  count: Int;
}

export interface AggregateBookedPlayerPromise
  extends Promise<AggregateBookedPlayer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookedPlayerSubscription
  extends Promise<AsyncIterator<AggregateBookedPlayer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamingSessionIndex {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  gamer: String;
  game?: String;
  launcher?: Launcher;
}

export interface GamingSessionIndexPromise
  extends Promise<GamingSessionIndex>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  gamer: () => Promise<String>;
  game: () => Promise<String>;
  launcher: () => Promise<Launcher>;
  gamingSession: <T = GamingSessionPromise>() => T;
}

export interface GamingSessionIndexSubscription
  extends Promise<AsyncIterator<GamingSessionIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  gamer: () => Promise<AsyncIterator<String>>;
  game: () => Promise<AsyncIterator<String>>;
  launcher: () => Promise<AsyncIterator<Launcher>>;
  gamingSession: <T = GamingSessionSubscription>() => T;
}

export interface GamingSessionIndexNullablePromise
  extends Promise<GamingSessionIndex | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  gamer: () => Promise<String>;
  game: () => Promise<String>;
  launcher: () => Promise<Launcher>;
  gamingSession: <T = GamingSessionPromise>() => T;
}

export interface GameSubscriptionPayload {
  mutation: MutationType;
  node: Game;
  updatedFields: String[];
  previousValues: GamePreviousValues;
}

export interface GameSubscriptionPayloadPromise
  extends Promise<GameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamePreviousValuesPromise>() => T;
}

export interface GameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamePreviousValuesSubscription>() => T;
}

export interface GamingSessionEdge {
  node: GamingSession;
  cursor: String;
}

export interface GamingSessionEdgePromise
  extends Promise<GamingSessionEdge>,
    Fragmentable {
  node: <T = GamingSessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamingSessionEdgeSubscription
  extends Promise<AsyncIterator<GamingSessionEdge>>,
    Fragmentable {
  node: <T = GamingSessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  tags: Tags[];
  launcher?: Launcher;
  numSessions: Int;
  picture: String;
  banner: String;
}

export interface GamePreviousValuesPromise
  extends Promise<GamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  tags: () => Promise<Tags[]>;
  launcher: () => Promise<Launcher>;
  numSessions: () => Promise<Int>;
  picture: () => Promise<String>;
  banner: () => Promise<String>;
}

export interface GamePreviousValuesSubscription
  extends Promise<AsyncIterator<GamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<Tags[]>>;
  launcher: () => Promise<AsyncIterator<Launcher>>;
  numSessions: () => Promise<AsyncIterator<Int>>;
  picture: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGamerTag {
  count: Int;
}

export interface AggregateGamerTagPromise
  extends Promise<AggregateGamerTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamerTagSubscription
  extends Promise<AsyncIterator<AggregateGamerTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookedPlayerEdge {
  node: BookedPlayer;
  cursor: String;
}

export interface BookedPlayerEdgePromise
  extends Promise<BookedPlayerEdge>,
    Fragmentable {
  node: <T = BookedPlayerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookedPlayerEdgeSubscription
  extends Promise<AsyncIterator<BookedPlayerEdge>>,
    Fragmentable {
  node: <T = BookedPlayerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamerTagConnection {
  pageInfo: PageInfo;
  edges: GamerTagEdge[];
}

export interface GamerTagConnectionPromise
  extends Promise<GamerTagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamerTagEdge>>() => T;
  aggregate: <T = AggregateGamerTagPromise>() => T;
}

export interface GamerTagConnectionSubscription
  extends Promise<AsyncIterator<GamerTagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GamerTagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGamerTagSubscription>() => T;
}

export interface GameIndexSubscriptionPayload {
  mutation: MutationType;
  node: GameIndex;
  updatedFields: String[];
  previousValues: GameIndexPreviousValues;
}

export interface GameIndexSubscriptionPayloadPromise
  extends Promise<GameIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GameIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GameIndexPreviousValuesPromise>() => T;
}

export interface GameIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GameIndexPreviousValuesSubscription>() => T;
}

export interface GamerRequestEdge {
  node: GamerRequest;
  cursor: String;
}

export interface GamerRequestEdgePromise
  extends Promise<GamerRequestEdge>,
    Fragmentable {
  node: <T = GamerRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamerRequestEdgeSubscription
  extends Promise<AsyncIterator<GamerRequestEdge>>,
    Fragmentable {
  node: <T = GamerRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GameIndexPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  launcher?: String;
  tags: String[];
}

export interface GameIndexPreviousValuesPromise
  extends Promise<GameIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  launcher: () => Promise<String>;
  tags: () => Promise<String[]>;
}

export interface GameIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<GameIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  launcher: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
}

export interface SocialMedia {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface SocialMediaPromise extends Promise<SocialMedia>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  twitter: () => Promise<String>;
  facebook: () => Promise<String>;
  youtube: () => Promise<String>;
  instagram: () => Promise<String>;
  twitch: () => Promise<String>;
  snapchat: () => Promise<String>;
}

export interface SocialMediaSubscription
  extends Promise<AsyncIterator<SocialMedia>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  twitter: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  youtube: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
  twitch: () => Promise<AsyncIterator<String>>;
  snapchat: () => Promise<AsyncIterator<String>>;
}

export interface SocialMediaNullablePromise
  extends Promise<SocialMedia | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  twitter: () => Promise<String>;
  facebook: () => Promise<String>;
  youtube: () => Promise<String>;
  instagram: () => Promise<String>;
  twitch: () => Promise<String>;
  snapchat: () => Promise<String>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGameIndex {
  count: Int;
}

export interface AggregateGameIndexPromise
  extends Promise<AggregateGameIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameIndexSubscription
  extends Promise<AsyncIterator<AggregateGameIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamerRequestSubscriptionPayload {
  mutation: MutationType;
  node: GamerRequest;
  updatedFields: String[];
  previousValues: GamerRequestPreviousValues;
}

export interface GamerRequestSubscriptionPayloadPromise
  extends Promise<GamerRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamerRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamerRequestPreviousValuesPromise>() => T;
}

export interface GamerRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamerRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamerRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamerRequestPreviousValuesSubscription>() => T;
}

export interface GameIndexConnection {
  pageInfo: PageInfo;
  edges: GameIndexEdge[];
}

export interface GameIndexConnectionPromise
  extends Promise<GameIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameIndexEdge>>() => T;
  aggregate: <T = AggregateGameIndexPromise>() => T;
}

export interface GameIndexConnectionSubscription
  extends Promise<AsyncIterator<GameIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameIndexEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameIndexSubscription>() => T;
}

export interface GamerRequestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  occupations: Occupations[];
  addToOccupations?: String;
}

export interface GamerRequestPreviousValuesPromise
  extends Promise<GamerRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  occupations: () => Promise<Occupations[]>;
  addToOccupations: () => Promise<String>;
}

export interface GamerRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<GamerRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  addToOccupations: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGame {
  count: Int;
}

export interface AggregateGamePromise
  extends Promise<AggregateGame>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameSubscription
  extends Promise<AsyncIterator<AggregateGame>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookedPlayerConnection {
  pageInfo: PageInfo;
  edges: BookedPlayerEdge[];
}

export interface BookedPlayerConnectionPromise
  extends Promise<BookedPlayerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookedPlayerEdge>>() => T;
  aggregate: <T = AggregateBookedPlayerPromise>() => T;
}

export interface BookedPlayerConnectionSubscription
  extends Promise<AsyncIterator<BookedPlayerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookedPlayerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookedPlayerSubscription>() => T;
}

export interface GameConnection {
  pageInfo: PageInfo;
  edges: GameEdge[];
}

export interface GameConnectionPromise
  extends Promise<GameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameEdge>>() => T;
  aggregate: <T = AggregateGamePromise>() => T;
}

export interface GameConnectionSubscription
  extends Promise<AsyncIterator<GameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameSubscription>() => T;
}

export interface GamerTagSubscriptionPayload {
  mutation: MutationType;
  node: GamerTag;
  updatedFields: String[];
  previousValues: GamerTagPreviousValues;
}

export interface GamerTagSubscriptionPayloadPromise
  extends Promise<GamerTagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamerTagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamerTagPreviousValuesPromise>() => T;
}

export interface GamerTagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamerTagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamerTagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamerTagPreviousValuesSubscription>() => T;
}

export interface AggregateFriendRequest {
  count: Int;
}

export interface AggregateFriendRequestPromise
  extends Promise<AggregateFriendRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFriendRequestSubscription
  extends Promise<AsyncIterator<AggregateFriendRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamerTagPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  psn?: String;
  xbl?: String;
  nso?: String;
}

export interface GamerTagPreviousValuesPromise
  extends Promise<GamerTagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  psn: () => Promise<String>;
  xbl: () => Promise<String>;
  nso: () => Promise<String>;
}

export interface GamerTagPreviousValuesSubscription
  extends Promise<AsyncIterator<GamerTagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  psn: () => Promise<AsyncIterator<String>>;
  xbl: () => Promise<AsyncIterator<String>>;
  nso: () => Promise<AsyncIterator<String>>;
}

export interface FriendRequestConnection {
  pageInfo: PageInfo;
  edges: FriendRequestEdge[];
}

export interface FriendRequestConnectionPromise
  extends Promise<FriendRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FriendRequestEdge>>() => T;
  aggregate: <T = AggregateFriendRequestPromise>() => T;
}

export interface FriendRequestConnectionSubscription
  extends Promise<AsyncIterator<FriendRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FriendRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFriendRequestSubscription>() => T;
}

export interface UserIndex {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  username: String;
  displayName?: String;
  name: String;
}

export interface UserIndexPromise extends Promise<UserIndex>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  displayName: () => Promise<String>;
  name: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface UserIndexSubscription
  extends Promise<AsyncIterator<UserIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface UserIndexNullablePromise
  extends Promise<UserIndex | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  displayName: () => Promise<String>;
  name: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface UserIndexSubscriptionPayload {
  mutation: MutationType;
  node: UserIndex;
  updatedFields: String[];
  previousValues: UserIndexPreviousValues;
}

export interface UserIndexSubscriptionPayloadPromise
  extends Promise<UserIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserIndexPreviousValuesPromise>() => T;
}

export interface UserIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserIndexPreviousValuesSubscription>() => T;
}

export interface GamingSessionSubscriptionPayload {
  mutation: MutationType;
  node: GamingSession;
  updatedFields: String[];
  previousValues: GamingSessionPreviousValues;
}

export interface GamingSessionSubscriptionPayloadPromise
  extends Promise<GamingSessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamingSessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamingSessionPreviousValuesPromise>() => T;
}

export interface GamingSessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamingSessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamingSessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamingSessionPreviousValuesSubscription>() => T;
}

export interface AggregateSocialMedia {
  count: Int;
}

export interface AggregateSocialMediaPromise
  extends Promise<AggregateSocialMedia>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSocialMediaSubscription
  extends Promise<AsyncIterator<AggregateSocialMedia>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamingSessionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  length: Int;
  price: Float;
  launcher?: Launcher;
  system: System;
  type: TypeOfGame;
  slots: Int;
  popularity?: Int;
  views?: Int;
  retired: Boolean;
}

export interface GamingSessionPreviousValuesPromise
  extends Promise<GamingSessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  length: () => Promise<Int>;
  price: () => Promise<Float>;
  launcher: () => Promise<Launcher>;
  system: () => Promise<System>;
  type: () => Promise<TypeOfGame>;
  slots: () => Promise<Int>;
  popularity: () => Promise<Int>;
  views: () => Promise<Int>;
  retired: () => Promise<Boolean>;
}

export interface GamingSessionPreviousValuesSubscription
  extends Promise<AsyncIterator<GamingSessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  length: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  launcher: () => Promise<AsyncIterator<Launcher>>;
  system: () => Promise<AsyncIterator<System>>;
  type: () => Promise<AsyncIterator<TypeOfGame>>;
  slots: () => Promise<AsyncIterator<Int>>;
  popularity: () => Promise<AsyncIterator<Int>>;
  views: () => Promise<AsyncIterator<Int>>;
  retired: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateSessionReviewIndex {
  count: Int;
}

export interface AggregateSessionReviewIndexPromise
  extends Promise<AggregateSessionReviewIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionReviewIndexSubscription
  extends Promise<AsyncIterator<AggregateSessionReviewIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PCLauncher {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  epic?: String;
  steam?: String;
  origin?: String;
  gog?: String;
  battlenet?: String;
  uplay?: String;
  bethesda?: String;
  itch?: String;
  windows?: String;
  riot?: String;
}

export interface PCLauncherPromise extends Promise<PCLauncher>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  gamerTag: <T = GamerTagPromise>() => T;
  epic: () => Promise<String>;
  steam: () => Promise<String>;
  origin: () => Promise<String>;
  gog: () => Promise<String>;
  battlenet: () => Promise<String>;
  uplay: () => Promise<String>;
  bethesda: () => Promise<String>;
  itch: () => Promise<String>;
  windows: () => Promise<String>;
  riot: () => Promise<String>;
}

export interface PCLauncherSubscription
  extends Promise<AsyncIterator<PCLauncher>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  gamerTag: <T = GamerTagSubscription>() => T;
  epic: () => Promise<AsyncIterator<String>>;
  steam: () => Promise<AsyncIterator<String>>;
  origin: () => Promise<AsyncIterator<String>>;
  gog: () => Promise<AsyncIterator<String>>;
  battlenet: () => Promise<AsyncIterator<String>>;
  uplay: () => Promise<AsyncIterator<String>>;
  bethesda: () => Promise<AsyncIterator<String>>;
  itch: () => Promise<AsyncIterator<String>>;
  windows: () => Promise<AsyncIterator<String>>;
  riot: () => Promise<AsyncIterator<String>>;
}

export interface PCLauncherNullablePromise
  extends Promise<PCLauncher | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  gamerTag: <T = GamerTagPromise>() => T;
  epic: () => Promise<String>;
  steam: () => Promise<String>;
  origin: () => Promise<String>;
  gog: () => Promise<String>;
  battlenet: () => Promise<String>;
  uplay: () => Promise<String>;
  bethesda: () => Promise<String>;
  itch: () => Promise<String>;
  windows: () => Promise<String>;
  riot: () => Promise<String>;
}

export interface SessionReviewIndex {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  text: String;
}

export interface SessionReviewIndexPromise
  extends Promise<SessionReviewIndex>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  sessionReview: <T = SessionReviewPromise>() => T;
}

export interface SessionReviewIndexSubscription
  extends Promise<AsyncIterator<SessionReviewIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  sessionReview: <T = SessionReviewSubscription>() => T;
}

export interface SessionReviewIndexNullablePromise
  extends Promise<SessionReviewIndex | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  sessionReview: <T = SessionReviewPromise>() => T;
}

export interface GamingSessionIndexSubscriptionPayload {
  mutation: MutationType;
  node: GamingSessionIndex;
  updatedFields: String[];
  previousValues: GamingSessionIndexPreviousValues;
}

export interface GamingSessionIndexSubscriptionPayloadPromise
  extends Promise<GamingSessionIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamingSessionIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamingSessionIndexPreviousValuesPromise>() => T;
}

export interface GamingSessionIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamingSessionIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamingSessionIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamingSessionIndexPreviousValuesSubscription>() => T;
}

export interface AggregateSavedCard {
  count: Int;
}

export interface AggregateSavedCardPromise
  extends Promise<AggregateSavedCard>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSavedCardSubscription
  extends Promise<AsyncIterator<AggregateSavedCard>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamingSessionIndexPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  gamer: String;
  game?: String;
  launcher?: Launcher;
}

export interface GamingSessionIndexPreviousValuesPromise
  extends Promise<GamingSessionIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  gamer: () => Promise<String>;
  game: () => Promise<String>;
  launcher: () => Promise<Launcher>;
}

export interface GamingSessionIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<GamingSessionIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  gamer: () => Promise<AsyncIterator<String>>;
  game: () => Promise<AsyncIterator<String>>;
  launcher: () => Promise<AsyncIterator<Launcher>>;
}

export interface RequirementEdge {
  node: Requirement;
  cursor: String;
}

export interface RequirementEdgePromise
  extends Promise<RequirementEdge>,
    Fragmentable {
  node: <T = RequirementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RequirementEdgeSubscription
  extends Promise<AsyncIterator<RequirementEdge>>,
    Fragmentable {
  node: <T = RequirementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamerTag {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  psn?: String;
  xbl?: String;
  nso?: String;
}

export interface GamerTagPromise extends Promise<GamerTag>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  psn: () => Promise<String>;
  xbl: () => Promise<String>;
  nso: () => Promise<String>;
  pc: <T = PCLauncherPromise>() => T;
}

export interface GamerTagSubscription
  extends Promise<AsyncIterator<GamerTag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  psn: () => Promise<AsyncIterator<String>>;
  xbl: () => Promise<AsyncIterator<String>>;
  nso: () => Promise<AsyncIterator<String>>;
  pc: <T = PCLauncherSubscription>() => T;
}

export interface GamerTagNullablePromise
  extends Promise<GamerTag | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  psn: () => Promise<String>;
  xbl: () => Promise<String>;
  nso: () => Promise<String>;
  pc: <T = PCLauncherPromise>() => T;
}

export interface PCLauncherConnection {
  pageInfo: PageInfo;
  edges: PCLauncherEdge[];
}

export interface PCLauncherConnectionPromise
  extends Promise<PCLauncherConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PCLauncherEdge>>() => T;
  aggregate: <T = AggregatePCLauncherPromise>() => T;
}

export interface PCLauncherConnectionSubscription
  extends Promise<AsyncIterator<PCLauncherConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PCLauncherEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePCLauncherSubscription>() => T;
}

export interface GamingTimeSlotSubscriptionPayload {
  mutation: MutationType;
  node: GamingTimeSlot;
  updatedFields: String[];
  previousValues: GamingTimeSlotPreviousValues;
}

export interface GamingTimeSlotSubscriptionPayloadPromise
  extends Promise<GamingTimeSlotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamingTimeSlotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamingTimeSlotPreviousValuesPromise>() => T;
}

export interface GamingTimeSlotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamingTimeSlotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamingTimeSlotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamingTimeSlotPreviousValuesSubscription>() => T;
}

export interface NotificationConnection {
  pageInfo: PageInfo;
  edges: NotificationEdge[];
}

export interface NotificationConnectionPromise
  extends Promise<NotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotificationEdge>>() => T;
  aggregate: <T = AggregateNotificationPromise>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface GamingTimeSlotPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  length: Int;
  slots: Int;
}

export interface GamingTimeSlotPreviousValuesPromise
  extends Promise<GamingTimeSlotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  length: () => Promise<Int>;
  slots: () => Promise<Int>;
}

export interface GamingTimeSlotPreviousValuesSubscription
  extends Promise<AsyncIterator<GamingTimeSlotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  length: () => Promise<AsyncIterator<Int>>;
  slots: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateGamingSessionIndex {
  count: Int;
}

export interface AggregateGamingSessionIndexPromise
  extends Promise<AggregateGamingSessionIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamingSessionIndexSubscription
  extends Promise<AsyncIterator<AggregateGamingSessionIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SavedCard {
  id: ID_Output;
  cardId: String;
  default: Boolean;
  lastFour: String;
  brand: String;
}

export interface SavedCardPromise extends Promise<SavedCard>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  cardId: () => Promise<String>;
  default: () => Promise<Boolean>;
  lastFour: () => Promise<String>;
  brand: () => Promise<String>;
}

export interface SavedCardSubscription
  extends Promise<AsyncIterator<SavedCard>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  cardId: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  lastFour: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
}

export interface SavedCardNullablePromise
  extends Promise<SavedCard | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  cardId: () => Promise<String>;
  default: () => Promise<Boolean>;
  lastFour: () => Promise<String>;
  brand: () => Promise<String>;
}

export interface AggregateGamingSession {
  count: Int;
}

export interface AggregateGamingSessionPromise
  extends Promise<AggregateGamingSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamingSessionSubscription
  extends Promise<AsyncIterator<AggregateGamingSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationSubscriptionPayload {
  mutation: MutationType;
  node: Notification;
  updatedFields: String[];
  previousValues: NotificationPreviousValues;
}

export interface NotificationSubscriptionPayloadPromise
  extends Promise<NotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValuesPromise>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface GamerTagEdge {
  node: GamerTag;
  cursor: String;
}

export interface GamerTagEdgePromise
  extends Promise<GamerTagEdge>,
    Fragmentable {
  node: <T = GamerTagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamerTagEdgeSubscription
  extends Promise<AsyncIterator<GamerTagEdge>>,
    Fragmentable {
  node: <T = GamerTagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NotificationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: NotificationType;
  text: String;
  viewed: Boolean;
}

export interface NotificationPreviousValuesPromise
  extends Promise<NotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NotificationType>;
  text: () => Promise<String>;
  viewed: () => Promise<Boolean>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NotificationType>>;
  text: () => Promise<AsyncIterator<String>>;
  viewed: () => Promise<AsyncIterator<Boolean>>;
}

export interface GamerRequestConnection {
  pageInfo: PageInfo;
  edges: GamerRequestEdge[];
}

export interface GamerRequestConnectionPromise
  extends Promise<GamerRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamerRequestEdge>>() => T;
  aggregate: <T = AggregateGamerRequestPromise>() => T;
}

export interface GamerRequestConnectionSubscription
  extends Promise<AsyncIterator<GamerRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GamerRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGamerRequestSubscription>() => T;
}

export interface Discount {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  percentage: Int;
  threshold: Int;
  playerOrSession: PlayerOrSession;
}

export interface DiscountPromise extends Promise<Discount>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  percentage: () => Promise<Int>;
  threshold: () => Promise<Int>;
  playerOrSession: () => Promise<PlayerOrSession>;
}

export interface DiscountSubscription
  extends Promise<AsyncIterator<Discount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  percentage: () => Promise<AsyncIterator<Int>>;
  threshold: () => Promise<AsyncIterator<Int>>;
  playerOrSession: () => Promise<AsyncIterator<PlayerOrSession>>;
}

export interface DiscountNullablePromise
  extends Promise<Discount | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  percentage: () => Promise<Int>;
  threshold: () => Promise<Int>;
  playerOrSession: () => Promise<PlayerOrSession>;
}

export interface GameIndexEdge {
  node: GameIndex;
  cursor: String;
}

export interface GameIndexEdgePromise
  extends Promise<GameIndexEdge>,
    Fragmentable {
  node: <T = GameIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameIndexEdgeSubscription
  extends Promise<AsyncIterator<GameIndexEdge>>,
    Fragmentable {
  node: <T = GameIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PCLauncherSubscriptionPayload {
  mutation: MutationType;
  node: PCLauncher;
  updatedFields: String[];
  previousValues: PCLauncherPreviousValues;
}

export interface PCLauncherSubscriptionPayloadPromise
  extends Promise<PCLauncherSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PCLauncherPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PCLauncherPreviousValuesPromise>() => T;
}

export interface PCLauncherSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PCLauncherSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PCLauncherSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PCLauncherPreviousValuesSubscription>() => T;
}

export interface GameEdge {
  node: Game;
  cursor: String;
}

export interface GameEdgePromise extends Promise<GameEdge>, Fragmentable {
  node: <T = GamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameEdgeSubscription
  extends Promise<AsyncIterator<GameEdge>>,
    Fragmentable {
  node: <T = GameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PCLauncherPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  epic?: String;
  steam?: String;
  origin?: String;
  gog?: String;
  battlenet?: String;
  uplay?: String;
  bethesda?: String;
  itch?: String;
  windows?: String;
  riot?: String;
}

export interface PCLauncherPreviousValuesPromise
  extends Promise<PCLauncherPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  epic: () => Promise<String>;
  steam: () => Promise<String>;
  origin: () => Promise<String>;
  gog: () => Promise<String>;
  battlenet: () => Promise<String>;
  uplay: () => Promise<String>;
  bethesda: () => Promise<String>;
  itch: () => Promise<String>;
  windows: () => Promise<String>;
  riot: () => Promise<String>;
}

export interface PCLauncherPreviousValuesSubscription
  extends Promise<AsyncIterator<PCLauncherPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  epic: () => Promise<AsyncIterator<String>>;
  steam: () => Promise<AsyncIterator<String>>;
  origin: () => Promise<AsyncIterator<String>>;
  gog: () => Promise<AsyncIterator<String>>;
  battlenet: () => Promise<AsyncIterator<String>>;
  uplay: () => Promise<AsyncIterator<String>>;
  bethesda: () => Promise<AsyncIterator<String>>;
  itch: () => Promise<AsyncIterator<String>>;
  windows: () => Promise<AsyncIterator<String>>;
  riot: () => Promise<AsyncIterator<String>>;
}

export interface FriendRequestEdge {
  node: FriendRequest;
  cursor: String;
}

export interface FriendRequestEdgePromise
  extends Promise<FriendRequestEdge>,
    Fragmentable {
  node: <T = FriendRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FriendRequestEdgeSubscription
  extends Promise<AsyncIterator<FriendRequestEdge>>,
    Fragmentable {
  node: <T = FriendRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FriendRequest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FriendRequestPromise
  extends Promise<FriendRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  to: <T = UserPromise>() => T;
  from: <T = UserPromise>() => T;
  notification: <T = NotificationPromise>() => T;
}

export interface FriendRequestSubscription
  extends Promise<AsyncIterator<FriendRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  to: <T = UserSubscription>() => T;
  from: <T = UserSubscription>() => T;
  notification: <T = NotificationSubscription>() => T;
}

export interface FriendRequestNullablePromise
  extends Promise<FriendRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  to: <T = UserPromise>() => T;
  from: <T = UserPromise>() => T;
  notification: <T = NotificationPromise>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RequirementSubscriptionPayload {
  mutation: MutationType;
  node: Requirement;
  updatedFields: String[];
  previousValues: RequirementPreviousValues;
}

export interface RequirementSubscriptionPayloadPromise
  extends Promise<RequirementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RequirementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RequirementPreviousValuesPromise>() => T;
}

export interface RequirementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RequirementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RequirementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RequirementPreviousValuesSubscription>() => T;
}

export interface SessionReviewIndexConnection {
  pageInfo: PageInfo;
  edges: SessionReviewIndexEdge[];
}

export interface SessionReviewIndexConnectionPromise
  extends Promise<SessionReviewIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionReviewIndexEdge>>() => T;
  aggregate: <T = AggregateSessionReviewIndexPromise>() => T;
}

export interface SessionReviewIndexConnectionSubscription
  extends Promise<AsyncIterator<SessionReviewIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SessionReviewIndexEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSessionReviewIndexSubscription>() => T;
}

export interface RequirementPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  msg: String;
}

export interface RequirementPreviousValuesPromise
  extends Promise<RequirementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  msg: () => Promise<String>;
}

export interface RequirementPreviousValuesSubscription
  extends Promise<AsyncIterator<RequirementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  msg: () => Promise<AsyncIterator<String>>;
}

export interface SavedCardConnection {
  pageInfo: PageInfo;
  edges: SavedCardEdge[];
}

export interface SavedCardConnectionPromise
  extends Promise<SavedCardConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SavedCardEdge>>() => T;
  aggregate: <T = AggregateSavedCardPromise>() => T;
}

export interface SavedCardConnectionSubscription
  extends Promise<AsyncIterator<SavedCardConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SavedCardEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSavedCardSubscription>() => T;
}

export interface Notification {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: NotificationType;
  text: String;
  viewed: Boolean;
}

export interface NotificationPromise
  extends Promise<Notification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NotificationType>;
  text: () => Promise<String>;
  for: <T = UserPromise>() => T;
  friendRequest: <T = FriendRequestPromise>() => T;
  bookingInvite: <T = BookingInvitePromise>() => T;
  booking: <T = BookingPromise>() => T;
  friend: <T = UserPromise>() => T;
  viewed: () => Promise<Boolean>;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<Notification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NotificationType>>;
  text: () => Promise<AsyncIterator<String>>;
  for: <T = UserSubscription>() => T;
  friendRequest: <T = FriendRequestSubscription>() => T;
  bookingInvite: <T = BookingInviteSubscription>() => T;
  booking: <T = BookingSubscription>() => T;
  friend: <T = UserSubscription>() => T;
  viewed: () => Promise<AsyncIterator<Boolean>>;
}

export interface NotificationNullablePromise
  extends Promise<Notification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NotificationType>;
  text: () => Promise<String>;
  for: <T = UserPromise>() => T;
  friendRequest: <T = FriendRequestPromise>() => T;
  bookingInvite: <T = BookingInvitePromise>() => T;
  booking: <T = BookingPromise>() => T;
  friend: <T = UserPromise>() => T;
  viewed: () => Promise<Boolean>;
}

export interface AggregateNotification {
  count: Int;
}

export interface AggregateNotificationPromise
  extends Promise<AggregateNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SavedCardSubscriptionPayload {
  mutation: MutationType;
  node: SavedCard;
  updatedFields: String[];
  previousValues: SavedCardPreviousValues;
}

export interface SavedCardSubscriptionPayloadPromise
  extends Promise<SavedCardSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SavedCardPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SavedCardPreviousValuesPromise>() => T;
}

export interface SavedCardSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SavedCardSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SavedCardSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SavedCardPreviousValuesSubscription>() => T;
}

export interface GamingSessionIndexConnection {
  pageInfo: PageInfo;
  edges: GamingSessionIndexEdge[];
}

export interface GamingSessionIndexConnectionPromise
  extends Promise<GamingSessionIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamingSessionIndexEdge>>() => T;
  aggregate: <T = AggregateGamingSessionIndexPromise>() => T;
}

export interface GamingSessionIndexConnectionSubscription
  extends Promise<AsyncIterator<GamingSessionIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<GamingSessionIndexEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateGamingSessionIndexSubscription>() => T;
}

export interface SavedCardPreviousValues {
  id: ID_Output;
  cardId: String;
  default: Boolean;
  lastFour: String;
  brand: String;
}

export interface SavedCardPreviousValuesPromise
  extends Promise<SavedCardPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  cardId: () => Promise<String>;
  default: () => Promise<Boolean>;
  lastFour: () => Promise<String>;
  brand: () => Promise<String>;
}

export interface SavedCardPreviousValuesSubscription
  extends Promise<AsyncIterator<SavedCardPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  cardId: () => Promise<AsyncIterator<String>>;
  default: () => Promise<AsyncIterator<Boolean>>;
  lastFour: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGamerRequest {
  count: Int;
}

export interface AggregateGamerRequestPromise
  extends Promise<AggregateGamerRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamerRequestSubscription
  extends Promise<AsyncIterator<AggregateGamerRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingInvite {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  startTime: DateTimeOutput;
  sent: Boolean;
  accepted?: Boolean;
}

export interface BookingInvitePromise
  extends Promise<BookingInvite>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  booking: <T = BookingPromise>() => T;
  to: <T = UserPromise>() => T;
  from: <T = UserPromise>() => T;
  sent: () => Promise<Boolean>;
  accepted: () => Promise<Boolean>;
  notification: <T = NotificationPromise>() => T;
}

export interface BookingInviteSubscription
  extends Promise<AsyncIterator<BookingInvite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  booking: <T = BookingSubscription>() => T;
  to: <T = UserSubscription>() => T;
  from: <T = UserSubscription>() => T;
  sent: () => Promise<AsyncIterator<Boolean>>;
  accepted: () => Promise<AsyncIterator<Boolean>>;
  notification: <T = NotificationSubscription>() => T;
}

export interface BookingInviteNullablePromise
  extends Promise<BookingInvite | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  booking: <T = BookingPromise>() => T;
  to: <T = UserPromise>() => T;
  from: <T = UserPromise>() => T;
  sent: () => Promise<Boolean>;
  accepted: () => Promise<Boolean>;
  notification: <T = NotificationPromise>() => T;
}

export interface GameIndex {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  launcher?: String;
  tags: String[];
}

export interface GameIndexPromise extends Promise<GameIndex>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  launcher: () => Promise<String>;
  tags: () => Promise<String[]>;
  game: <T = GamePromise>() => T;
}

export interface GameIndexSubscription
  extends Promise<AsyncIterator<GameIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  launcher: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  game: <T = GameSubscription>() => T;
}

export interface GameIndexNullablePromise
  extends Promise<GameIndex | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  launcher: () => Promise<String>;
  tags: () => Promise<String[]>;
  game: <T = GamePromise>() => T;
}

export interface SessionReviewSubscriptionPayload {
  mutation: MutationType;
  node: SessionReview;
  updatedFields: String[];
  previousValues: SessionReviewPreviousValues;
}

export interface SessionReviewSubscriptionPayloadPromise
  extends Promise<SessionReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionReviewPreviousValuesPromise>() => T;
}

export interface SessionReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionReviewPreviousValuesSubscription>() => T;
}

export interface UserIndexEdge {
  node: UserIndex;
  cursor: String;
}

export interface UserIndexEdgePromise
  extends Promise<UserIndexEdge>,
    Fragmentable {
  node: <T = UserIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserIndexEdgeSubscription
  extends Promise<AsyncIterator<UserIndexEdge>>,
    Fragmentable {
  node: <T = UserIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SessionReviewPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  text: String;
  rating: Int;
}

export interface SessionReviewPreviousValuesPromise
  extends Promise<SessionReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  rating: () => Promise<Int>;
}

export interface SessionReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  rating: () => Promise<AsyncIterator<Int>>;
}

export interface SessionReviewEdge {
  node: SessionReview;
  cursor: String;
}

export interface SessionReviewEdgePromise
  extends Promise<SessionReviewEdge>,
    Fragmentable {
  node: <T = SessionReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionReviewEdgeSubscription
  extends Promise<AsyncIterator<SessionReviewEdge>>,
    Fragmentable {
  node: <T = SessionReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Booking {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  charge?: String;
  numSlots: Int;
  numPlayers: Int;
  total: Float;
  cancelled?: Boolean;
}

export interface BookingPromise extends Promise<Booking>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  charge: () => Promise<String>;
  numSlots: () => Promise<Int>;
  numPlayers: () => Promise<Int>;
  players: <T = FragmentableArray<BookedPlayer>>(args?: {
    where?: BookedPlayerWhereInput;
    orderBy?: BookedPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<Float>;
  bookee: <T = UserPromise>() => T;
  timeslot: <T = GamingTimeSlotPromise>() => T;
  invites: <T = FragmentableArray<BookingInvite>>(args?: {
    where?: BookingInviteWhereInput;
    orderBy?: BookingInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cancelled: () => Promise<Boolean>;
  notifications: <T = FragmentableArray<Notification>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookingSubscription
  extends Promise<AsyncIterator<Booking>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  charge: () => Promise<AsyncIterator<String>>;
  numSlots: () => Promise<AsyncIterator<Int>>;
  numPlayers: () => Promise<AsyncIterator<Int>>;
  players: <T = Promise<AsyncIterator<BookedPlayerSubscription>>>(args?: {
    where?: BookedPlayerWhereInput;
    orderBy?: BookedPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<AsyncIterator<Float>>;
  bookee: <T = UserSubscription>() => T;
  timeslot: <T = GamingTimeSlotSubscription>() => T;
  invites: <T = Promise<AsyncIterator<BookingInviteSubscription>>>(args?: {
    where?: BookingInviteWhereInput;
    orderBy?: BookingInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cancelled: () => Promise<AsyncIterator<Boolean>>;
  notifications: <T = Promise<AsyncIterator<NotificationSubscription>>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BookingNullablePromise
  extends Promise<Booking | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  charge: () => Promise<String>;
  numSlots: () => Promise<Int>;
  numPlayers: () => Promise<Int>;
  players: <T = FragmentableArray<BookedPlayer>>(args?: {
    where?: BookedPlayerWhereInput;
    orderBy?: BookedPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<Float>;
  bookee: <T = UserPromise>() => T;
  timeslot: <T = GamingTimeSlotPromise>() => T;
  invites: <T = FragmentableArray<BookingInvite>>(args?: {
    where?: BookingInviteWhereInput;
    orderBy?: BookingInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cancelled: () => Promise<Boolean>;
  notifications: <T = FragmentableArray<Notification>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface GamingTimeSlotEdge {
  node: GamingTimeSlot;
  cursor: String;
}

export interface GamingTimeSlotEdgePromise
  extends Promise<GamingTimeSlotEdge>,
    Fragmentable {
  node: <T = GamingTimeSlotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamingTimeSlotEdgeSubscription
  extends Promise<AsyncIterator<GamingTimeSlotEdge>>,
    Fragmentable {
  node: <T = GamingTimeSlotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamerRequest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  occupations: Occupations[];
  addToOccupations?: String;
}

export interface GamerRequestPromise
  extends Promise<GamerRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  occupations: () => Promise<Occupations[]>;
  addToOccupations: () => Promise<String>;
  socialMedia: <T = SocialMediaPromise>() => T;
}

export interface GamerRequestSubscription
  extends Promise<AsyncIterator<GamerRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  addToOccupations: () => Promise<AsyncIterator<String>>;
  socialMedia: <T = SocialMediaSubscription>() => T;
}

export interface GamerRequestNullablePromise
  extends Promise<GamerRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  occupations: () => Promise<Occupations[]>;
  addToOccupations: () => Promise<String>;
  socialMedia: <T = SocialMediaPromise>() => T;
}

export interface SocialMediaSubscriptionPayload {
  mutation: MutationType;
  node: SocialMedia;
  updatedFields: String[];
  previousValues: SocialMediaPreviousValues;
}

export interface SocialMediaSubscriptionPayloadPromise
  extends Promise<SocialMediaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SocialMediaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SocialMediaPreviousValuesPromise>() => T;
}

export interface SocialMediaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SocialMediaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SocialMediaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SocialMediaPreviousValuesSubscription>() => T;
}

export interface GamingTimeSlot {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  length: Int;
  slots: Int;
}

export interface GamingTimeSlotPromise
  extends Promise<GamingTimeSlot>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  gamingSession: <T = GamingSessionPromise>() => T;
  gamers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookings: <T = FragmentableArray<Booking>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  players: <T = FragmentableArray<BookedPlayer>>(args?: {
    where?: BookedPlayerWhereInput;
    orderBy?: BookedPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  length: () => Promise<Int>;
  slots: () => Promise<Int>;
}

export interface GamingTimeSlotSubscription
  extends Promise<AsyncIterator<GamingTimeSlot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  gamingSession: <T = GamingSessionSubscription>() => T;
  gamers: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  players: <T = Promise<AsyncIterator<BookedPlayerSubscription>>>(args?: {
    where?: BookedPlayerWhereInput;
    orderBy?: BookedPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  length: () => Promise<AsyncIterator<Int>>;
  slots: () => Promise<AsyncIterator<Int>>;
}

export interface GamingTimeSlotNullablePromise
  extends Promise<GamingTimeSlot | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  gamingSession: <T = GamingSessionPromise>() => T;
  gamers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookings: <T = FragmentableArray<Booking>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  players: <T = FragmentableArray<BookedPlayer>>(args?: {
    where?: BookedPlayerWhereInput;
    orderBy?: BookedPlayerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  length: () => Promise<Int>;
  slots: () => Promise<Int>;
}

export interface SessionReviewIndexPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  text: String;
}

export interface SessionReviewIndexPreviousValuesPromise
  extends Promise<SessionReviewIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
}

export interface SessionReviewIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionReviewIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface SessionReviewIndexSubscriptionPayload {
  mutation: MutationType;
  node: SessionReviewIndex;
  updatedFields: String[];
  previousValues: SessionReviewIndexPreviousValues;
}

export interface SessionReviewIndexSubscriptionPayloadPromise
  extends Promise<SessionReviewIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionReviewIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionReviewIndexPreviousValuesPromise>() => T;
}

export interface SessionReviewIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionReviewIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionReviewIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionReviewIndexPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface GamingSessionConnection {
  pageInfo: PageInfo;
  edges: GamingSessionEdge[];
}

export interface GamingSessionConnectionPromise
  extends Promise<GamingSessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamingSessionEdge>>() => T;
  aggregate: <T = AggregateGamingSessionPromise>() => T;
}

export interface GamingSessionConnectionSubscription
  extends Promise<AsyncIterator<GamingSessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GamingSessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGamingSessionSubscription>() => T;
}

export interface AggregatePCLauncher {
  count: Int;
}

export interface AggregatePCLauncherPromise
  extends Promise<AggregatePCLauncher>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePCLauncherSubscription
  extends Promise<AsyncIterator<AggregatePCLauncher>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SocialMediaConnection {
  pageInfo: PageInfo;
  edges: SocialMediaEdge[];
}

export interface SocialMediaConnectionPromise
  extends Promise<SocialMediaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SocialMediaEdge>>() => T;
  aggregate: <T = AggregateSocialMediaPromise>() => T;
}

export interface SocialMediaConnectionSubscription
  extends Promise<AsyncIterator<SocialMediaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SocialMediaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSocialMediaSubscription>() => T;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "UserIndex",
    embedded: false
  },
  {
    name: "BookedPlayer",
    embedded: false
  },
  {
    name: "GamerTag",
    embedded: false
  },
  {
    name: "PCLauncher",
    embedded: false
  },
  {
    name: "SavedCard",
    embedded: false
  },
  {
    name: "GamerRequest",
    embedded: false
  },
  {
    name: "SocialMedia",
    embedded: false
  },
  {
    name: "Game",
    embedded: false
  },
  {
    name: "GameIndex",
    embedded: false
  },
  {
    name: "Launcher",
    embedded: false
  },
  {
    name: "GamingSession",
    embedded: false
  },
  {
    name: "GamingSessionIndex",
    embedded: false
  },
  {
    name: "Requirement",
    embedded: false
  },
  {
    name: "Discount",
    embedded: false
  },
  {
    name: "SessionReview",
    embedded: false
  },
  {
    name: "SessionReviewIndex",
    embedded: false
  },
  {
    name: "GamingTimeSlot",
    embedded: false
  },
  {
    name: "Occupations",
    embedded: false
  },
  {
    name: "Tags",
    embedded: false
  },
  {
    name: "System",
    embedded: false
  },
  {
    name: "TypeOfGame",
    embedded: false
  },
  {
    name: "PlayerOrSession",
    embedded: false
  },
  {
    name: "Booking",
    embedded: false
  },
  {
    name: "BookingInvite",
    embedded: false
  },
  {
    name: "FriendRequest",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "NotificationType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
