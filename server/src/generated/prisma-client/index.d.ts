// Code generated by Prisma (prisma@1.28.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  bookedPlayer: (where?: BookedPlayerWhereInput) => Promise<boolean>;
  booking: (where?: BookingWhereInput) => Promise<boolean>;
  bookingInvite: (where?: BookingInviteWhereInput) => Promise<boolean>;
  discount: (where?: DiscountWhereInput) => Promise<boolean>;
  friendRequest: (where?: FriendRequestWhereInput) => Promise<boolean>;
  game: (where?: GameWhereInput) => Promise<boolean>;
  gameIndex: (where?: GameIndexWhereInput) => Promise<boolean>;
  gamerRequest: (where?: GamerRequestWhereInput) => Promise<boolean>;
  gamerTag: (where?: GamerTagWhereInput) => Promise<boolean>;
  gamingSession: (where?: GamingSessionWhereInput) => Promise<boolean>;
  gamingSessionIndex: (
    where?: GamingSessionIndexWhereInput
  ) => Promise<boolean>;
  gamingTimeSlot: (where?: GamingTimeSlotWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  pCLauncher: (where?: PCLauncherWhereInput) => Promise<boolean>;
  requirement: (where?: RequirementWhereInput) => Promise<boolean>;
  sessionReview: (where?: SessionReviewWhereInput) => Promise<boolean>;
  sessionReviewIndex: (
    where?: SessionReviewIndexWhereInput
  ) => Promise<boolean>;
  socialMedia: (where?: SocialMediaWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userIndex: (where?: UserIndexWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  bookedPlayer: (where: BookedPlayerWhereUniqueInput) => BookedPlayerPromise;
  bookedPlayers: (
    args?: {
      where?: BookedPlayerWhereInput;
      orderBy?: BookedPlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BookedPlayer>;
  bookedPlayersConnection: (
    args?: {
      where?: BookedPlayerWhereInput;
      orderBy?: BookedPlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookedPlayerConnectionPromise;
  booking: (where: BookingWhereUniqueInput) => BookingPromise;
  bookings: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Booking>;
  bookingsConnection: (
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookingConnectionPromise;
  bookingInvite: (where: BookingInviteWhereUniqueInput) => BookingInvitePromise;
  bookingInvites: (
    args?: {
      where?: BookingInviteWhereInput;
      orderBy?: BookingInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BookingInvite>;
  bookingInvitesConnection: (
    args?: {
      where?: BookingInviteWhereInput;
      orderBy?: BookingInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookingInviteConnectionPromise;
  discounts: (
    args?: {
      where?: DiscountWhereInput;
      orderBy?: DiscountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Discount>;
  discountsConnection: (
    args?: {
      where?: DiscountWhereInput;
      orderBy?: DiscountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DiscountConnectionPromise;
  friendRequest: (where: FriendRequestWhereUniqueInput) => FriendRequestPromise;
  friendRequests: (
    args?: {
      where?: FriendRequestWhereInput;
      orderBy?: FriendRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FriendRequest>;
  friendRequestsConnection: (
    args?: {
      where?: FriendRequestWhereInput;
      orderBy?: FriendRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FriendRequestConnectionPromise;
  game: (where: GameWhereUniqueInput) => GamePromise;
  games: (
    args?: {
      where?: GameWhereInput;
      orderBy?: GameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Game>;
  gamesConnection: (
    args?: {
      where?: GameWhereInput;
      orderBy?: GameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GameConnectionPromise;
  gameIndex: (where: GameIndexWhereUniqueInput) => GameIndexPromise;
  gameIndexes: (
    args?: {
      where?: GameIndexWhereInput;
      orderBy?: GameIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GameIndex>;
  gameIndexesConnection: (
    args?: {
      where?: GameIndexWhereInput;
      orderBy?: GameIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GameIndexConnectionPromise;
  gamerRequest: (where: GamerRequestWhereUniqueInput) => GamerRequestPromise;
  gamerRequests: (
    args?: {
      where?: GamerRequestWhereInput;
      orderBy?: GamerRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GamerRequest>;
  gamerRequestsConnection: (
    args?: {
      where?: GamerRequestWhereInput;
      orderBy?: GamerRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GamerRequestConnectionPromise;
  gamerTag: (where: GamerTagWhereUniqueInput) => GamerTagPromise;
  gamerTags: (
    args?: {
      where?: GamerTagWhereInput;
      orderBy?: GamerTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GamerTag>;
  gamerTagsConnection: (
    args?: {
      where?: GamerTagWhereInput;
      orderBy?: GamerTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GamerTagConnectionPromise;
  gamingSession: (where: GamingSessionWhereUniqueInput) => GamingSessionPromise;
  gamingSessions: (
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GamingSession>;
  gamingSessionsConnection: (
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GamingSessionConnectionPromise;
  gamingSessionIndex: (
    where: GamingSessionIndexWhereUniqueInput
  ) => GamingSessionIndexPromise;
  gamingSessionIndexes: (
    args?: {
      where?: GamingSessionIndexWhereInput;
      orderBy?: GamingSessionIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GamingSessionIndex>;
  gamingSessionIndexesConnection: (
    args?: {
      where?: GamingSessionIndexWhereInput;
      orderBy?: GamingSessionIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GamingSessionIndexConnectionPromise;
  gamingTimeSlot: (
    where: GamingTimeSlotWhereUniqueInput
  ) => GamingTimeSlotPromise;
  gamingTimeSlots: (
    args?: {
      where?: GamingTimeSlotWhereInput;
      orderBy?: GamingTimeSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GamingTimeSlot>;
  gamingTimeSlotsConnection: (
    args?: {
      where?: GamingTimeSlotWhereInput;
      orderBy?: GamingTimeSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GamingTimeSlotConnectionPromise;
  notification: (where: NotificationWhereUniqueInput) => NotificationPromise;
  notifications: (
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Notification>;
  notificationsConnection: (
    args?: {
      where?: NotificationWhereInput;
      orderBy?: NotificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NotificationConnectionPromise;
  pCLauncher: (where: PCLauncherWhereUniqueInput) => PCLauncherPromise;
  pCLaunchers: (
    args?: {
      where?: PCLauncherWhereInput;
      orderBy?: PCLauncherOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PCLauncher>;
  pCLaunchersConnection: (
    args?: {
      where?: PCLauncherWhereInput;
      orderBy?: PCLauncherOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PCLauncherConnectionPromise;
  requirements: (
    args?: {
      where?: RequirementWhereInput;
      orderBy?: RequirementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Requirement>;
  requirementsConnection: (
    args?: {
      where?: RequirementWhereInput;
      orderBy?: RequirementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RequirementConnectionPromise;
  sessionReview: (where: SessionReviewWhereUniqueInput) => SessionReviewPromise;
  sessionReviews: (
    args?: {
      where?: SessionReviewWhereInput;
      orderBy?: SessionReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SessionReview>;
  sessionReviewsConnection: (
    args?: {
      where?: SessionReviewWhereInput;
      orderBy?: SessionReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SessionReviewConnectionPromise;
  sessionReviewIndex: (
    where: SessionReviewIndexWhereUniqueInput
  ) => SessionReviewIndexPromise;
  sessionReviewIndexes: (
    args?: {
      where?: SessionReviewIndexWhereInput;
      orderBy?: SessionReviewIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SessionReviewIndex>;
  sessionReviewIndexesConnection: (
    args?: {
      where?: SessionReviewIndexWhereInput;
      orderBy?: SessionReviewIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SessionReviewIndexConnectionPromise;
  socialMedia: (where: SocialMediaWhereUniqueInput) => SocialMediaPromise;
  socialMedias: (
    args?: {
      where?: SocialMediaWhereInput;
      orderBy?: SocialMediaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SocialMedia>;
  socialMediasConnection: (
    args?: {
      where?: SocialMediaWhereInput;
      orderBy?: SocialMediaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SocialMediaConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userIndex: (where: UserIndexWhereUniqueInput) => UserIndexPromise;
  userIndexes: (
    args?: {
      where?: UserIndexWhereInput;
      orderBy?: UserIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserIndex>;
  userIndexesConnection: (
    args?: {
      where?: UserIndexWhereInput;
      orderBy?: UserIndexOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserIndexConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBookedPlayer: (data: BookedPlayerCreateInput) => BookedPlayerPromise;
  updateBookedPlayer: (
    args: { data: BookedPlayerUpdateInput; where: BookedPlayerWhereUniqueInput }
  ) => BookedPlayerPromise;
  upsertBookedPlayer: (
    args: {
      where: BookedPlayerWhereUniqueInput;
      create: BookedPlayerCreateInput;
      update: BookedPlayerUpdateInput;
    }
  ) => BookedPlayerPromise;
  deleteBookedPlayer: (
    where: BookedPlayerWhereUniqueInput
  ) => BookedPlayerPromise;
  deleteManyBookedPlayers: (
    where?: BookedPlayerWhereInput
  ) => BatchPayloadPromise;
  createBooking: (data: BookingCreateInput) => BookingPromise;
  updateBooking: (
    args: { data: BookingUpdateInput; where: BookingWhereUniqueInput }
  ) => BookingPromise;
  updateManyBookings: (
    args: { data: BookingUpdateManyMutationInput; where?: BookingWhereInput }
  ) => BatchPayloadPromise;
  upsertBooking: (
    args: {
      where: BookingWhereUniqueInput;
      create: BookingCreateInput;
      update: BookingUpdateInput;
    }
  ) => BookingPromise;
  deleteBooking: (where: BookingWhereUniqueInput) => BookingPromise;
  deleteManyBookings: (where?: BookingWhereInput) => BatchPayloadPromise;
  createBookingInvite: (data: BookingInviteCreateInput) => BookingInvitePromise;
  updateBookingInvite: (
    args: {
      data: BookingInviteUpdateInput;
      where: BookingInviteWhereUniqueInput;
    }
  ) => BookingInvitePromise;
  updateManyBookingInvites: (
    args: {
      data: BookingInviteUpdateManyMutationInput;
      where?: BookingInviteWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBookingInvite: (
    args: {
      where: BookingInviteWhereUniqueInput;
      create: BookingInviteCreateInput;
      update: BookingInviteUpdateInput;
    }
  ) => BookingInvitePromise;
  deleteBookingInvite: (
    where: BookingInviteWhereUniqueInput
  ) => BookingInvitePromise;
  deleteManyBookingInvites: (
    where?: BookingInviteWhereInput
  ) => BatchPayloadPromise;
  createDiscount: (data: DiscountCreateInput) => DiscountPromise;
  updateManyDiscounts: (
    args: { data: DiscountUpdateManyMutationInput; where?: DiscountWhereInput }
  ) => BatchPayloadPromise;
  deleteManyDiscounts: (where?: DiscountWhereInput) => BatchPayloadPromise;
  createFriendRequest: (data: FriendRequestCreateInput) => FriendRequestPromise;
  updateFriendRequest: (
    args: {
      data: FriendRequestUpdateInput;
      where: FriendRequestWhereUniqueInput;
    }
  ) => FriendRequestPromise;
  upsertFriendRequest: (
    args: {
      where: FriendRequestWhereUniqueInput;
      create: FriendRequestCreateInput;
      update: FriendRequestUpdateInput;
    }
  ) => FriendRequestPromise;
  deleteFriendRequest: (
    where: FriendRequestWhereUniqueInput
  ) => FriendRequestPromise;
  deleteManyFriendRequests: (
    where?: FriendRequestWhereInput
  ) => BatchPayloadPromise;
  createGame: (data: GameCreateInput) => GamePromise;
  updateGame: (
    args: { data: GameUpdateInput; where: GameWhereUniqueInput }
  ) => GamePromise;
  updateManyGames: (
    args: { data: GameUpdateManyMutationInput; where?: GameWhereInput }
  ) => BatchPayloadPromise;
  upsertGame: (
    args: {
      where: GameWhereUniqueInput;
      create: GameCreateInput;
      update: GameUpdateInput;
    }
  ) => GamePromise;
  deleteGame: (where: GameWhereUniqueInput) => GamePromise;
  deleteManyGames: (where?: GameWhereInput) => BatchPayloadPromise;
  createGameIndex: (data: GameIndexCreateInput) => GameIndexPromise;
  updateGameIndex: (
    args: { data: GameIndexUpdateInput; where: GameIndexWhereUniqueInput }
  ) => GameIndexPromise;
  updateManyGameIndexes: (
    args: {
      data: GameIndexUpdateManyMutationInput;
      where?: GameIndexWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGameIndex: (
    args: {
      where: GameIndexWhereUniqueInput;
      create: GameIndexCreateInput;
      update: GameIndexUpdateInput;
    }
  ) => GameIndexPromise;
  deleteGameIndex: (where: GameIndexWhereUniqueInput) => GameIndexPromise;
  deleteManyGameIndexes: (where?: GameIndexWhereInput) => BatchPayloadPromise;
  createGamerRequest: (data: GamerRequestCreateInput) => GamerRequestPromise;
  updateGamerRequest: (
    args: { data: GamerRequestUpdateInput; where: GamerRequestWhereUniqueInput }
  ) => GamerRequestPromise;
  updateManyGamerRequests: (
    args: {
      data: GamerRequestUpdateManyMutationInput;
      where?: GamerRequestWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGamerRequest: (
    args: {
      where: GamerRequestWhereUniqueInput;
      create: GamerRequestCreateInput;
      update: GamerRequestUpdateInput;
    }
  ) => GamerRequestPromise;
  deleteGamerRequest: (
    where: GamerRequestWhereUniqueInput
  ) => GamerRequestPromise;
  deleteManyGamerRequests: (
    where?: GamerRequestWhereInput
  ) => BatchPayloadPromise;
  createGamerTag: (data: GamerTagCreateInput) => GamerTagPromise;
  updateGamerTag: (
    args: { data: GamerTagUpdateInput; where: GamerTagWhereUniqueInput }
  ) => GamerTagPromise;
  updateManyGamerTags: (
    args: { data: GamerTagUpdateManyMutationInput; where?: GamerTagWhereInput }
  ) => BatchPayloadPromise;
  upsertGamerTag: (
    args: {
      where: GamerTagWhereUniqueInput;
      create: GamerTagCreateInput;
      update: GamerTagUpdateInput;
    }
  ) => GamerTagPromise;
  deleteGamerTag: (where: GamerTagWhereUniqueInput) => GamerTagPromise;
  deleteManyGamerTags: (where?: GamerTagWhereInput) => BatchPayloadPromise;
  createGamingSession: (data: GamingSessionCreateInput) => GamingSessionPromise;
  updateGamingSession: (
    args: {
      data: GamingSessionUpdateInput;
      where: GamingSessionWhereUniqueInput;
    }
  ) => GamingSessionPromise;
  updateManyGamingSessions: (
    args: {
      data: GamingSessionUpdateManyMutationInput;
      where?: GamingSessionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGamingSession: (
    args: {
      where: GamingSessionWhereUniqueInput;
      create: GamingSessionCreateInput;
      update: GamingSessionUpdateInput;
    }
  ) => GamingSessionPromise;
  deleteGamingSession: (
    where: GamingSessionWhereUniqueInput
  ) => GamingSessionPromise;
  deleteManyGamingSessions: (
    where?: GamingSessionWhereInput
  ) => BatchPayloadPromise;
  createGamingSessionIndex: (
    data: GamingSessionIndexCreateInput
  ) => GamingSessionIndexPromise;
  updateGamingSessionIndex: (
    args: {
      data: GamingSessionIndexUpdateInput;
      where: GamingSessionIndexWhereUniqueInput;
    }
  ) => GamingSessionIndexPromise;
  updateManyGamingSessionIndexes: (
    args: {
      data: GamingSessionIndexUpdateManyMutationInput;
      where?: GamingSessionIndexWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGamingSessionIndex: (
    args: {
      where: GamingSessionIndexWhereUniqueInput;
      create: GamingSessionIndexCreateInput;
      update: GamingSessionIndexUpdateInput;
    }
  ) => GamingSessionIndexPromise;
  deleteGamingSessionIndex: (
    where: GamingSessionIndexWhereUniqueInput
  ) => GamingSessionIndexPromise;
  deleteManyGamingSessionIndexes: (
    where?: GamingSessionIndexWhereInput
  ) => BatchPayloadPromise;
  createGamingTimeSlot: (
    data: GamingTimeSlotCreateInput
  ) => GamingTimeSlotPromise;
  updateGamingTimeSlot: (
    args: {
      data: GamingTimeSlotUpdateInput;
      where: GamingTimeSlotWhereUniqueInput;
    }
  ) => GamingTimeSlotPromise;
  updateManyGamingTimeSlots: (
    args: {
      data: GamingTimeSlotUpdateManyMutationInput;
      where?: GamingTimeSlotWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGamingTimeSlot: (
    args: {
      where: GamingTimeSlotWhereUniqueInput;
      create: GamingTimeSlotCreateInput;
      update: GamingTimeSlotUpdateInput;
    }
  ) => GamingTimeSlotPromise;
  deleteGamingTimeSlot: (
    where: GamingTimeSlotWhereUniqueInput
  ) => GamingTimeSlotPromise;
  deleteManyGamingTimeSlots: (
    where?: GamingTimeSlotWhereInput
  ) => BatchPayloadPromise;
  createNotification: (data: NotificationCreateInput) => NotificationPromise;
  updateNotification: (
    args: { data: NotificationUpdateInput; where: NotificationWhereUniqueInput }
  ) => NotificationPromise;
  updateManyNotifications: (
    args: {
      data: NotificationUpdateManyMutationInput;
      where?: NotificationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertNotification: (
    args: {
      where: NotificationWhereUniqueInput;
      create: NotificationCreateInput;
      update: NotificationUpdateInput;
    }
  ) => NotificationPromise;
  deleteNotification: (
    where: NotificationWhereUniqueInput
  ) => NotificationPromise;
  deleteManyNotifications: (
    where?: NotificationWhereInput
  ) => BatchPayloadPromise;
  createPCLauncher: (data: PCLauncherCreateInput) => PCLauncherPromise;
  updatePCLauncher: (
    args: { data: PCLauncherUpdateInput; where: PCLauncherWhereUniqueInput }
  ) => PCLauncherPromise;
  updateManyPCLaunchers: (
    args: {
      data: PCLauncherUpdateManyMutationInput;
      where?: PCLauncherWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPCLauncher: (
    args: {
      where: PCLauncherWhereUniqueInput;
      create: PCLauncherCreateInput;
      update: PCLauncherUpdateInput;
    }
  ) => PCLauncherPromise;
  deletePCLauncher: (where: PCLauncherWhereUniqueInput) => PCLauncherPromise;
  deleteManyPCLaunchers: (where?: PCLauncherWhereInput) => BatchPayloadPromise;
  createRequirement: (data: RequirementCreateInput) => RequirementPromise;
  updateManyRequirements: (
    args: {
      data: RequirementUpdateManyMutationInput;
      where?: RequirementWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyRequirements: (
    where?: RequirementWhereInput
  ) => BatchPayloadPromise;
  createSessionReview: (data: SessionReviewCreateInput) => SessionReviewPromise;
  updateSessionReview: (
    args: {
      data: SessionReviewUpdateInput;
      where: SessionReviewWhereUniqueInput;
    }
  ) => SessionReviewPromise;
  updateManySessionReviews: (
    args: {
      data: SessionReviewUpdateManyMutationInput;
      where?: SessionReviewWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSessionReview: (
    args: {
      where: SessionReviewWhereUniqueInput;
      create: SessionReviewCreateInput;
      update: SessionReviewUpdateInput;
    }
  ) => SessionReviewPromise;
  deleteSessionReview: (
    where: SessionReviewWhereUniqueInput
  ) => SessionReviewPromise;
  deleteManySessionReviews: (
    where?: SessionReviewWhereInput
  ) => BatchPayloadPromise;
  createSessionReviewIndex: (
    data: SessionReviewIndexCreateInput
  ) => SessionReviewIndexPromise;
  updateSessionReviewIndex: (
    args: {
      data: SessionReviewIndexUpdateInput;
      where: SessionReviewIndexWhereUniqueInput;
    }
  ) => SessionReviewIndexPromise;
  updateManySessionReviewIndexes: (
    args: {
      data: SessionReviewIndexUpdateManyMutationInput;
      where?: SessionReviewIndexWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSessionReviewIndex: (
    args: {
      where: SessionReviewIndexWhereUniqueInput;
      create: SessionReviewIndexCreateInput;
      update: SessionReviewIndexUpdateInput;
    }
  ) => SessionReviewIndexPromise;
  deleteSessionReviewIndex: (
    where: SessionReviewIndexWhereUniqueInput
  ) => SessionReviewIndexPromise;
  deleteManySessionReviewIndexes: (
    where?: SessionReviewIndexWhereInput
  ) => BatchPayloadPromise;
  createSocialMedia: (data: SocialMediaCreateInput) => SocialMediaPromise;
  updateSocialMedia: (
    args: { data: SocialMediaUpdateInput; where: SocialMediaWhereUniqueInput }
  ) => SocialMediaPromise;
  updateManySocialMedias: (
    args: {
      data: SocialMediaUpdateManyMutationInput;
      where?: SocialMediaWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSocialMedia: (
    args: {
      where: SocialMediaWhereUniqueInput;
      create: SocialMediaCreateInput;
      update: SocialMediaUpdateInput;
    }
  ) => SocialMediaPromise;
  deleteSocialMedia: (where: SocialMediaWhereUniqueInput) => SocialMediaPromise;
  deleteManySocialMedias: (
    where?: SocialMediaWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserIndex: (data: UserIndexCreateInput) => UserIndexPromise;
  updateUserIndex: (
    args: { data: UserIndexUpdateInput; where: UserIndexWhereUniqueInput }
  ) => UserIndexPromise;
  updateManyUserIndexes: (
    args: {
      data: UserIndexUpdateManyMutationInput;
      where?: UserIndexWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserIndex: (
    args: {
      where: UserIndexWhereUniqueInput;
      create: UserIndexCreateInput;
      update: UserIndexUpdateInput;
    }
  ) => UserIndexPromise;
  deleteUserIndex: (where: UserIndexWhereUniqueInput) => UserIndexPromise;
  deleteManyUserIndexes: (where?: UserIndexWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  bookedPlayer: (
    where?: BookedPlayerSubscriptionWhereInput
  ) => BookedPlayerSubscriptionPayloadSubscription;
  booking: (
    where?: BookingSubscriptionWhereInput
  ) => BookingSubscriptionPayloadSubscription;
  bookingInvite: (
    where?: BookingInviteSubscriptionWhereInput
  ) => BookingInviteSubscriptionPayloadSubscription;
  discount: (
    where?: DiscountSubscriptionWhereInput
  ) => DiscountSubscriptionPayloadSubscription;
  friendRequest: (
    where?: FriendRequestSubscriptionWhereInput
  ) => FriendRequestSubscriptionPayloadSubscription;
  game: (
    where?: GameSubscriptionWhereInput
  ) => GameSubscriptionPayloadSubscription;
  gameIndex: (
    where?: GameIndexSubscriptionWhereInput
  ) => GameIndexSubscriptionPayloadSubscription;
  gamerRequest: (
    where?: GamerRequestSubscriptionWhereInput
  ) => GamerRequestSubscriptionPayloadSubscription;
  gamerTag: (
    where?: GamerTagSubscriptionWhereInput
  ) => GamerTagSubscriptionPayloadSubscription;
  gamingSession: (
    where?: GamingSessionSubscriptionWhereInput
  ) => GamingSessionSubscriptionPayloadSubscription;
  gamingSessionIndex: (
    where?: GamingSessionIndexSubscriptionWhereInput
  ) => GamingSessionIndexSubscriptionPayloadSubscription;
  gamingTimeSlot: (
    where?: GamingTimeSlotSubscriptionWhereInput
  ) => GamingTimeSlotSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  pCLauncher: (
    where?: PCLauncherSubscriptionWhereInput
  ) => PCLauncherSubscriptionPayloadSubscription;
  requirement: (
    where?: RequirementSubscriptionWhereInput
  ) => RequirementSubscriptionPayloadSubscription;
  sessionReview: (
    where?: SessionReviewSubscriptionWhereInput
  ) => SessionReviewSubscriptionPayloadSubscription;
  sessionReviewIndex: (
    where?: SessionReviewIndexSubscriptionWhereInput
  ) => SessionReviewIndexSubscriptionPayloadSubscription;
  socialMedia: (
    where?: SocialMediaSubscriptionWhereInput
  ) => SocialMediaSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userIndex: (
    where?: UserIndexSubscriptionWhereInput
  ) => UserIndexSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type BookingInviteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "sent_ASC"
  | "sent_DESC"
  | "accepted_ASC"
  | "accepted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "launcher_ASC"
  | "launcher_DESC"
  | "numSessions_ASC"
  | "numSessions_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "numSlots_ASC"
  | "numSlots_DESC"
  | "numPlayers_ASC"
  | "numPlayers_DESC"
  | "total_ASC"
  | "total_DESC"
  | "cancelled_ASC"
  | "cancelled_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "username_ASC"
  | "username_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NotificationType =
  | "CANCELLED_TIMESLOT"
  | "ACCEPTED_GAMER_REQUEST"
  | "DENIED_GAMER_REQUEST"
  | "FRIEND_REQUEST"
  | "ACCEPTED_TIMESLOT_REQUEST"
  | "TIMESLOT_REQUEST"
  | "BOOKED_TIMESLOT"
  | "TIMESLOT_INVITE"
  | "ACCEPTED_TIMESLOT_INVITE"
  | "ACCEPTED_FRIEND_REQUEST";

export type SessionReviewIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GamingTimeSlotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "length_ASC"
  | "length_DESC"
  | "slots_ASC"
  | "slots_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PCLauncherOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "epic_ASC"
  | "epic_DESC"
  | "steam_ASC"
  | "steam_DESC"
  | "origin_ASC"
  | "origin_DESC"
  | "gog_ASC"
  | "gog_DESC"
  | "battlenet_ASC"
  | "battlenet_DESC"
  | "uplay_ASC"
  | "uplay_DESC"
  | "bethesda_ASC"
  | "bethesda_DESC"
  | "itch_ASC"
  | "itch_DESC"
  | "windows_ASC"
  | "windows_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DiscountOrderByInput =
  | "percentage_ASC"
  | "percentage_DESC"
  | "threshold_ASC"
  | "threshold_DESC"
  | "playerOrSession_ASC"
  | "playerOrSession_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GamingSessionIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RequirementOrderByInput =
  | "msg_ASC"
  | "msg_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GameIndexOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SessionReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "text_ASC"
  | "text_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GamerTagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "psn_ASC"
  | "psn_DESC"
  | "xbl_ASC"
  | "xbl_DESC"
  | "nso_ASC"
  | "nso_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "isGamer_ASC"
  | "isGamer_DESC"
  | "name_ASC"
  | "name_DESC"
  | "aboutMe_ASC"
  | "aboutMe_DESC"
  | "setup_ASC"
  | "setup_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type System = "PS4" | "PC" | "XBOX_ONE" | "NINTENDO_SWITCH";

export type Occupations =
  | "CELEBRITY"
  | "INFLUENCER"
  | "ENTERTAINER"
  | "STREAMER"
  | "YOUTUBER"
  | "MEDIA"
  | "SPORTS_PERSONALITY"
  | "INTERNET_PERSONALITY"
  | "ATHLETE"
  | "PROFESIONAL_GAMER"
  | "ACTOR"
  | "COMEDIAN"
  | "ROCK_STAR"
  | "RAPPER"
  | "SINGER"
  | "MUSICIAN"
  | "POLITICIAN"
  | "DJ"
  | "MUSIC_PRODUCER"
  | "ENTREPRENEUR"
  | "ARTIST"
  | "ACTRESS"
  | "MODEL"
  | "ADULT_PERFORMER";

export type TypeOfGame = "CUSTOM" | "MATCHMAKING";

export type GamerRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "addToOccupations_ASC"
  | "addToOccupations_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Launcher =
  | "EPIC"
  | "STEAM"
  | "ORIGIN"
  | "BATTLENET"
  | "GOG"
  | "UPLAY"
  | "BETHESDA"
  | "ITCH"
  | "WINDOWS";

export type PlayerOrSession = "PLAYER" | "SESSION";

export type Tags =
  | "ACTION"
  | "ADVENTURE_GAME"
  | "CARD_AND_BOARD_GAME"
  | "COMPILATION"
  | "DRIVING_SLASH_RACING_GAME"
  | "EDUCATIONAL_GAME"
  | "FIGHTING"
  | "FLIGHT_SIMULATOR"
  | "FPS"
  | "GAMBLING_GAME"
  | "HIDDEN_OBJECTS"
  | "HORROR"
  | "INDIE_GAME"
  | "METROIDVANIA"
  | "MMORPG"
  | "MOBA"
  | "OPEN_WORLD"
  | "PINBALL"
  | "PLATFORMER"
  | "POINT_AND_CLICK"
  | "PUZZLE"
  | "RHYTHM_AND_MUSIC_GAME"
  | "ROGUELIKE"
  | "RPG"
  | "RTS"
  | "SERIES_COLON_SOULS"
  | "SHOOT_HYPHEN_EM_UP"
  | "SHOOTER"
  | "SIMULATION"
  | "SPORTS_GAME"
  | "STEALTH"
  | "STRATEGY"
  | "SURVIVAL"
  | "VISUAL_NOVEL";

export type GamingSessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "length_ASC"
  | "length_DESC"
  | "price_ASC"
  | "price_DESC"
  | "system_ASC"
  | "system_DESC"
  | "type_ASC"
  | "type_DESC"
  | "slots_ASC"
  | "slots_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FriendRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "text_ASC"
  | "text_DESC"
  | "viewed_ASC"
  | "viewed_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SocialMediaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "twitter_ASC"
  | "twitter_DESC"
  | "facebook_ASC"
  | "facebook_DESC"
  | "youtube_ASC"
  | "youtube_DESC"
  | "instagram_ASC"
  | "instagram_DESC"
  | "twitch_ASC"
  | "twitch_DESC"
  | "snapchat_ASC"
  | "snapchat_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookedPlayerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface RequirementUpdateManyDataInput {
  msg?: String;
}

export type BookedPlayerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GamingSessionCreateWithoutReviewsInput {
  gamers?: UserCreateManyWithoutSessionsInput;
  creator: UserCreateOneInput;
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  system: System;
  type: TypeOfGame;
  slots: Int;
  requirements?: RequirementCreateManyInput;
  discounts?: DiscountCreateManyInput;
  timeslots?: GamingTimeSlotCreateManyWithoutGamingSessionInput;
}

export interface NotificationCreateWithoutFriendRequestInput {
  type: NotificationType;
  text: String;
  for: UserCreateOneInput;
  bookingInvite?: BookingInviteCreateOneWithoutNotificationInput;
  booking?: BookingCreateOneInput;
  friend?: UserCreateOneInput;
  viewed?: Boolean;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface GamingTimeSlotUpdateWithoutBookingsDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  gamingSession?: GamingSessionUpdateOneRequiredWithoutTimeslotsInput;
  gamers?: UserUpdateManyWithoutTimeSlotsInput;
  players?: BookedPlayerUpdateManyWithoutTimeslotInput;
  length?: Int;
  slots?: Int;
}

export interface GamerTagCreateManyInput {
  create?: GamerTagCreateInput[] | GamerTagCreateInput;
  connect?: GamerTagWhereUniqueInput[] | GamerTagWhereUniqueInput;
}

export interface UserIndexSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserIndexWhereInput;
  AND?: UserIndexSubscriptionWhereInput[] | UserIndexSubscriptionWhereInput;
  OR?: UserIndexSubscriptionWhereInput[] | UserIndexSubscriptionWhereInput;
  NOT?: UserIndexSubscriptionWhereInput[] | UserIndexSubscriptionWhereInput;
}

export interface GamerTagCreateInput {
  psn?: String;
  xbl?: String;
  nso?: String;
  pc?: PCLauncherCreateOneInput;
}

export interface GamerTagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  psn?: String;
  psn_not?: String;
  psn_in?: String[] | String;
  psn_not_in?: String[] | String;
  psn_lt?: String;
  psn_lte?: String;
  psn_gt?: String;
  psn_gte?: String;
  psn_contains?: String;
  psn_not_contains?: String;
  psn_starts_with?: String;
  psn_not_starts_with?: String;
  psn_ends_with?: String;
  psn_not_ends_with?: String;
  xbl?: String;
  xbl_not?: String;
  xbl_in?: String[] | String;
  xbl_not_in?: String[] | String;
  xbl_lt?: String;
  xbl_lte?: String;
  xbl_gt?: String;
  xbl_gte?: String;
  xbl_contains?: String;
  xbl_not_contains?: String;
  xbl_starts_with?: String;
  xbl_not_starts_with?: String;
  xbl_ends_with?: String;
  xbl_not_ends_with?: String;
  nso?: String;
  nso_not?: String;
  nso_in?: String[] | String;
  nso_not_in?: String[] | String;
  nso_lt?: String;
  nso_lte?: String;
  nso_gt?: String;
  nso_gte?: String;
  nso_contains?: String;
  nso_not_contains?: String;
  nso_starts_with?: String;
  nso_not_starts_with?: String;
  nso_ends_with?: String;
  nso_not_ends_with?: String;
  pc?: PCLauncherWhereInput;
  AND?: GamerTagWhereInput[] | GamerTagWhereInput;
  OR?: GamerTagWhereInput[] | GamerTagWhereInput;
  NOT?: GamerTagWhereInput[] | GamerTagWhereInput;
}

export interface PCLauncherCreateOneInput {
  create?: PCLauncherCreateInput;
  connect?: PCLauncherWhereUniqueInput;
}

export interface SessionReviewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  session?: GamingSessionWhereInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  rating?: Int;
  rating_not?: Int;
  rating_in?: Int[] | Int;
  rating_not_in?: Int[] | Int;
  rating_lt?: Int;
  rating_lte?: Int;
  rating_gt?: Int;
  rating_gte?: Int;
  AND?: SessionReviewWhereInput[] | SessionReviewWhereInput;
  OR?: SessionReviewWhereInput[] | SessionReviewWhereInput;
  NOT?: SessionReviewWhereInput[] | SessionReviewWhereInput;
}

export interface PCLauncherCreateInput {
  epic?: String;
  steam?: String;
  origin?: String;
  gog?: String;
  battlenet?: String;
  uplay?: String;
  bethesda?: String;
  itch?: String;
  windows?: String;
}

export interface BookedPlayerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  player?: UserWhereInput;
  timeslot?: GamingTimeSlotWhereInput;
  AND?: BookedPlayerWhereInput[] | BookedPlayerWhereInput;
  OR?: BookedPlayerWhereInput[] | BookedPlayerWhereInput;
  NOT?: BookedPlayerWhereInput[] | BookedPlayerWhereInput;
}

export interface NotificationCreateOneWithoutBookingInviteInput {
  create?: NotificationCreateWithoutBookingInviteInput;
  connect?: NotificationWhereUniqueInput;
}

export interface FriendRequestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  to?: UserWhereInput;
  from?: UserWhereInput;
  notification?: NotificationWhereInput;
  AND?: FriendRequestWhereInput[] | FriendRequestWhereInput;
  OR?: FriendRequestWhereInput[] | FriendRequestWhereInput;
  NOT?: FriendRequestWhereInput[] | FriendRequestWhereInput;
}

export interface NotificationCreateWithoutBookingInviteInput {
  type: NotificationType;
  text: String;
  for: UserCreateOneInput;
  friendRequest?: FriendRequestCreateOneWithoutNotificationInput;
  booking?: BookingCreateOneInput;
  friend?: UserCreateOneInput;
  viewed?: Boolean;
}

export interface NotificationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: NotificationType;
  type_not?: NotificationType;
  type_in?: NotificationType[] | NotificationType;
  type_not_in?: NotificationType[] | NotificationType;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  for?: UserWhereInput;
  friendRequest?: FriendRequestWhereInput;
  bookingInvite?: BookingInviteWhereInput;
  booking?: BookingWhereInput;
  friend?: UserWhereInput;
  viewed?: Boolean;
  viewed_not?: Boolean;
  AND?: NotificationWhereInput[] | NotificationWhereInput;
  OR?: NotificationWhereInput[] | NotificationWhereInput;
  NOT?: NotificationWhereInput[] | NotificationWhereInput;
}

export interface FriendRequestCreateOneWithoutNotificationInput {
  create?: FriendRequestCreateWithoutNotificationInput;
  connect?: FriendRequestWhereUniqueInput;
}

export interface BookingInviteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  booking?: BookingWhereInput;
  to?: UserWhereInput;
  from?: UserWhereInput;
  sent?: Boolean;
  sent_not?: Boolean;
  accepted?: Boolean;
  accepted_not?: Boolean;
  notification?: NotificationWhereInput;
  AND?: BookingInviteWhereInput[] | BookingInviteWhereInput;
  OR?: BookingInviteWhereInput[] | BookingInviteWhereInput;
  NOT?: BookingInviteWhereInput[] | BookingInviteWhereInput;
}

export interface FriendRequestCreateWithoutNotificationInput {
  to: UserCreateOneInput;
  from: UserCreateOneInput;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NotificationWhereInput;
  AND?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  OR?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  NOT?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
}

export interface BookingCreateOneInput {
  create?: BookingCreateInput;
  connect?: BookingWhereUniqueInput;
}

export interface GamingSessionIndexSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GamingSessionIndexWhereInput;
  AND?:
    | GamingSessionIndexSubscriptionWhereInput[]
    | GamingSessionIndexSubscriptionWhereInput;
  OR?:
    | GamingSessionIndexSubscriptionWhereInput[]
    | GamingSessionIndexSubscriptionWhereInput;
  NOT?:
    | GamingSessionIndexSubscriptionWhereInput[]
    | GamingSessionIndexSubscriptionWhereInput;
}

export interface BookingCreateInput {
  numSlots: Int;
  numPlayers: Int;
  players?: UserCreateManyWithoutTimeSlotsBookedInput;
  total: Float;
  timeslot: GamingTimeSlotCreateOneWithoutBookingsInput;
  invites?: BookingInviteCreateManyWithoutBookingInput;
  cancelled?: Boolean;
}

export interface GamerTagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GamerTagWhereInput;
  AND?: GamerTagSubscriptionWhereInput[] | GamerTagSubscriptionWhereInput;
  OR?: GamerTagSubscriptionWhereInput[] | GamerTagSubscriptionWhereInput;
  NOT?: GamerTagSubscriptionWhereInput[] | GamerTagSubscriptionWhereInput;
}

export interface BookingCreateManyWithoutTimeslotInput {
  create?:
    | BookingCreateWithoutTimeslotInput[]
    | BookingCreateWithoutTimeslotInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface GameIndexSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GameIndexWhereInput;
  AND?: GameIndexSubscriptionWhereInput[] | GameIndexSubscriptionWhereInput;
  OR?: GameIndexSubscriptionWhereInput[] | GameIndexSubscriptionWhereInput;
  NOT?: GameIndexSubscriptionWhereInput[] | GameIndexSubscriptionWhereInput;
}

export interface BookingCreateWithoutTimeslotInput {
  numSlots: Int;
  numPlayers: Int;
  players?: UserCreateManyWithoutTimeSlotsBookedInput;
  total: Float;
  invites?: BookingInviteCreateManyWithoutBookingInput;
  cancelled?: Boolean;
}

export interface FriendRequestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FriendRequestWhereInput;
  AND?:
    | FriendRequestSubscriptionWhereInput[]
    | FriendRequestSubscriptionWhereInput;
  OR?:
    | FriendRequestSubscriptionWhereInput[]
    | FriendRequestSubscriptionWhereInput;
  NOT?:
    | FriendRequestSubscriptionWhereInput[]
    | FriendRequestSubscriptionWhereInput;
}

export interface GamingTimeSlotCreateOneWithoutPlayersInput {
  create?: GamingTimeSlotCreateWithoutPlayersInput;
  connect?: GamingTimeSlotWhereUniqueInput;
}

export type BookingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GamingTimeSlotCreateWithoutPlayersInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamingSession: GamingSessionCreateOneWithoutTimeslotsInput;
  gamers?: UserCreateManyWithoutTimeSlotsInput;
  bookings?: BookingCreateManyWithoutTimeslotInput;
  length: Int;
  slots: Int;
}

export interface BookingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookingWhereInput;
  AND?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  OR?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
  NOT?: BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput;
}

export interface BookedPlayerUpdateInput {
  player?: UserUpdateOneRequiredInput;
  timeslot?: GamingTimeSlotUpdateOneRequiredWithoutPlayersInput;
}

export type BookingInviteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserIndexUpdateInput {
  email?: String;
  username?: String;
  name?: String;
  user?: UserUpdateOneRequiredInput;
}

export interface UserUpdateDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  sessions?: GamingSessionUpdateManyWithoutGamersInput;
  timeSlots?: GamingTimeSlotUpdateManyWithoutGamersInput;
  timeSlotsBooked?: BookingUpdateManyWithoutPlayersInput;
  invites?: BookingInviteUpdateManyWithoutFromInput;
  invitesReceived?: BookingInviteUpdateManyWithoutToInput;
  setup?: Int;
  reviews?: SessionReviewUpdateManyWithoutUserInput;
  friends?: UserUpdateManyInput;
  gamertags?: GamerTagUpdateManyInput;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  setup?: Int;
}

export interface UserUpdateoccupationsInput {
  set?: Occupations[] | Occupations;
}

export interface SocialMediaUpdateManyMutationInput {
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface GameUpdateManyInput {
  create?: GameCreateInput[] | GameCreateInput;
  update?:
    | GameUpdateWithWhereUniqueNestedInput[]
    | GameUpdateWithWhereUniqueNestedInput;
  upsert?:
    | GameUpsertWithWhereUniqueNestedInput[]
    | GameUpsertWithWhereUniqueNestedInput;
  delete?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  connect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  set?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  disconnect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
  deleteMany?: GameScalarWhereInput[] | GameScalarWhereInput;
  updateMany?:
    | GameUpdateManyWithWhereNestedInput[]
    | GameUpdateManyWithWhereNestedInput;
}

export interface BookingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  numSlots?: Int;
  numSlots_not?: Int;
  numSlots_in?: Int[] | Int;
  numSlots_not_in?: Int[] | Int;
  numSlots_lt?: Int;
  numSlots_lte?: Int;
  numSlots_gt?: Int;
  numSlots_gte?: Int;
  numPlayers?: Int;
  numPlayers_not?: Int;
  numPlayers_in?: Int[] | Int;
  numPlayers_not_in?: Int[] | Int;
  numPlayers_lt?: Int;
  numPlayers_lte?: Int;
  numPlayers_gt?: Int;
  numPlayers_gte?: Int;
  players_every?: UserWhereInput;
  players_some?: UserWhereInput;
  players_none?: UserWhereInput;
  total?: Float;
  total_not?: Float;
  total_in?: Float[] | Float;
  total_not_in?: Float[] | Float;
  total_lt?: Float;
  total_lte?: Float;
  total_gt?: Float;
  total_gte?: Float;
  timeslot?: GamingTimeSlotWhereInput;
  invites_every?: BookingInviteWhereInput;
  invites_some?: BookingInviteWhereInput;
  invites_none?: BookingInviteWhereInput;
  cancelled?: Boolean;
  cancelled_not?: Boolean;
  AND?: BookingWhereInput[] | BookingWhereInput;
  OR?: BookingWhereInput[] | BookingWhereInput;
  NOT?: BookingWhereInput[] | BookingWhereInput;
}

export interface GameUpdateWithWhereUniqueNestedInput {
  where: GameWhereUniqueInput;
  data: GameUpdateDataInput;
}

export interface SessionReviewIndexUpdateManyMutationInput {
  text?: String;
}

export interface GameUpdateDataInput {
  name?: String;
  tags?: GameUpdatetagsInput;
  sessions?: GamingSessionUpdateManyWithoutGameInput;
  launcher?: Launcher;
  numSessions?: Int;
}

export type GameWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface GameUpdatetagsInput {
  set?: Tags[] | Tags;
}

export interface SessionReviewUpdateOneRequiredInput {
  create?: SessionReviewCreateInput;
  update?: SessionReviewUpdateDataInput;
  upsert?: SessionReviewUpsertNestedInput;
  connect?: SessionReviewWhereUniqueInput;
}

export interface GamingSessionUpdateManyWithoutGameInput {
  create?:
    | GamingSessionCreateWithoutGameInput[]
    | GamingSessionCreateWithoutGameInput;
  delete?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  connect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  set?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  disconnect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  update?:
    | GamingSessionUpdateWithWhereUniqueWithoutGameInput[]
    | GamingSessionUpdateWithWhereUniqueWithoutGameInput;
  upsert?:
    | GamingSessionUpsertWithWhereUniqueWithoutGameInput[]
    | GamingSessionUpsertWithWhereUniqueWithoutGameInput;
  deleteMany?: GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput;
  updateMany?:
    | GamingSessionUpdateManyWithWhereNestedInput[]
    | GamingSessionUpdateManyWithWhereNestedInput;
}

export type GameIndexWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GamingSessionUpdateWithWhereUniqueWithoutGameInput {
  where: GamingSessionWhereUniqueInput;
  data: GamingSessionUpdateWithoutGameDataInput;
}

export interface GameIndexWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  game?: GameWhereInput;
  AND?: GameIndexWhereInput[] | GameIndexWhereInput;
  OR?: GameIndexWhereInput[] | GameIndexWhereInput;
  NOT?: GameIndexWhereInput[] | GameIndexWhereInput;
}

export interface GamingSessionUpdateWithoutGameDataInput {
  gamers?: UserUpdateManyWithoutSessionsInput;
  creator?: UserUpdateOneRequiredInput;
  title?: String;
  length?: Int;
  price?: Float;
  reviews?: SessionReviewUpdateManyWithoutSessionInput;
  system?: System;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
  timeslots?: GamingTimeSlotUpdateManyWithoutGamingSessionInput;
}

export interface SessionReviewUpdateManyMutationInput {
  text?: String;
  rating?: Int;
}

export interface UserUpdateManyWithoutSessionsInput {
  create?: UserCreateWithoutSessionsInput[] | UserCreateWithoutSessionsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutSessionsInput[]
    | UserUpdateWithWhereUniqueWithoutSessionsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutSessionsInput[]
    | UserUpsertWithWhereUniqueWithoutSessionsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface SessionReviewCreateInput {
  user: UserCreateOneWithoutReviewsInput;
  session: GamingSessionCreateOneWithoutReviewsInput;
  text: String;
  rating: Int;
}

export interface UserUpdateWithWhereUniqueWithoutSessionsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSessionsDataInput;
}

export interface RequirementUpdateManyMutationInput {
  msg?: String;
}

export interface UserUpdateWithoutSessionsDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  timeSlots?: GamingTimeSlotUpdateManyWithoutGamersInput;
  timeSlotsBooked?: BookingUpdateManyWithoutPlayersInput;
  invites?: BookingInviteUpdateManyWithoutFromInput;
  invitesReceived?: BookingInviteUpdateManyWithoutToInput;
  setup?: Int;
  reviews?: SessionReviewUpdateManyWithoutUserInput;
  friends?: UserUpdateManyInput;
  gamertags?: GamerTagUpdateManyInput;
}

export interface GamerRequestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  addToOccupations?: String;
  addToOccupations_not?: String;
  addToOccupations_in?: String[] | String;
  addToOccupations_not_in?: String[] | String;
  addToOccupations_lt?: String;
  addToOccupations_lte?: String;
  addToOccupations_gt?: String;
  addToOccupations_gte?: String;
  addToOccupations_contains?: String;
  addToOccupations_not_contains?: String;
  addToOccupations_starts_with?: String;
  addToOccupations_not_starts_with?: String;
  addToOccupations_ends_with?: String;
  addToOccupations_not_ends_with?: String;
  socialMedia?: SocialMediaWhereInput;
  AND?: GamerRequestWhereInput[] | GamerRequestWhereInput;
  OR?: GamerRequestWhereInput[] | GamerRequestWhereInput;
  NOT?: GamerRequestWhereInput[] | GamerRequestWhereInput;
}

export interface GamingTimeSlotUpdateManyWithoutGamersInput {
  create?:
    | GamingTimeSlotCreateWithoutGamersInput[]
    | GamingTimeSlotCreateWithoutGamersInput;
  delete?: GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput;
  connect?: GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput;
  set?: GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput;
  disconnect?:
    | GamingTimeSlotWhereUniqueInput[]
    | GamingTimeSlotWhereUniqueInput;
  update?:
    | GamingTimeSlotUpdateWithWhereUniqueWithoutGamersInput[]
    | GamingTimeSlotUpdateWithWhereUniqueWithoutGamersInput;
  upsert?:
    | GamingTimeSlotUpsertWithWhereUniqueWithoutGamersInput[]
    | GamingTimeSlotUpsertWithWhereUniqueWithoutGamersInput;
  deleteMany?:
    | GamingTimeSlotScalarWhereInput[]
    | GamingTimeSlotScalarWhereInput;
  updateMany?:
    | GamingTimeSlotUpdateManyWithWhereNestedInput[]
    | GamingTimeSlotUpdateManyWithWhereNestedInput;
}

export interface GamingTimeSlotWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  gamingSession?: GamingSessionWhereInput;
  gamers_every?: UserWhereInput;
  gamers_some?: UserWhereInput;
  gamers_none?: UserWhereInput;
  bookings_every?: BookingWhereInput;
  bookings_some?: BookingWhereInput;
  bookings_none?: BookingWhereInput;
  players_every?: BookedPlayerWhereInput;
  players_some?: BookedPlayerWhereInput;
  players_none?: BookedPlayerWhereInput;
  length?: Int;
  length_not?: Int;
  length_in?: Int[] | Int;
  length_not_in?: Int[] | Int;
  length_lt?: Int;
  length_lte?: Int;
  length_gt?: Int;
  length_gte?: Int;
  slots?: Int;
  slots_not?: Int;
  slots_in?: Int[] | Int;
  slots_not_in?: Int[] | Int;
  slots_lt?: Int;
  slots_lte?: Int;
  slots_gt?: Int;
  slots_gte?: Int;
  AND?: GamingTimeSlotWhereInput[] | GamingTimeSlotWhereInput;
  OR?: GamingTimeSlotWhereInput[] | GamingTimeSlotWhereInput;
  NOT?: GamingTimeSlotWhereInput[] | GamingTimeSlotWhereInput;
}

export interface GamingTimeSlotUpdateWithWhereUniqueWithoutGamersInput {
  where: GamingTimeSlotWhereUniqueInput;
  data: GamingTimeSlotUpdateWithoutGamersDataInput;
}

export interface NotificationUpdateManyMutationInput {
  type?: NotificationType;
  text?: String;
  viewed?: Boolean;
}

export interface GamingTimeSlotUpdateWithoutGamersDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  gamingSession?: GamingSessionUpdateOneRequiredWithoutTimeslotsInput;
  bookings?: BookingUpdateManyWithoutTimeslotInput;
  players?: BookedPlayerUpdateManyWithoutTimeslotInput;
  length?: Int;
  slots?: Int;
}

export type GamerTagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GamingSessionUpdateOneRequiredWithoutTimeslotsInput {
  create?: GamingSessionCreateWithoutTimeslotsInput;
  update?: GamingSessionUpdateWithoutTimeslotsDataInput;
  upsert?: GamingSessionUpsertWithoutTimeslotsInput;
  connect?: GamingSessionWhereUniqueInput;
}

export interface GamingTimeSlotUpdateManyMutationInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  length?: Int;
  slots?: Int;
}

export interface GamingSessionUpdateWithoutTimeslotsDataInput {
  gamers?: UserUpdateManyWithoutSessionsInput;
  creator?: UserUpdateOneRequiredInput;
  game?: GameUpdateOneRequiredWithoutSessionsInput;
  title?: String;
  length?: Int;
  price?: Float;
  reviews?: SessionReviewUpdateManyWithoutSessionInput;
  system?: System;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
}

export type GamingSessionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GameUpdateOneRequiredWithoutSessionsInput {
  create?: GameCreateWithoutSessionsInput;
  update?: GameUpdateWithoutSessionsDataInput;
  upsert?: GameUpsertWithoutSessionsInput;
  connect?: GameWhereUniqueInput;
}

export interface GamingSessionIndexUpdateManyMutationInput {
  title?: String;
}

export interface GameUpdateWithoutSessionsDataInput {
  name?: String;
  tags?: GameUpdatetagsInput;
  launcher?: Launcher;
  numSessions?: Int;
}

export type GamingSessionIndexWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GameUpsertWithoutSessionsInput {
  update: GameUpdateWithoutSessionsDataInput;
  create: GameCreateWithoutSessionsInput;
}

export interface GamingSessionIndexWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  gamingSession?: GamingSessionWhereInput;
  AND?: GamingSessionIndexWhereInput[] | GamingSessionIndexWhereInput;
  OR?: GamingSessionIndexWhereInput[] | GamingSessionIndexWhereInput;
  NOT?: GamingSessionIndexWhereInput[] | GamingSessionIndexWhereInput;
}

export interface SessionReviewUpdateManyWithoutSessionInput {
  create?:
    | SessionReviewCreateWithoutSessionInput[]
    | SessionReviewCreateWithoutSessionInput;
  delete?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  connect?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  set?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  disconnect?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  update?:
    | SessionReviewUpdateWithWhereUniqueWithoutSessionInput[]
    | SessionReviewUpdateWithWhereUniqueWithoutSessionInput;
  upsert?:
    | SessionReviewUpsertWithWhereUniqueWithoutSessionInput[]
    | SessionReviewUpsertWithWhereUniqueWithoutSessionInput;
  deleteMany?: SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput;
  updateMany?:
    | SessionReviewUpdateManyWithWhereNestedInput[]
    | SessionReviewUpdateManyWithWhereNestedInput;
}

export interface GamingSessionUpdateOneRequiredInput {
  create?: GamingSessionCreateInput;
  update?: GamingSessionUpdateDataInput;
  upsert?: GamingSessionUpsertNestedInput;
  connect?: GamingSessionWhereUniqueInput;
}

export interface SessionReviewUpdateWithWhereUniqueWithoutSessionInput {
  where: SessionReviewWhereUniqueInput;
  data: SessionReviewUpdateWithoutSessionDataInput;
}

export interface GamingSessionCreateOneInput {
  create?: GamingSessionCreateInput;
  connect?: GamingSessionWhereUniqueInput;
}

export interface SessionReviewUpdateWithoutSessionDataInput {
  user?: UserUpdateOneRequiredWithoutReviewsInput;
  text?: String;
  rating?: Int;
}

export interface GamingSessionIndexCreateInput {
  title: String;
  gamingSession: GamingSessionCreateOneInput;
}

export interface UserUpdateOneRequiredWithoutReviewsInput {
  create?: UserCreateWithoutReviewsInput;
  update?: UserUpdateWithoutReviewsDataInput;
  upsert?: UserUpsertWithoutReviewsInput;
  connect?: UserWhereUniqueInput;
}

export interface GamingSessionUpdateInput {
  gamers?: UserUpdateManyWithoutSessionsInput;
  creator?: UserUpdateOneRequiredInput;
  game?: GameUpdateOneRequiredWithoutSessionsInput;
  title?: String;
  length?: Int;
  price?: Float;
  reviews?: SessionReviewUpdateManyWithoutSessionInput;
  system?: System;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
  timeslots?: GamingTimeSlotUpdateManyWithoutGamingSessionInput;
}

export interface UserUpdateWithoutReviewsDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  sessions?: GamingSessionUpdateManyWithoutGamersInput;
  timeSlots?: GamingTimeSlotUpdateManyWithoutGamersInput;
  timeSlotsBooked?: BookingUpdateManyWithoutPlayersInput;
  invites?: BookingInviteUpdateManyWithoutFromInput;
  invitesReceived?: BookingInviteUpdateManyWithoutToInput;
  setup?: Int;
  friends?: UserUpdateManyInput;
  gamertags?: GamerTagUpdateManyInput;
}

export interface GamingSessionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  gamers_every?: UserWhereInput;
  gamers_some?: UserWhereInput;
  gamers_none?: UserWhereInput;
  creator?: UserWhereInput;
  game?: GameWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  length?: Int;
  length_not?: Int;
  length_in?: Int[] | Int;
  length_not_in?: Int[] | Int;
  length_lt?: Int;
  length_lte?: Int;
  length_gt?: Int;
  length_gte?: Int;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  reviews_every?: SessionReviewWhereInput;
  reviews_some?: SessionReviewWhereInput;
  reviews_none?: SessionReviewWhereInput;
  system?: System;
  system_not?: System;
  system_in?: System[] | System;
  system_not_in?: System[] | System;
  type?: TypeOfGame;
  type_not?: TypeOfGame;
  type_in?: TypeOfGame[] | TypeOfGame;
  type_not_in?: TypeOfGame[] | TypeOfGame;
  slots?: Int;
  slots_not?: Int;
  slots_in?: Int[] | Int;
  slots_not_in?: Int[] | Int;
  slots_lt?: Int;
  slots_lte?: Int;
  slots_gt?: Int;
  slots_gte?: Int;
  requirements_every?: RequirementWhereInput;
  requirements_some?: RequirementWhereInput;
  requirements_none?: RequirementWhereInput;
  discounts_every?: DiscountWhereInput;
  discounts_some?: DiscountWhereInput;
  discounts_none?: DiscountWhereInput;
  timeslots_every?: GamingTimeSlotWhereInput;
  timeslots_some?: GamingTimeSlotWhereInput;
  timeslots_none?: GamingTimeSlotWhereInput;
  AND?: GamingSessionWhereInput[] | GamingSessionWhereInput;
  OR?: GamingSessionWhereInput[] | GamingSessionWhereInput;
  NOT?: GamingSessionWhereInput[] | GamingSessionWhereInput;
}

export interface GamingSessionUpdateManyWithoutGamersInput {
  create?:
    | GamingSessionCreateWithoutGamersInput[]
    | GamingSessionCreateWithoutGamersInput;
  delete?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  connect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  set?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  disconnect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
  update?:
    | GamingSessionUpdateWithWhereUniqueWithoutGamersInput[]
    | GamingSessionUpdateWithWhereUniqueWithoutGamersInput;
  upsert?:
    | GamingSessionUpsertWithWhereUniqueWithoutGamersInput[]
    | GamingSessionUpsertWithWhereUniqueWithoutGamersInput;
  deleteMany?: GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput;
  updateMany?:
    | GamingSessionUpdateManyWithWhereNestedInput[]
    | GamingSessionUpdateManyWithWhereNestedInput;
}

export interface GamerTagUpdateManyMutationInput {
  psn?: String;
  xbl?: String;
  nso?: String;
}

export interface GamingSessionUpdateWithWhereUniqueWithoutGamersInput {
  where: GamingSessionWhereUniqueInput;
  data: GamingSessionUpdateWithoutGamersDataInput;
}

export type PCLauncherWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GamingSessionUpdateWithoutGamersDataInput {
  creator?: UserUpdateOneRequiredInput;
  game?: GameUpdateOneRequiredWithoutSessionsInput;
  title?: String;
  length?: Int;
  price?: Float;
  reviews?: SessionReviewUpdateManyWithoutSessionInput;
  system?: System;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
  timeslots?: GamingTimeSlotUpdateManyWithoutGamingSessionInput;
}

export interface GamerRequestUpdateManyMutationInput {
  occupations?: GamerRequestUpdateoccupationsInput;
  addToOccupations?: String;
}

export interface RequirementUpdateManyInput {
  create?: RequirementCreateInput[] | RequirementCreateInput;
  deleteMany?: RequirementScalarWhereInput[] | RequirementScalarWhereInput;
  updateMany?:
    | RequirementUpdateManyWithWhereNestedInput[]
    | RequirementUpdateManyWithWhereNestedInput;
}

export interface SocialMediaUpdateDataInput {
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface RequirementScalarWhereInput {
  msg?: String;
  msg_not?: String;
  msg_in?: String[] | String;
  msg_not_in?: String[] | String;
  msg_lt?: String;
  msg_lte?: String;
  msg_gt?: String;
  msg_gte?: String;
  msg_contains?: String;
  msg_not_contains?: String;
  msg_starts_with?: String;
  msg_not_starts_with?: String;
  msg_ends_with?: String;
  msg_not_ends_with?: String;
  AND?: RequirementScalarWhereInput[] | RequirementScalarWhereInput;
  OR?: RequirementScalarWhereInput[] | RequirementScalarWhereInput;
  NOT?: RequirementScalarWhereInput[] | RequirementScalarWhereInput;
}

export interface GamerRequestUpdateoccupationsInput {
  set?: Occupations[] | Occupations;
}

export interface RequirementUpdateManyWithWhereNestedInput {
  where: RequirementScalarWhereInput;
  data: RequirementUpdateManyDataInput;
}

export type SessionReviewWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FriendRequestUpdateInput {
  to?: UserUpdateOneRequiredInput;
  from?: UserUpdateOneRequiredInput;
  notification?: NotificationUpdateOneRequiredWithoutFriendRequestInput;
}

export interface SocialMediaCreateOneInput {
  create?: SocialMediaCreateInput;
  connect?: SocialMediaWhereUniqueInput;
}

export interface DiscountUpdateManyInput {
  create?: DiscountCreateInput[] | DiscountCreateInput;
  deleteMany?: DiscountScalarWhereInput[] | DiscountScalarWhereInput;
  updateMany?:
    | DiscountUpdateManyWithWhereNestedInput[]
    | DiscountUpdateManyWithWhereNestedInput;
}

export type SessionReviewIndexWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DiscountScalarWhereInput {
  percentage?: Int;
  percentage_not?: Int;
  percentage_in?: Int[] | Int;
  percentage_not_in?: Int[] | Int;
  percentage_lt?: Int;
  percentage_lte?: Int;
  percentage_gt?: Int;
  percentage_gte?: Int;
  threshold?: Int;
  threshold_not?: Int;
  threshold_in?: Int[] | Int;
  threshold_not_in?: Int[] | Int;
  threshold_lt?: Int;
  threshold_lte?: Int;
  threshold_gt?: Int;
  threshold_gte?: Int;
  playerOrSession?: PlayerOrSession;
  playerOrSession_not?: PlayerOrSession;
  playerOrSession_in?: PlayerOrSession[] | PlayerOrSession;
  playerOrSession_not_in?: PlayerOrSession[] | PlayerOrSession;
  AND?: DiscountScalarWhereInput[] | DiscountScalarWhereInput;
  OR?: DiscountScalarWhereInput[] | DiscountScalarWhereInput;
  NOT?: DiscountScalarWhereInput[] | DiscountScalarWhereInput;
}

export interface SessionReviewIndexWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  sessionReview?: SessionReviewWhereInput;
  AND?: SessionReviewIndexWhereInput[] | SessionReviewIndexWhereInput;
  OR?: SessionReviewIndexWhereInput[] | SessionReviewIndexWhereInput;
  NOT?: SessionReviewIndexWhereInput[] | SessionReviewIndexWhereInput;
}

export interface DiscountUpdateManyWithWhereNestedInput {
  where: DiscountScalarWhereInput;
  data: DiscountUpdateManyDataInput;
}

export interface GameUpsertNestedInput {
  update: GameUpdateDataInput;
  create: GameCreateInput;
}

export interface DiscountUpdateManyDataInput {
  percentage?: Int;
  threshold?: Int;
  playerOrSession?: PlayerOrSession;
}

export interface GameIndexUpdatetagsInput {
  set?: String[] | String;
}

export interface GamingTimeSlotUpdateManyWithoutGamingSessionInput {
  create?:
    | GamingTimeSlotCreateWithoutGamingSessionInput[]
    | GamingTimeSlotCreateWithoutGamingSessionInput;
  delete?: GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput;
  connect?: GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput;
  set?: GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput;
  disconnect?:
    | GamingTimeSlotWhereUniqueInput[]
    | GamingTimeSlotWhereUniqueInput;
  update?:
    | GamingTimeSlotUpdateWithWhereUniqueWithoutGamingSessionInput[]
    | GamingTimeSlotUpdateWithWhereUniqueWithoutGamingSessionInput;
  upsert?:
    | GamingTimeSlotUpsertWithWhereUniqueWithoutGamingSessionInput[]
    | GamingTimeSlotUpsertWithWhereUniqueWithoutGamingSessionInput;
  deleteMany?:
    | GamingTimeSlotScalarWhereInput[]
    | GamingTimeSlotScalarWhereInput;
  updateMany?:
    | GamingTimeSlotUpdateManyWithWhereNestedInput[]
    | GamingTimeSlotUpdateManyWithWhereNestedInput;
}

export interface GameIndexUpdateInput {
  name?: String;
  tags?: GameIndexUpdatetagsInput;
  game?: GameUpdateOneRequiredInput;
}

export interface GamingTimeSlotUpdateWithWhereUniqueWithoutGamingSessionInput {
  where: GamingTimeSlotWhereUniqueInput;
  data: GamingTimeSlotUpdateWithoutGamingSessionDataInput;
}

export interface GameIndexCreatetagsInput {
  set?: String[] | String;
}

export interface GamingTimeSlotUpdateWithoutGamingSessionDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  gamers?: UserUpdateManyWithoutTimeSlotsInput;
  bookings?: BookingUpdateManyWithoutTimeslotInput;
  players?: BookedPlayerUpdateManyWithoutTimeslotInput;
  length?: Int;
  slots?: Int;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  username?: String;
}>;

export interface UserUpdateManyWithoutTimeSlotsInput {
  create?: UserCreateWithoutTimeSlotsInput[] | UserCreateWithoutTimeSlotsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutTimeSlotsInput[]
    | UserUpdateWithWhereUniqueWithoutTimeSlotsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutTimeSlotsInput[]
    | UserUpsertWithWhereUniqueWithoutTimeSlotsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface GameUpdateInput {
  name?: String;
  tags?: GameUpdatetagsInput;
  sessions?: GamingSessionUpdateManyWithoutGameInput;
  launcher?: Launcher;
  numSessions?: Int;
}

export interface UserUpdateWithWhereUniqueWithoutTimeSlotsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTimeSlotsDataInput;
}

export type UserIndexWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  username?: String;
}>;

export interface UserUpdateWithoutTimeSlotsDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  sessions?: GamingSessionUpdateManyWithoutGamersInput;
  timeSlotsBooked?: BookingUpdateManyWithoutPlayersInput;
  invites?: BookingInviteUpdateManyWithoutFromInput;
  invitesReceived?: BookingInviteUpdateManyWithoutToInput;
  setup?: Int;
  reviews?: SessionReviewUpdateManyWithoutUserInput;
  friends?: UserUpdateManyInput;
  gamertags?: GamerTagUpdateManyInput;
}

export interface UserIndexWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  user?: UserWhereInput;
  AND?: UserIndexWhereInput[] | UserIndexWhereInput;
  OR?: UserIndexWhereInput[] | UserIndexWhereInput;
  NOT?: UserIndexWhereInput[] | UserIndexWhereInput;
}

export interface BookingUpdateManyWithoutPlayersInput {
  create?:
    | BookingCreateWithoutPlayersInput[]
    | BookingCreateWithoutPlayersInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  set?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutPlayersInput[]
    | BookingUpdateWithWhereUniqueWithoutPlayersInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutPlayersInput[]
    | BookingUpsertWithWhereUniqueWithoutPlayersInput;
  deleteMany?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  updateMany?:
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput;
}

export interface BookingInviteUpdateOneWithoutNotificationInput {
  create?: BookingInviteCreateWithoutNotificationInput;
  update?: BookingInviteUpdateWithoutNotificationDataInput;
  upsert?: BookingInviteUpsertWithoutNotificationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BookingInviteWhereUniqueInput;
}

export interface BookingUpdateWithWhereUniqueWithoutPlayersInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutPlayersDataInput;
}

export interface NotificationUpdateOneRequiredWithoutFriendRequestInput {
  create?: NotificationCreateWithoutFriendRequestInput;
  update?: NotificationUpdateWithoutFriendRequestDataInput;
  upsert?: NotificationUpsertWithoutFriendRequestInput;
  connect?: NotificationWhereUniqueInput;
}

export interface BookingUpdateWithoutPlayersDataInput {
  numSlots?: Int;
  numPlayers?: Int;
  total?: Float;
  timeslot?: GamingTimeSlotUpdateOneRequiredWithoutBookingsInput;
  invites?: BookingInviteUpdateManyWithoutBookingInput;
  cancelled?: Boolean;
}

export interface BookedPlayerCreateInput {
  player: UserCreateOneInput;
  timeslot: GamingTimeSlotCreateOneWithoutPlayersInput;
}

export interface GamingTimeSlotUpdateOneRequiredWithoutBookingsInput {
  create?: GamingTimeSlotCreateWithoutBookingsInput;
  update?: GamingTimeSlotUpdateWithoutBookingsDataInput;
  upsert?: GamingTimeSlotUpsertWithoutBookingsInput;
  connect?: GamingTimeSlotWhereUniqueInput;
}

export interface UserCreateInput {
  email: String;
  username: String;
  password: String;
  isGamer?: Boolean;
  occupations?: UserCreateoccupationsInput;
  name: String;
  aboutMe?: String;
  favoriteGames?: GameCreateManyInput;
  sessions?: GamingSessionCreateManyWithoutGamersInput;
  timeSlots?: GamingTimeSlotCreateManyWithoutGamersInput;
  timeSlotsBooked?: BookingCreateManyWithoutPlayersInput;
  invites?: BookingInviteCreateManyWithoutFromInput;
  invitesReceived?: BookingInviteCreateManyWithoutToInput;
  setup?: Int;
  reviews?: SessionReviewCreateManyWithoutUserInput;
  friends?: UserCreateManyInput;
  gamertags?: GamerTagCreateManyInput;
}

export interface DiscountWhereInput {
  percentage?: Int;
  percentage_not?: Int;
  percentage_in?: Int[] | Int;
  percentage_not_in?: Int[] | Int;
  percentage_lt?: Int;
  percentage_lte?: Int;
  percentage_gt?: Int;
  percentage_gte?: Int;
  threshold?: Int;
  threshold_not?: Int;
  threshold_in?: Int[] | Int;
  threshold_not_in?: Int[] | Int;
  threshold_lt?: Int;
  threshold_lte?: Int;
  threshold_gt?: Int;
  threshold_gte?: Int;
  playerOrSession?: PlayerOrSession;
  playerOrSession_not?: PlayerOrSession;
  playerOrSession_in?: PlayerOrSession[] | PlayerOrSession;
  playerOrSession_not_in?: PlayerOrSession[] | PlayerOrSession;
  AND?: DiscountWhereInput[] | DiscountWhereInput;
  OR?: DiscountWhereInput[] | DiscountWhereInput;
  NOT?: DiscountWhereInput[] | DiscountWhereInput;
}

export interface GameCreateManyInput {
  create?: GameCreateInput[] | GameCreateInput;
  connect?: GameWhereUniqueInput[] | GameWhereUniqueInput;
}

export interface BookedPlayerUpdateManyWithoutTimeslotInput {
  create?:
    | BookedPlayerCreateWithoutTimeslotInput[]
    | BookedPlayerCreateWithoutTimeslotInput;
  delete?: BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput;
  connect?: BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput;
  set?: BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput;
  disconnect?: BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput;
  update?:
    | BookedPlayerUpdateWithWhereUniqueWithoutTimeslotInput[]
    | BookedPlayerUpdateWithWhereUniqueWithoutTimeslotInput;
  upsert?:
    | BookedPlayerUpsertWithWhereUniqueWithoutTimeslotInput[]
    | BookedPlayerUpsertWithWhereUniqueWithoutTimeslotInput;
  deleteMany?: BookedPlayerScalarWhereInput[] | BookedPlayerScalarWhereInput;
}

export interface GameCreatetagsInput {
  set?: Tags[] | Tags;
}

export interface BookedPlayerUpdateWithWhereUniqueWithoutTimeslotInput {
  where: BookedPlayerWhereUniqueInput;
  data: BookedPlayerUpdateWithoutTimeslotDataInput;
}

export interface GamingSessionCreateWithoutGameInput {
  gamers?: UserCreateManyWithoutSessionsInput;
  creator: UserCreateOneInput;
  title: String;
  length: Int;
  price: Float;
  reviews?: SessionReviewCreateManyWithoutSessionInput;
  system: System;
  type: TypeOfGame;
  slots: Int;
  requirements?: RequirementCreateManyInput;
  discounts?: DiscountCreateManyInput;
  timeslots?: GamingTimeSlotCreateManyWithoutGamingSessionInput;
}

export interface BookedPlayerUpdateWithoutTimeslotDataInput {
  player?: UserUpdateOneRequiredInput;
}

export interface UserCreateWithoutSessionsInput {
  email: String;
  username: String;
  password: String;
  isGamer?: Boolean;
  occupations?: UserCreateoccupationsInput;
  name: String;
  aboutMe?: String;
  favoriteGames?: GameCreateManyInput;
  timeSlots?: GamingTimeSlotCreateManyWithoutGamersInput;
  timeSlotsBooked?: BookingCreateManyWithoutPlayersInput;
  invites?: BookingInviteCreateManyWithoutFromInput;
  invitesReceived?: BookingInviteCreateManyWithoutToInput;
  setup?: Int;
  reviews?: SessionReviewCreateManyWithoutUserInput;
  friends?: UserCreateManyInput;
  gamertags?: GamerTagCreateManyInput;
}

export interface BookedPlayerUpsertWithWhereUniqueWithoutTimeslotInput {
  where: BookedPlayerWhereUniqueInput;
  update: BookedPlayerUpdateWithoutTimeslotDataInput;
  create: BookedPlayerCreateWithoutTimeslotInput;
}

export interface GamingTimeSlotCreateWithoutGamersInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamingSession: GamingSessionCreateOneWithoutTimeslotsInput;
  bookings?: BookingCreateManyWithoutTimeslotInput;
  players?: BookedPlayerCreateManyWithoutTimeslotInput;
  length: Int;
  slots: Int;
}

export interface BookedPlayerScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: BookedPlayerScalarWhereInput[] | BookedPlayerScalarWhereInput;
  OR?: BookedPlayerScalarWhereInput[] | BookedPlayerScalarWhereInput;
  NOT?: BookedPlayerScalarWhereInput[] | BookedPlayerScalarWhereInput;
}

export interface GamingSessionCreateWithoutTimeslotsInput {
  gamers?: UserCreateManyWithoutSessionsInput;
  creator: UserCreateOneInput;
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  reviews?: SessionReviewCreateManyWithoutSessionInput;
  system: System;
  type: TypeOfGame;
  slots: Int;
  requirements?: RequirementCreateManyInput;
  discounts?: DiscountCreateManyInput;
}

export interface GamingTimeSlotUpsertWithoutBookingsInput {
  update: GamingTimeSlotUpdateWithoutBookingsDataInput;
  create: GamingTimeSlotCreateWithoutBookingsInput;
}

export interface GameCreateWithoutSessionsInput {
  name: String;
  tags?: GameCreatetagsInput;
  launcher?: Launcher;
  numSessions?: Int;
}

export interface BookingInviteUpdateManyWithoutBookingInput {
  create?:
    | BookingInviteCreateWithoutBookingInput[]
    | BookingInviteCreateWithoutBookingInput;
  delete?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  connect?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  set?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  disconnect?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  update?:
    | BookingInviteUpdateWithWhereUniqueWithoutBookingInput[]
    | BookingInviteUpdateWithWhereUniqueWithoutBookingInput;
  upsert?:
    | BookingInviteUpsertWithWhereUniqueWithoutBookingInput[]
    | BookingInviteUpsertWithWhereUniqueWithoutBookingInput;
  deleteMany?: BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput;
  updateMany?:
    | BookingInviteUpdateManyWithWhereNestedInput[]
    | BookingInviteUpdateManyWithWhereNestedInput;
}

export interface SessionReviewCreateWithoutSessionInput {
  user: UserCreateOneWithoutReviewsInput;
  text: String;
  rating: Int;
}

export interface BookingInviteUpdateWithWhereUniqueWithoutBookingInput {
  where: BookingInviteWhereUniqueInput;
  data: BookingInviteUpdateWithoutBookingDataInput;
}

export interface UserCreateWithoutReviewsInput {
  email: String;
  username: String;
  password: String;
  isGamer?: Boolean;
  occupations?: UserCreateoccupationsInput;
  name: String;
  aboutMe?: String;
  favoriteGames?: GameCreateManyInput;
  sessions?: GamingSessionCreateManyWithoutGamersInput;
  timeSlots?: GamingTimeSlotCreateManyWithoutGamersInput;
  timeSlotsBooked?: BookingCreateManyWithoutPlayersInput;
  invites?: BookingInviteCreateManyWithoutFromInput;
  invitesReceived?: BookingInviteCreateManyWithoutToInput;
  setup?: Int;
  friends?: UserCreateManyInput;
  gamertags?: GamerTagCreateManyInput;
}

export interface BookingInviteUpdateWithoutBookingDataInput {
  startTime?: DateTimeInput;
  to?: UserUpdateOneWithoutInvitesReceivedInput;
  from?: UserUpdateOneRequiredWithoutInvitesInput;
  sent?: Boolean;
  accepted?: Boolean;
  notification?: NotificationUpdateOneWithoutBookingInviteInput;
}

export interface GamingSessionCreateWithoutGamersInput {
  creator: UserCreateOneInput;
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  reviews?: SessionReviewCreateManyWithoutSessionInput;
  system: System;
  type: TypeOfGame;
  slots: Int;
  requirements?: RequirementCreateManyInput;
  discounts?: DiscountCreateManyInput;
  timeslots?: GamingTimeSlotCreateManyWithoutGamingSessionInput;
}

export interface UserUpdateOneWithoutInvitesReceivedInput {
  create?: UserCreateWithoutInvitesReceivedInput;
  update?: UserUpdateWithoutInvitesReceivedDataInput;
  upsert?: UserUpsertWithoutInvitesReceivedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface RequirementCreateInput {
  msg: String;
}

export interface UserUpdateWithoutInvitesReceivedDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  sessions?: GamingSessionUpdateManyWithoutGamersInput;
  timeSlots?: GamingTimeSlotUpdateManyWithoutGamersInput;
  timeSlotsBooked?: BookingUpdateManyWithoutPlayersInput;
  invites?: BookingInviteUpdateManyWithoutFromInput;
  setup?: Int;
  reviews?: SessionReviewUpdateManyWithoutUserInput;
  friends?: UserUpdateManyInput;
  gamertags?: GamerTagUpdateManyInput;
}

export interface DiscountCreateInput {
  percentage: Int;
  threshold: Int;
  playerOrSession: PlayerOrSession;
}

export interface BookingInviteUpdateManyWithoutFromInput {
  create?:
    | BookingInviteCreateWithoutFromInput[]
    | BookingInviteCreateWithoutFromInput;
  delete?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  connect?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  set?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  disconnect?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  update?:
    | BookingInviteUpdateWithWhereUniqueWithoutFromInput[]
    | BookingInviteUpdateWithWhereUniqueWithoutFromInput;
  upsert?:
    | BookingInviteUpsertWithWhereUniqueWithoutFromInput[]
    | BookingInviteUpsertWithWhereUniqueWithoutFromInput;
  deleteMany?: BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput;
  updateMany?:
    | BookingInviteUpdateManyWithWhereNestedInput[]
    | BookingInviteUpdateManyWithWhereNestedInput;
}

export interface GamingTimeSlotCreateWithoutGamingSessionInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamers?: UserCreateManyWithoutTimeSlotsInput;
  bookings?: BookingCreateManyWithoutTimeslotInput;
  players?: BookedPlayerCreateManyWithoutTimeslotInput;
  length: Int;
  slots: Int;
}

export interface BookingInviteUpdateWithWhereUniqueWithoutFromInput {
  where: BookingInviteWhereUniqueInput;
  data: BookingInviteUpdateWithoutFromDataInput;
}

export interface UserCreateWithoutTimeSlotsInput {
  email: String;
  username: String;
  password: String;
  isGamer?: Boolean;
  occupations?: UserCreateoccupationsInput;
  name: String;
  aboutMe?: String;
  favoriteGames?: GameCreateManyInput;
  sessions?: GamingSessionCreateManyWithoutGamersInput;
  timeSlotsBooked?: BookingCreateManyWithoutPlayersInput;
  invites?: BookingInviteCreateManyWithoutFromInput;
  invitesReceived?: BookingInviteCreateManyWithoutToInput;
  setup?: Int;
  reviews?: SessionReviewCreateManyWithoutUserInput;
  friends?: UserCreateManyInput;
  gamertags?: GamerTagCreateManyInput;
}

export interface BookingInviteUpdateWithoutFromDataInput {
  startTime?: DateTimeInput;
  booking?: BookingUpdateOneRequiredWithoutInvitesInput;
  to?: UserUpdateOneWithoutInvitesReceivedInput;
  sent?: Boolean;
  accepted?: Boolean;
  notification?: NotificationUpdateOneWithoutBookingInviteInput;
}

export interface BookingCreateWithoutPlayersInput {
  numSlots: Int;
  numPlayers: Int;
  total: Float;
  timeslot: GamingTimeSlotCreateOneWithoutBookingsInput;
  invites?: BookingInviteCreateManyWithoutBookingInput;
  cancelled?: Boolean;
}

export interface BookingUpdateOneRequiredWithoutInvitesInput {
  create?: BookingCreateWithoutInvitesInput;
  update?: BookingUpdateWithoutInvitesDataInput;
  upsert?: BookingUpsertWithoutInvitesInput;
  connect?: BookingWhereUniqueInput;
}

export interface GamingTimeSlotCreateWithoutBookingsInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamingSession: GamingSessionCreateOneWithoutTimeslotsInput;
  gamers?: UserCreateManyWithoutTimeSlotsInput;
  players?: BookedPlayerCreateManyWithoutTimeslotInput;
  length: Int;
  slots: Int;
}

export interface BookingUpdateWithoutInvitesDataInput {
  numSlots?: Int;
  numPlayers?: Int;
  players?: UserUpdateManyWithoutTimeSlotsBookedInput;
  total?: Float;
  timeslot?: GamingTimeSlotUpdateOneRequiredWithoutBookingsInput;
  cancelled?: Boolean;
}

export interface BookedPlayerCreateWithoutTimeslotInput {
  player: UserCreateOneInput;
}

export interface UserUpdateManyWithoutTimeSlotsBookedInput {
  create?:
    | UserCreateWithoutTimeSlotsBookedInput[]
    | UserCreateWithoutTimeSlotsBookedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutTimeSlotsBookedInput[]
    | UserUpdateWithWhereUniqueWithoutTimeSlotsBookedInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutTimeSlotsBookedInput[]
    | UserUpsertWithWhereUniqueWithoutTimeSlotsBookedInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface BookingInviteCreateWithoutBookingInput {
  startTime: DateTimeInput;
  to?: UserCreateOneWithoutInvitesReceivedInput;
  from: UserCreateOneWithoutInvitesInput;
  sent: Boolean;
  accepted?: Boolean;
  notification?: NotificationCreateOneWithoutBookingInviteInput;
}

export interface UserUpdateWithWhereUniqueWithoutTimeSlotsBookedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTimeSlotsBookedDataInput;
}

export interface UserCreateWithoutInvitesReceivedInput {
  email: String;
  username: String;
  password: String;
  isGamer?: Boolean;
  occupations?: UserCreateoccupationsInput;
  name: String;
  aboutMe?: String;
  favoriteGames?: GameCreateManyInput;
  sessions?: GamingSessionCreateManyWithoutGamersInput;
  timeSlots?: GamingTimeSlotCreateManyWithoutGamersInput;
  timeSlotsBooked?: BookingCreateManyWithoutPlayersInput;
  invites?: BookingInviteCreateManyWithoutFromInput;
  setup?: Int;
  reviews?: SessionReviewCreateManyWithoutUserInput;
  friends?: UserCreateManyInput;
  gamertags?: GamerTagCreateManyInput;
}

export interface UserUpdateWithoutTimeSlotsBookedDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  sessions?: GamingSessionUpdateManyWithoutGamersInput;
  timeSlots?: GamingTimeSlotUpdateManyWithoutGamersInput;
  invites?: BookingInviteUpdateManyWithoutFromInput;
  invitesReceived?: BookingInviteUpdateManyWithoutToInput;
  setup?: Int;
  reviews?: SessionReviewUpdateManyWithoutUserInput;
  friends?: UserUpdateManyInput;
  gamertags?: GamerTagUpdateManyInput;
}

export interface BookingInviteCreateWithoutFromInput {
  startTime: DateTimeInput;
  booking: BookingCreateOneWithoutInvitesInput;
  to?: UserCreateOneWithoutInvitesReceivedInput;
  sent: Boolean;
  accepted?: Boolean;
  notification?: NotificationCreateOneWithoutBookingInviteInput;
}

export interface BookingInviteUpdateManyWithoutToInput {
  create?:
    | BookingInviteCreateWithoutToInput[]
    | BookingInviteCreateWithoutToInput;
  delete?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  connect?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  set?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  disconnect?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
  update?:
    | BookingInviteUpdateWithWhereUniqueWithoutToInput[]
    | BookingInviteUpdateWithWhereUniqueWithoutToInput;
  upsert?:
    | BookingInviteUpsertWithWhereUniqueWithoutToInput[]
    | BookingInviteUpsertWithWhereUniqueWithoutToInput;
  deleteMany?: BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput;
  updateMany?:
    | BookingInviteUpdateManyWithWhereNestedInput[]
    | BookingInviteUpdateManyWithWhereNestedInput;
}

export interface BookingCreateWithoutInvitesInput {
  numSlots: Int;
  numPlayers: Int;
  players?: UserCreateManyWithoutTimeSlotsBookedInput;
  total: Float;
  timeslot: GamingTimeSlotCreateOneWithoutBookingsInput;
  cancelled?: Boolean;
}

export interface BookingInviteUpdateWithWhereUniqueWithoutToInput {
  where: BookingInviteWhereUniqueInput;
  data: BookingInviteUpdateWithoutToDataInput;
}

export interface UserCreateWithoutTimeSlotsBookedInput {
  email: String;
  username: String;
  password: String;
  isGamer?: Boolean;
  occupations?: UserCreateoccupationsInput;
  name: String;
  aboutMe?: String;
  favoriteGames?: GameCreateManyInput;
  sessions?: GamingSessionCreateManyWithoutGamersInput;
  timeSlots?: GamingTimeSlotCreateManyWithoutGamersInput;
  invites?: BookingInviteCreateManyWithoutFromInput;
  invitesReceived?: BookingInviteCreateManyWithoutToInput;
  setup?: Int;
  reviews?: SessionReviewCreateManyWithoutUserInput;
  friends?: UserCreateManyInput;
  gamertags?: GamerTagCreateManyInput;
}

export interface BookingInviteUpdateWithoutToDataInput {
  startTime?: DateTimeInput;
  booking?: BookingUpdateOneRequiredWithoutInvitesInput;
  from?: UserUpdateOneRequiredWithoutInvitesInput;
  sent?: Boolean;
  accepted?: Boolean;
  notification?: NotificationUpdateOneWithoutBookingInviteInput;
}

export interface BookingInviteCreateWithoutToInput {
  startTime: DateTimeInput;
  booking: BookingCreateOneWithoutInvitesInput;
  from: UserCreateOneWithoutInvitesInput;
  sent: Boolean;
  accepted?: Boolean;
  notification?: NotificationCreateOneWithoutBookingInviteInput;
}

export interface UserUpdateOneRequiredWithoutInvitesInput {
  create?: UserCreateWithoutInvitesInput;
  update?: UserUpdateWithoutInvitesDataInput;
  upsert?: UserUpsertWithoutInvitesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutInvitesInput {
  email: String;
  username: String;
  password: String;
  isGamer?: Boolean;
  occupations?: UserCreateoccupationsInput;
  name: String;
  aboutMe?: String;
  favoriteGames?: GameCreateManyInput;
  sessions?: GamingSessionCreateManyWithoutGamersInput;
  timeSlots?: GamingTimeSlotCreateManyWithoutGamersInput;
  timeSlotsBooked?: BookingCreateManyWithoutPlayersInput;
  invitesReceived?: BookingInviteCreateManyWithoutToInput;
  setup?: Int;
  reviews?: SessionReviewCreateManyWithoutUserInput;
  friends?: UserCreateManyInput;
  gamertags?: GamerTagCreateManyInput;
}

export interface UserUpdateWithoutInvitesDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  sessions?: GamingSessionUpdateManyWithoutGamersInput;
  timeSlots?: GamingTimeSlotUpdateManyWithoutGamersInput;
  timeSlotsBooked?: BookingUpdateManyWithoutPlayersInput;
  invitesReceived?: BookingInviteUpdateManyWithoutToInput;
  setup?: Int;
  reviews?: SessionReviewUpdateManyWithoutUserInput;
  friends?: UserUpdateManyInput;
  gamertags?: GamerTagUpdateManyInput;
}

export interface SessionReviewCreateWithoutUserInput {
  session: GamingSessionCreateOneWithoutReviewsInput;
  text: String;
  rating: Int;
}

export interface SessionReviewUpdateManyWithoutUserInput {
  create?:
    | SessionReviewCreateWithoutUserInput[]
    | SessionReviewCreateWithoutUserInput;
  delete?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  connect?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  set?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  disconnect?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
  update?:
    | SessionReviewUpdateWithWhereUniqueWithoutUserInput[]
    | SessionReviewUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | SessionReviewUpsertWithWhereUniqueWithoutUserInput[]
    | SessionReviewUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput;
  updateMany?:
    | SessionReviewUpdateManyWithWhereNestedInput[]
    | SessionReviewUpdateManyWithWhereNestedInput;
}

export interface RequirementWhereInput {
  msg?: String;
  msg_not?: String;
  msg_in?: String[] | String;
  msg_not_in?: String[] | String;
  msg_lt?: String;
  msg_lte?: String;
  msg_gt?: String;
  msg_gte?: String;
  msg_contains?: String;
  msg_not_contains?: String;
  msg_starts_with?: String;
  msg_not_starts_with?: String;
  msg_ends_with?: String;
  msg_not_ends_with?: String;
  AND?: RequirementWhereInput[] | RequirementWhereInput;
  OR?: RequirementWhereInput[] | RequirementWhereInput;
  NOT?: RequirementWhereInput[] | RequirementWhereInput;
}

export interface SessionReviewUpdateWithWhereUniqueWithoutUserInput {
  where: SessionReviewWhereUniqueInput;
  data: SessionReviewUpdateWithoutUserDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface SessionReviewUpdateWithoutUserDataInput {
  session?: GamingSessionUpdateOneRequiredWithoutReviewsInput;
  text?: String;
  rating?: Int;
}

export interface SessionReviewIndexSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SessionReviewIndexWhereInput;
  AND?:
    | SessionReviewIndexSubscriptionWhereInput[]
    | SessionReviewIndexSubscriptionWhereInput;
  OR?:
    | SessionReviewIndexSubscriptionWhereInput[]
    | SessionReviewIndexSubscriptionWhereInput;
  NOT?:
    | SessionReviewIndexSubscriptionWhereInput[]
    | SessionReviewIndexSubscriptionWhereInput;
}

export interface GamingSessionUpdateOneRequiredWithoutReviewsInput {
  create?: GamingSessionCreateWithoutReviewsInput;
  update?: GamingSessionUpdateWithoutReviewsDataInput;
  upsert?: GamingSessionUpsertWithoutReviewsInput;
  connect?: GamingSessionWhereUniqueInput;
}

export interface RequirementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RequirementWhereInput;
  AND?: RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput;
  OR?: RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput;
  NOT?: RequirementSubscriptionWhereInput[] | RequirementSubscriptionWhereInput;
}

export interface GamingSessionUpdateWithoutReviewsDataInput {
  gamers?: UserUpdateManyWithoutSessionsInput;
  creator?: UserUpdateOneRequiredInput;
  game?: GameUpdateOneRequiredWithoutSessionsInput;
  title?: String;
  length?: Int;
  price?: Float;
  system?: System;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
  timeslots?: GamingTimeSlotUpdateManyWithoutGamingSessionInput;
}

export interface GamingTimeSlotSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GamingTimeSlotWhereInput;
  AND?:
    | GamingTimeSlotSubscriptionWhereInput[]
    | GamingTimeSlotSubscriptionWhereInput;
  OR?:
    | GamingTimeSlotSubscriptionWhereInput[]
    | GamingTimeSlotSubscriptionWhereInput;
  NOT?:
    | GamingTimeSlotSubscriptionWhereInput[]
    | GamingTimeSlotSubscriptionWhereInput;
}

export interface GamingSessionUpsertWithoutReviewsInput {
  update: GamingSessionUpdateWithoutReviewsDataInput;
  create: GamingSessionCreateWithoutReviewsInput;
}

export interface GamerRequestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GamerRequestWhereInput;
  AND?:
    | GamerRequestSubscriptionWhereInput[]
    | GamerRequestSubscriptionWhereInput;
  OR?:
    | GamerRequestSubscriptionWhereInput[]
    | GamerRequestSubscriptionWhereInput;
  NOT?:
    | GamerRequestSubscriptionWhereInput[]
    | GamerRequestSubscriptionWhereInput;
}

export interface SessionReviewUpsertWithWhereUniqueWithoutUserInput {
  where: SessionReviewWhereUniqueInput;
  update: SessionReviewUpdateWithoutUserDataInput;
  create: SessionReviewCreateWithoutUserInput;
}

export interface DiscountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DiscountWhereInput;
  AND?: DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput;
  OR?: DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput;
  NOT?: DiscountSubscriptionWhereInput[] | DiscountSubscriptionWhereInput;
}

export interface SessionReviewScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  rating?: Int;
  rating_not?: Int;
  rating_in?: Int[] | Int;
  rating_not_in?: Int[] | Int;
  rating_lt?: Int;
  rating_lte?: Int;
  rating_gt?: Int;
  rating_gte?: Int;
  AND?: SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput;
  OR?: SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput;
  NOT?: SessionReviewScalarWhereInput[] | SessionReviewScalarWhereInput;
}

export interface BookedPlayerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookedPlayerWhereInput;
  AND?:
    | BookedPlayerSubscriptionWhereInput[]
    | BookedPlayerSubscriptionWhereInput;
  OR?:
    | BookedPlayerSubscriptionWhereInput[]
    | BookedPlayerSubscriptionWhereInput;
  NOT?:
    | BookedPlayerSubscriptionWhereInput[]
    | BookedPlayerSubscriptionWhereInput;
}

export interface SessionReviewUpdateManyWithWhereNestedInput {
  where: SessionReviewScalarWhereInput;
  data: SessionReviewUpdateManyDataInput;
}

export interface UserIndexCreateInput {
  email: String;
  username: String;
  name: String;
  user: UserCreateOneInput;
}

export interface SessionReviewUpdateManyDataInput {
  text?: String;
  rating?: Int;
}

export type FriendRequestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface SessionReviewUpsertNestedInput {
  update: SessionReviewUpdateDataInput;
  create: SessionReviewCreateInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface SessionReviewIndexUpdateInput {
  text?: String;
  sessionReview?: SessionReviewUpdateOneRequiredInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface SessionReviewIndexCreateInput {
  text: String;
  sessionReview: SessionReviewCreateOneInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  isGamer?: Boolean;
  isGamer_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  aboutMe?: String;
  aboutMe_not?: String;
  aboutMe_in?: String[] | String;
  aboutMe_not_in?: String[] | String;
  aboutMe_lt?: String;
  aboutMe_lte?: String;
  aboutMe_gt?: String;
  aboutMe_gte?: String;
  aboutMe_contains?: String;
  aboutMe_not_contains?: String;
  aboutMe_starts_with?: String;
  aboutMe_not_starts_with?: String;
  aboutMe_ends_with?: String;
  aboutMe_not_ends_with?: String;
  setup?: Int;
  setup_not?: Int;
  setup_in?: Int[] | Int;
  setup_not_in?: Int[] | Int;
  setup_lt?: Int;
  setup_lte?: Int;
  setup_gt?: Int;
  setup_gte?: Int;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export type GamerRequestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface SocialMediaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  twitter?: String;
  twitter_not?: String;
  twitter_in?: String[] | String;
  twitter_not_in?: String[] | String;
  twitter_lt?: String;
  twitter_lte?: String;
  twitter_gt?: String;
  twitter_gte?: String;
  twitter_contains?: String;
  twitter_not_contains?: String;
  twitter_starts_with?: String;
  twitter_not_starts_with?: String;
  twitter_ends_with?: String;
  twitter_not_ends_with?: String;
  facebook?: String;
  facebook_not?: String;
  facebook_in?: String[] | String;
  facebook_not_in?: String[] | String;
  facebook_lt?: String;
  facebook_lte?: String;
  facebook_gt?: String;
  facebook_gte?: String;
  facebook_contains?: String;
  facebook_not_contains?: String;
  facebook_starts_with?: String;
  facebook_not_starts_with?: String;
  facebook_ends_with?: String;
  facebook_not_ends_with?: String;
  youtube?: String;
  youtube_not?: String;
  youtube_in?: String[] | String;
  youtube_not_in?: String[] | String;
  youtube_lt?: String;
  youtube_lte?: String;
  youtube_gt?: String;
  youtube_gte?: String;
  youtube_contains?: String;
  youtube_not_contains?: String;
  youtube_starts_with?: String;
  youtube_not_starts_with?: String;
  youtube_ends_with?: String;
  youtube_not_ends_with?: String;
  instagram?: String;
  instagram_not?: String;
  instagram_in?: String[] | String;
  instagram_not_in?: String[] | String;
  instagram_lt?: String;
  instagram_lte?: String;
  instagram_gt?: String;
  instagram_gte?: String;
  instagram_contains?: String;
  instagram_not_contains?: String;
  instagram_starts_with?: String;
  instagram_not_starts_with?: String;
  instagram_ends_with?: String;
  instagram_not_ends_with?: String;
  twitch?: String;
  twitch_not?: String;
  twitch_in?: String[] | String;
  twitch_not_in?: String[] | String;
  twitch_lt?: String;
  twitch_lte?: String;
  twitch_gt?: String;
  twitch_gte?: String;
  twitch_contains?: String;
  twitch_not_contains?: String;
  twitch_starts_with?: String;
  twitch_not_starts_with?: String;
  twitch_ends_with?: String;
  twitch_not_ends_with?: String;
  snapchat?: String;
  snapchat_not?: String;
  snapchat_in?: String[] | String;
  snapchat_not_in?: String[] | String;
  snapchat_lt?: String;
  snapchat_lte?: String;
  snapchat_gt?: String;
  snapchat_gte?: String;
  snapchat_contains?: String;
  snapchat_not_contains?: String;
  snapchat_starts_with?: String;
  snapchat_not_starts_with?: String;
  snapchat_ends_with?: String;
  snapchat_not_ends_with?: String;
  AND?: SocialMediaWhereInput[] | SocialMediaWhereInput;
  OR?: SocialMediaWhereInput[] | SocialMediaWhereInput;
  NOT?: SocialMediaWhereInput[] | SocialMediaWhereInput;
}

export interface UserUpdateManyDataInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  setup?: Int;
}

export interface NotificationUpdateInput {
  type?: NotificationType;
  text?: String;
  for?: UserUpdateOneRequiredInput;
  friendRequest?: FriendRequestUpdateOneWithoutNotificationInput;
  bookingInvite?: BookingInviteUpdateOneWithoutNotificationInput;
  booking?: BookingUpdateOneInput;
  friend?: UserUpdateOneInput;
  viewed?: Boolean;
}

export interface GamerTagUpdateManyInput {
  create?: GamerTagCreateInput[] | GamerTagCreateInput;
  update?:
    | GamerTagUpdateWithWhereUniqueNestedInput[]
    | GamerTagUpdateWithWhereUniqueNestedInput;
  upsert?:
    | GamerTagUpsertWithWhereUniqueNestedInput[]
    | GamerTagUpsertWithWhereUniqueNestedInput;
  delete?: GamerTagWhereUniqueInput[] | GamerTagWhereUniqueInput;
  connect?: GamerTagWhereUniqueInput[] | GamerTagWhereUniqueInput;
  set?: GamerTagWhereUniqueInput[] | GamerTagWhereUniqueInput;
  disconnect?: GamerTagWhereUniqueInput[] | GamerTagWhereUniqueInput;
  deleteMany?: GamerTagScalarWhereInput[] | GamerTagScalarWhereInput;
  updateMany?:
    | GamerTagUpdateManyWithWhereNestedInput[]
    | GamerTagUpdateManyWithWhereNestedInput;
}

export interface GamingTimeSlotUpdateInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  gamingSession?: GamingSessionUpdateOneRequiredWithoutTimeslotsInput;
  gamers?: UserUpdateManyWithoutTimeSlotsInput;
  bookings?: BookingUpdateManyWithoutTimeslotInput;
  players?: BookedPlayerUpdateManyWithoutTimeslotInput;
  length?: Int;
  slots?: Int;
}

export interface GamerTagUpdateWithWhereUniqueNestedInput {
  where: GamerTagWhereUniqueInput;
  data: GamerTagUpdateDataInput;
}

export interface GamingSessionUpsertNestedInput {
  update: GamingSessionUpdateDataInput;
  create: GamingSessionCreateInput;
}

export interface GamerTagUpdateDataInput {
  psn?: String;
  xbl?: String;
  nso?: String;
  pc?: PCLauncherUpdateOneInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  isGamer?: Boolean;
  isGamer_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  aboutMe?: String;
  aboutMe_not?: String;
  aboutMe_in?: String[] | String;
  aboutMe_not_in?: String[] | String;
  aboutMe_lt?: String;
  aboutMe_lte?: String;
  aboutMe_gt?: String;
  aboutMe_gte?: String;
  aboutMe_contains?: String;
  aboutMe_not_contains?: String;
  aboutMe_starts_with?: String;
  aboutMe_not_starts_with?: String;
  aboutMe_ends_with?: String;
  aboutMe_not_ends_with?: String;
  favoriteGames_every?: GameWhereInput;
  favoriteGames_some?: GameWhereInput;
  favoriteGames_none?: GameWhereInput;
  sessions_every?: GamingSessionWhereInput;
  sessions_some?: GamingSessionWhereInput;
  sessions_none?: GamingSessionWhereInput;
  timeSlots_every?: GamingTimeSlotWhereInput;
  timeSlots_some?: GamingTimeSlotWhereInput;
  timeSlots_none?: GamingTimeSlotWhereInput;
  timeSlotsBooked_every?: BookingWhereInput;
  timeSlotsBooked_some?: BookingWhereInput;
  timeSlotsBooked_none?: BookingWhereInput;
  invites_every?: BookingInviteWhereInput;
  invites_some?: BookingInviteWhereInput;
  invites_none?: BookingInviteWhereInput;
  invitesReceived_every?: BookingInviteWhereInput;
  invitesReceived_some?: BookingInviteWhereInput;
  invitesReceived_none?: BookingInviteWhereInput;
  setup?: Int;
  setup_not?: Int;
  setup_in?: Int[] | Int;
  setup_not_in?: Int[] | Int;
  setup_lt?: Int;
  setup_lte?: Int;
  setup_gt?: Int;
  setup_gte?: Int;
  reviews_every?: SessionReviewWhereInput;
  reviews_some?: SessionReviewWhereInput;
  reviews_none?: SessionReviewWhereInput;
  friends_every?: UserWhereInput;
  friends_some?: UserWhereInput;
  friends_none?: UserWhereInput;
  gamertags_every?: GamerTagWhereInput;
  gamertags_some?: GamerTagWhereInput;
  gamertags_none?: GamerTagWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface PCLauncherUpdateOneInput {
  create?: PCLauncherCreateInput;
  update?: PCLauncherUpdateDataInput;
  upsert?: PCLauncherUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PCLauncherWhereUniqueInput;
}

export type GamingTimeSlotWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PCLauncherUpdateDataInput {
  epic?: String;
  steam?: String;
  origin?: String;
  gog?: String;
  battlenet?: String;
  uplay?: String;
  bethesda?: String;
  itch?: String;
  windows?: String;
}

export type NotificationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PCLauncherUpsertNestedInput {
  update: PCLauncherUpdateDataInput;
  create: PCLauncherCreateInput;
}

export interface GamerTagUpdateInput {
  psn?: String;
  xbl?: String;
  nso?: String;
  pc?: PCLauncherUpdateOneInput;
}

export interface GamerTagUpsertWithWhereUniqueNestedInput {
  where: GamerTagWhereUniqueInput;
  update: GamerTagUpdateDataInput;
  create: GamerTagCreateInput;
}

export interface SocialMediaUpsertNestedInput {
  update: SocialMediaUpdateDataInput;
  create: SocialMediaCreateInput;
}

export interface GamerTagScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  psn?: String;
  psn_not?: String;
  psn_in?: String[] | String;
  psn_not_in?: String[] | String;
  psn_lt?: String;
  psn_lte?: String;
  psn_gt?: String;
  psn_gte?: String;
  psn_contains?: String;
  psn_not_contains?: String;
  psn_starts_with?: String;
  psn_not_starts_with?: String;
  psn_ends_with?: String;
  psn_not_ends_with?: String;
  xbl?: String;
  xbl_not?: String;
  xbl_in?: String[] | String;
  xbl_not_in?: String[] | String;
  xbl_lt?: String;
  xbl_lte?: String;
  xbl_gt?: String;
  xbl_gte?: String;
  xbl_contains?: String;
  xbl_not_contains?: String;
  xbl_starts_with?: String;
  xbl_not_starts_with?: String;
  xbl_ends_with?: String;
  xbl_not_ends_with?: String;
  nso?: String;
  nso_not?: String;
  nso_in?: String[] | String;
  nso_not_in?: String[] | String;
  nso_lt?: String;
  nso_lte?: String;
  nso_gt?: String;
  nso_gte?: String;
  nso_contains?: String;
  nso_not_contains?: String;
  nso_starts_with?: String;
  nso_not_starts_with?: String;
  nso_ends_with?: String;
  nso_not_ends_with?: String;
  AND?: GamerTagScalarWhereInput[] | GamerTagScalarWhereInput;
  OR?: GamerTagScalarWhereInput[] | GamerTagScalarWhereInput;
  NOT?: GamerTagScalarWhereInput[] | GamerTagScalarWhereInput;
}

export interface GamerRequestUpdateInput {
  user?: UserUpdateOneRequiredInput;
  occupations?: GamerRequestUpdateoccupationsInput;
  addToOccupations?: String;
  socialMedia?: SocialMediaUpdateOneRequiredInput;
}

export interface GamerTagUpdateManyWithWhereNestedInput {
  where: GamerTagScalarWhereInput;
  data: GamerTagUpdateManyDataInput;
}

export interface GamerRequestCreateoccupationsInput {
  set?: Occupations[] | Occupations;
}

export interface GamerTagUpdateManyDataInput {
  psn?: String;
  xbl?: String;
  nso?: String;
}

export interface GameIndexUpdateManyMutationInput {
  name?: String;
  tags?: GameIndexUpdatetagsInput;
}

export interface UserUpsertWithoutInvitesInput {
  update: UserUpdateWithoutInvitesDataInput;
  create: UserCreateWithoutInvitesInput;
}

export type SocialMediaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NotificationUpdateOneWithoutBookingInviteInput {
  create?: NotificationCreateWithoutBookingInviteInput;
  update?: NotificationUpdateWithoutBookingInviteDataInput;
  upsert?: NotificationUpsertWithoutBookingInviteInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: NotificationWhereUniqueInput;
}

export interface GameIndexCreateInput {
  name: String;
  tags?: GameIndexCreatetagsInput;
  game: GameCreateOneInput;
}

export interface NotificationUpdateWithoutBookingInviteDataInput {
  type?: NotificationType;
  text?: String;
  for?: UserUpdateOneRequiredInput;
  friendRequest?: FriendRequestUpdateOneWithoutNotificationInput;
  booking?: BookingUpdateOneInput;
  friend?: UserUpdateOneInput;
  viewed?: Boolean;
}

export interface NotificationUpsertWithoutFriendRequestInput {
  update: NotificationUpdateWithoutFriendRequestDataInput;
  create: NotificationCreateWithoutFriendRequestInput;
}

export interface FriendRequestUpdateOneWithoutNotificationInput {
  create?: FriendRequestCreateWithoutNotificationInput;
  update?: FriendRequestUpdateWithoutNotificationDataInput;
  upsert?: FriendRequestUpsertWithoutNotificationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FriendRequestWhereUniqueInput;
}

export interface BookingInviteUpdateWithoutNotificationDataInput {
  startTime?: DateTimeInput;
  booking?: BookingUpdateOneRequiredWithoutInvitesInput;
  to?: UserUpdateOneWithoutInvitesReceivedInput;
  from?: UserUpdateOneRequiredWithoutInvitesInput;
  sent?: Boolean;
  accepted?: Boolean;
}

export interface FriendRequestUpdateWithoutNotificationDataInput {
  to?: UserUpdateOneRequiredInput;
  from?: UserUpdateOneRequiredInput;
}

export interface UserCreateoccupationsInput {
  set?: Occupations[] | Occupations;
}

export interface FriendRequestUpsertWithoutNotificationInput {
  update: FriendRequestUpdateWithoutNotificationDataInput;
  create: FriendRequestCreateWithoutNotificationInput;
}

export interface GamingSessionCreateManyWithoutGameInput {
  create?:
    | GamingSessionCreateWithoutGameInput[]
    | GamingSessionCreateWithoutGameInput;
  connect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
}

export interface BookingUpdateOneInput {
  create?: BookingCreateInput;
  update?: BookingUpdateDataInput;
  upsert?: BookingUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BookingWhereUniqueInput;
}

export interface GamingTimeSlotCreateManyWithoutGamersInput {
  create?:
    | GamingTimeSlotCreateWithoutGamersInput[]
    | GamingTimeSlotCreateWithoutGamersInput;
  connect?: GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput;
}

export interface BookingUpdateDataInput {
  numSlots?: Int;
  numPlayers?: Int;
  players?: UserUpdateManyWithoutTimeSlotsBookedInput;
  total?: Float;
  timeslot?: GamingTimeSlotUpdateOneRequiredWithoutBookingsInput;
  invites?: BookingInviteUpdateManyWithoutBookingInput;
  cancelled?: Boolean;
}

export interface GameCreateOneWithoutSessionsInput {
  create?: GameCreateWithoutSessionsInput;
  connect?: GameWhereUniqueInput;
}

export interface BookingUpsertNestedInput {
  update: BookingUpdateDataInput;
  create: BookingCreateInput;
}

export interface UserCreateOneWithoutReviewsInput {
  create?: UserCreateWithoutReviewsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface RequirementCreateManyInput {
  create?: RequirementCreateInput[] | RequirementCreateInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface GamingTimeSlotCreateManyWithoutGamingSessionInput {
  create?:
    | GamingTimeSlotCreateWithoutGamingSessionInput[]
    | GamingTimeSlotCreateWithoutGamingSessionInput;
  connect?: GamingTimeSlotWhereUniqueInput[] | GamingTimeSlotWhereUniqueInput;
}

export interface NotificationUpsertWithoutBookingInviteInput {
  update: NotificationUpdateWithoutBookingInviteDataInput;
  create: NotificationCreateWithoutBookingInviteInput;
}

export interface BookingCreateManyWithoutPlayersInput {
  create?:
    | BookingCreateWithoutPlayersInput[]
    | BookingCreateWithoutPlayersInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
}

export interface BookingInviteUpsertWithWhereUniqueWithoutToInput {
  where: BookingInviteWhereUniqueInput;
  update: BookingInviteUpdateWithoutToDataInput;
  create: BookingInviteCreateWithoutToInput;
}

export interface BookedPlayerCreateManyWithoutTimeslotInput {
  create?:
    | BookedPlayerCreateWithoutTimeslotInput[]
    | BookedPlayerCreateWithoutTimeslotInput;
  connect?: BookedPlayerWhereUniqueInput[] | BookedPlayerWhereUniqueInput;
}

export interface BookingInviteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  sent?: Boolean;
  sent_not?: Boolean;
  accepted?: Boolean;
  accepted_not?: Boolean;
  AND?: BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput;
  OR?: BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput;
  NOT?: BookingInviteScalarWhereInput[] | BookingInviteScalarWhereInput;
}

export interface UserCreateOneWithoutInvitesReceivedInput {
  create?: UserCreateWithoutInvitesReceivedInput;
  connect?: UserWhereUniqueInput;
}

export interface BookingInviteUpdateManyWithWhereNestedInput {
  where: BookingInviteScalarWhereInput;
  data: BookingInviteUpdateManyDataInput;
}

export interface BookingCreateOneWithoutInvitesInput {
  create?: BookingCreateWithoutInvitesInput;
  connect?: BookingWhereUniqueInput;
}

export interface BookingInviteUpdateManyDataInput {
  startTime?: DateTimeInput;
  sent?: Boolean;
  accepted?: Boolean;
}

export interface BookingInviteCreateManyWithoutToInput {
  create?:
    | BookingInviteCreateWithoutToInput[]
    | BookingInviteCreateWithoutToInput;
  connect?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
}

export interface UserUpsertWithWhereUniqueWithoutTimeSlotsBookedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTimeSlotsBookedDataInput;
  create: UserCreateWithoutTimeSlotsBookedInput;
}

export interface SessionReviewCreateManyWithoutUserInput {
  create?:
    | SessionReviewCreateWithoutUserInput[]
    | SessionReviewCreateWithoutUserInput;
  connect?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
}

export interface BookingUpsertWithoutInvitesInput {
  update: BookingUpdateWithoutInvitesDataInput;
  create: BookingCreateWithoutInvitesInput;
}

export interface PCLauncherWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  epic?: String;
  epic_not?: String;
  epic_in?: String[] | String;
  epic_not_in?: String[] | String;
  epic_lt?: String;
  epic_lte?: String;
  epic_gt?: String;
  epic_gte?: String;
  epic_contains?: String;
  epic_not_contains?: String;
  epic_starts_with?: String;
  epic_not_starts_with?: String;
  epic_ends_with?: String;
  epic_not_ends_with?: String;
  steam?: String;
  steam_not?: String;
  steam_in?: String[] | String;
  steam_not_in?: String[] | String;
  steam_lt?: String;
  steam_lte?: String;
  steam_gt?: String;
  steam_gte?: String;
  steam_contains?: String;
  steam_not_contains?: String;
  steam_starts_with?: String;
  steam_not_starts_with?: String;
  steam_ends_with?: String;
  steam_not_ends_with?: String;
  origin?: String;
  origin_not?: String;
  origin_in?: String[] | String;
  origin_not_in?: String[] | String;
  origin_lt?: String;
  origin_lte?: String;
  origin_gt?: String;
  origin_gte?: String;
  origin_contains?: String;
  origin_not_contains?: String;
  origin_starts_with?: String;
  origin_not_starts_with?: String;
  origin_ends_with?: String;
  origin_not_ends_with?: String;
  gog?: String;
  gog_not?: String;
  gog_in?: String[] | String;
  gog_not_in?: String[] | String;
  gog_lt?: String;
  gog_lte?: String;
  gog_gt?: String;
  gog_gte?: String;
  gog_contains?: String;
  gog_not_contains?: String;
  gog_starts_with?: String;
  gog_not_starts_with?: String;
  gog_ends_with?: String;
  gog_not_ends_with?: String;
  battlenet?: String;
  battlenet_not?: String;
  battlenet_in?: String[] | String;
  battlenet_not_in?: String[] | String;
  battlenet_lt?: String;
  battlenet_lte?: String;
  battlenet_gt?: String;
  battlenet_gte?: String;
  battlenet_contains?: String;
  battlenet_not_contains?: String;
  battlenet_starts_with?: String;
  battlenet_not_starts_with?: String;
  battlenet_ends_with?: String;
  battlenet_not_ends_with?: String;
  uplay?: String;
  uplay_not?: String;
  uplay_in?: String[] | String;
  uplay_not_in?: String[] | String;
  uplay_lt?: String;
  uplay_lte?: String;
  uplay_gt?: String;
  uplay_gte?: String;
  uplay_contains?: String;
  uplay_not_contains?: String;
  uplay_starts_with?: String;
  uplay_not_starts_with?: String;
  uplay_ends_with?: String;
  uplay_not_ends_with?: String;
  bethesda?: String;
  bethesda_not?: String;
  bethesda_in?: String[] | String;
  bethesda_not_in?: String[] | String;
  bethesda_lt?: String;
  bethesda_lte?: String;
  bethesda_gt?: String;
  bethesda_gte?: String;
  bethesda_contains?: String;
  bethesda_not_contains?: String;
  bethesda_starts_with?: String;
  bethesda_not_starts_with?: String;
  bethesda_ends_with?: String;
  bethesda_not_ends_with?: String;
  itch?: String;
  itch_not?: String;
  itch_in?: String[] | String;
  itch_not_in?: String[] | String;
  itch_lt?: String;
  itch_lte?: String;
  itch_gt?: String;
  itch_gte?: String;
  itch_contains?: String;
  itch_not_contains?: String;
  itch_starts_with?: String;
  itch_not_starts_with?: String;
  itch_ends_with?: String;
  itch_not_ends_with?: String;
  windows?: String;
  windows_not?: String;
  windows_in?: String[] | String;
  windows_not_in?: String[] | String;
  windows_lt?: String;
  windows_lte?: String;
  windows_gt?: String;
  windows_gte?: String;
  windows_contains?: String;
  windows_not_contains?: String;
  windows_starts_with?: String;
  windows_not_starts_with?: String;
  windows_ends_with?: String;
  windows_not_ends_with?: String;
  AND?: PCLauncherWhereInput[] | PCLauncherWhereInput;
  OR?: PCLauncherWhereInput[] | PCLauncherWhereInput;
  NOT?: PCLauncherWhereInput[] | PCLauncherWhereInput;
}

export interface BookingInviteUpsertWithWhereUniqueWithoutFromInput {
  where: BookingInviteWhereUniqueInput;
  update: BookingInviteUpdateWithoutFromDataInput;
  create: BookingInviteCreateWithoutFromInput;
}

export interface SessionReviewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SessionReviewWhereInput;
  AND?:
    | SessionReviewSubscriptionWhereInput[]
    | SessionReviewSubscriptionWhereInput;
  OR?:
    | SessionReviewSubscriptionWhereInput[]
    | SessionReviewSubscriptionWhereInput;
  NOT?:
    | SessionReviewSubscriptionWhereInput[]
    | SessionReviewSubscriptionWhereInput;
}

export interface UserUpsertWithoutInvitesReceivedInput {
  update: UserUpdateWithoutInvitesReceivedDataInput;
  create: UserCreateWithoutInvitesReceivedInput;
}

export interface GamingSessionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GamingSessionWhereInput;
  AND?:
    | GamingSessionSubscriptionWhereInput[]
    | GamingSessionSubscriptionWhereInput;
  OR?:
    | GamingSessionSubscriptionWhereInput[]
    | GamingSessionSubscriptionWhereInput;
  NOT?:
    | GamingSessionSubscriptionWhereInput[]
    | GamingSessionSubscriptionWhereInput;
}

export interface BookingInviteUpsertWithWhereUniqueWithoutBookingInput {
  where: BookingInviteWhereUniqueInput;
  update: BookingInviteUpdateWithoutBookingDataInput;
  create: BookingInviteCreateWithoutBookingInput;
}

export interface BookingInviteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookingInviteWhereInput;
  AND?:
    | BookingInviteSubscriptionWhereInput[]
    | BookingInviteSubscriptionWhereInput;
  OR?:
    | BookingInviteSubscriptionWhereInput[]
    | BookingInviteSubscriptionWhereInput;
  NOT?:
    | BookingInviteSubscriptionWhereInput[]
    | BookingInviteSubscriptionWhereInput;
}

export interface BookingUpsertWithWhereUniqueWithoutPlayersInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutPlayersDataInput;
  create: BookingCreateWithoutPlayersInput;
}

export interface UserUpdateInput {
  email?: String;
  username?: String;
  password?: String;
  isGamer?: Boolean;
  occupations?: UserUpdateoccupationsInput;
  name?: String;
  aboutMe?: String;
  favoriteGames?: GameUpdateManyInput;
  sessions?: GamingSessionUpdateManyWithoutGamersInput;
  timeSlots?: GamingTimeSlotUpdateManyWithoutGamersInput;
  timeSlotsBooked?: BookingUpdateManyWithoutPlayersInput;
  invites?: BookingInviteUpdateManyWithoutFromInput;
  invitesReceived?: BookingInviteUpdateManyWithoutToInput;
  setup?: Int;
  reviews?: SessionReviewUpdateManyWithoutUserInput;
  friends?: UserUpdateManyInput;
  gamertags?: GamerTagUpdateManyInput;
}

export interface BookingScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  numSlots?: Int;
  numSlots_not?: Int;
  numSlots_in?: Int[] | Int;
  numSlots_not_in?: Int[] | Int;
  numSlots_lt?: Int;
  numSlots_lte?: Int;
  numSlots_gt?: Int;
  numSlots_gte?: Int;
  numPlayers?: Int;
  numPlayers_not?: Int;
  numPlayers_in?: Int[] | Int;
  numPlayers_not_in?: Int[] | Int;
  numPlayers_lt?: Int;
  numPlayers_lte?: Int;
  numPlayers_gt?: Int;
  numPlayers_gte?: Int;
  total?: Float;
  total_not?: Float;
  total_in?: Float[] | Float;
  total_not_in?: Float[] | Float;
  total_lt?: Float;
  total_lte?: Float;
  total_gt?: Float;
  total_gte?: Float;
  cancelled?: Boolean;
  cancelled_not?: Boolean;
  AND?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  OR?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  NOT?: BookingScalarWhereInput[] | BookingScalarWhereInput;
}

export interface SessionReviewUpdateDataInput {
  user?: UserUpdateOneRequiredWithoutReviewsInput;
  session?: GamingSessionUpdateOneRequiredWithoutReviewsInput;
  text?: String;
  rating?: Int;
}

export interface BookingUpdateManyWithWhereNestedInput {
  where: BookingScalarWhereInput;
  data: BookingUpdateManyDataInput;
}

export interface SessionReviewUpdateInput {
  user?: UserUpdateOneRequiredWithoutReviewsInput;
  session?: GamingSessionUpdateOneRequiredWithoutReviewsInput;
  text?: String;
  rating?: Int;
}

export interface BookingUpdateManyDataInput {
  numSlots?: Int;
  numPlayers?: Int;
  total?: Float;
  cancelled?: Boolean;
}

export interface PCLauncherUpdateInput {
  epic?: String;
  steam?: String;
  origin?: String;
  gog?: String;
  battlenet?: String;
  uplay?: String;
  bethesda?: String;
  itch?: String;
  windows?: String;
}

export interface UserUpsertWithWhereUniqueWithoutTimeSlotsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTimeSlotsDataInput;
  create: UserCreateWithoutTimeSlotsInput;
}

export interface GamingTimeSlotCreateInput {
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  gamingSession: GamingSessionCreateOneWithoutTimeslotsInput;
  gamers?: UserCreateManyWithoutTimeSlotsInput;
  bookings?: BookingCreateManyWithoutTimeslotInput;
  players?: BookedPlayerCreateManyWithoutTimeslotInput;
  length: Int;
  slots: Int;
}

export interface BookingUpdateManyWithoutTimeslotInput {
  create?:
    | BookingCreateWithoutTimeslotInput[]
    | BookingCreateWithoutTimeslotInput;
  delete?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  connect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  set?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  disconnect?: BookingWhereUniqueInput[] | BookingWhereUniqueInput;
  update?:
    | BookingUpdateWithWhereUniqueWithoutTimeslotInput[]
    | BookingUpdateWithWhereUniqueWithoutTimeslotInput;
  upsert?:
    | BookingUpsertWithWhereUniqueWithoutTimeslotInput[]
    | BookingUpsertWithWhereUniqueWithoutTimeslotInput;
  deleteMany?: BookingScalarWhereInput[] | BookingScalarWhereInput;
  updateMany?:
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput;
}

export interface GamingSessionIndexUpdateInput {
  title?: String;
  gamingSession?: GamingSessionUpdateOneRequiredInput;
}

export interface BookingUpdateWithWhereUniqueWithoutTimeslotInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutTimeslotDataInput;
}

export interface GamingSessionCreateInput {
  gamers?: UserCreateManyWithoutSessionsInput;
  creator: UserCreateOneInput;
  game: GameCreateOneWithoutSessionsInput;
  title: String;
  length: Int;
  price: Float;
  reviews?: SessionReviewCreateManyWithoutSessionInput;
  system: System;
  type: TypeOfGame;
  slots: Int;
  requirements?: RequirementCreateManyInput;
  discounts?: DiscountCreateManyInput;
  timeslots?: GamingTimeSlotCreateManyWithoutGamingSessionInput;
}

export interface BookingUpdateWithoutTimeslotDataInput {
  numSlots?: Int;
  numPlayers?: Int;
  players?: UserUpdateManyWithoutTimeSlotsBookedInput;
  total?: Float;
  invites?: BookingInviteUpdateManyWithoutBookingInput;
  cancelled?: Boolean;
}

export interface SocialMediaUpdateOneRequiredInput {
  create?: SocialMediaCreateInput;
  update?: SocialMediaUpdateDataInput;
  upsert?: SocialMediaUpsertNestedInput;
  connect?: SocialMediaWhereUniqueInput;
}

export interface BookingUpsertWithWhereUniqueWithoutTimeslotInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutTimeslotDataInput;
  create: BookingCreateWithoutTimeslotInput;
}

export interface GamerRequestCreateInput {
  user: UserCreateOneInput;
  occupations?: GamerRequestCreateoccupationsInput;
  addToOccupations?: String;
  socialMedia: SocialMediaCreateOneInput;
}

export interface GamingTimeSlotUpsertWithWhereUniqueWithoutGamingSessionInput {
  where: GamingTimeSlotWhereUniqueInput;
  update: GamingTimeSlotUpdateWithoutGamingSessionDataInput;
  create: GamingTimeSlotCreateWithoutGamingSessionInput;
}

export interface GameCreateOneInput {
  create?: GameCreateInput;
  connect?: GameWhereUniqueInput;
}

export interface GamingTimeSlotScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  length?: Int;
  length_not?: Int;
  length_in?: Int[] | Int;
  length_not_in?: Int[] | Int;
  length_lt?: Int;
  length_lte?: Int;
  length_gt?: Int;
  length_gte?: Int;
  slots?: Int;
  slots_not?: Int;
  slots_in?: Int[] | Int;
  slots_not_in?: Int[] | Int;
  slots_lt?: Int;
  slots_lte?: Int;
  slots_gt?: Int;
  slots_gte?: Int;
  AND?: GamingTimeSlotScalarWhereInput[] | GamingTimeSlotScalarWhereInput;
  OR?: GamingTimeSlotScalarWhereInput[] | GamingTimeSlotScalarWhereInput;
  NOT?: GamingTimeSlotScalarWhereInput[] | GamingTimeSlotScalarWhereInput;
}

export interface BookingInviteUpsertWithoutNotificationInput {
  update: BookingInviteUpdateWithoutNotificationDataInput;
  create: BookingInviteCreateWithoutNotificationInput;
}

export interface GamingTimeSlotUpdateManyWithWhereNestedInput {
  where: GamingTimeSlotScalarWhereInput;
  data: GamingTimeSlotUpdateManyDataInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface GamingTimeSlotUpdateManyDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  length?: Int;
  slots?: Int;
}

export interface UserCreateManyWithoutSessionsInput {
  create?: UserCreateWithoutSessionsInput[] | UserCreateWithoutSessionsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface GamingSessionUpsertWithWhereUniqueWithoutGamersInput {
  where: GamingSessionWhereUniqueInput;
  update: GamingSessionUpdateWithoutGamersDataInput;
  create: GamingSessionCreateWithoutGamersInput;
}

export interface SessionReviewCreateManyWithoutSessionInput {
  create?:
    | SessionReviewCreateWithoutSessionInput[]
    | SessionReviewCreateWithoutSessionInput;
  connect?: SessionReviewWhereUniqueInput[] | SessionReviewWhereUniqueInput;
}

export interface GamingSessionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  length?: Int;
  length_not?: Int;
  length_in?: Int[] | Int;
  length_not_in?: Int[] | Int;
  length_lt?: Int;
  length_lte?: Int;
  length_gt?: Int;
  length_gte?: Int;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  system?: System;
  system_not?: System;
  system_in?: System[] | System;
  system_not_in?: System[] | System;
  type?: TypeOfGame;
  type_not?: TypeOfGame;
  type_in?: TypeOfGame[] | TypeOfGame;
  type_not_in?: TypeOfGame[] | TypeOfGame;
  slots?: Int;
  slots_not?: Int;
  slots_in?: Int[] | Int;
  slots_not_in?: Int[] | Int;
  slots_lt?: Int;
  slots_lte?: Int;
  slots_gt?: Int;
  slots_gte?: Int;
  AND?: GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput;
  OR?: GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput;
  NOT?: GamingSessionScalarWhereInput[] | GamingSessionScalarWhereInput;
}

export interface DiscountCreateManyInput {
  create?: DiscountCreateInput[] | DiscountCreateInput;
}

export interface GamingSessionUpdateManyWithWhereNestedInput {
  where: GamingSessionScalarWhereInput;
  data: GamingSessionUpdateManyDataInput;
}

export interface GamingTimeSlotCreateOneWithoutBookingsInput {
  create?: GamingTimeSlotCreateWithoutBookingsInput;
  connect?: GamingTimeSlotWhereUniqueInput;
}

export interface GamingSessionUpdateManyDataInput {
  title?: String;
  length?: Int;
  price?: Float;
  system?: System;
  type?: TypeOfGame;
  slots?: Int;
}

export interface BookingInviteCreateManyWithoutFromInput {
  create?:
    | BookingInviteCreateWithoutFromInput[]
    | BookingInviteCreateWithoutFromInput;
  connect?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
}

export interface UserUpsertWithoutReviewsInput {
  update: UserUpdateWithoutReviewsDataInput;
  create: UserCreateWithoutReviewsInput;
}

export interface UserCreateOneWithoutInvitesInput {
  create?: UserCreateWithoutInvitesInput;
  connect?: UserWhereUniqueInput;
}

export interface SessionReviewUpsertWithWhereUniqueWithoutSessionInput {
  where: SessionReviewWhereUniqueInput;
  update: SessionReviewUpdateWithoutSessionDataInput;
  create: SessionReviewCreateWithoutSessionInput;
}

export interface SocialMediaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SocialMediaWhereInput;
  AND?: SocialMediaSubscriptionWhereInput[] | SocialMediaSubscriptionWhereInput;
  OR?: SocialMediaSubscriptionWhereInput[] | SocialMediaSubscriptionWhereInput;
  NOT?: SocialMediaSubscriptionWhereInput[] | SocialMediaSubscriptionWhereInput;
}

export interface GamingSessionUpsertWithoutTimeslotsInput {
  update: GamingSessionUpdateWithoutTimeslotsDataInput;
  create: GamingSessionCreateWithoutTimeslotsInput;
}

export interface GameSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GameWhereInput;
  AND?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
  OR?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
  NOT?: GameSubscriptionWhereInput[] | GameSubscriptionWhereInput;
}

export interface GamingTimeSlotUpsertWithWhereUniqueWithoutGamersInput {
  where: GamingTimeSlotWhereUniqueInput;
  update: GamingTimeSlotUpdateWithoutGamersDataInput;
  create: GamingTimeSlotCreateWithoutGamersInput;
}

export interface SocialMediaUpdateInput {
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface UserUpsertWithWhereUniqueWithoutSessionsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSessionsDataInput;
  create: UserCreateWithoutSessionsInput;
}

export interface PCLauncherUpdateManyMutationInput {
  epic?: String;
  steam?: String;
  origin?: String;
  gog?: String;
  battlenet?: String;
  uplay?: String;
  bethesda?: String;
  itch?: String;
  windows?: String;
}

export interface GamingSessionUpsertWithWhereUniqueWithoutGameInput {
  where: GamingSessionWhereUniqueInput;
  update: GamingSessionUpdateWithoutGameDataInput;
  create: GamingSessionCreateWithoutGameInput;
}

export interface GamingSessionUpdateDataInput {
  gamers?: UserUpdateManyWithoutSessionsInput;
  creator?: UserUpdateOneRequiredInput;
  game?: GameUpdateOneRequiredWithoutSessionsInput;
  title?: String;
  length?: Int;
  price?: Float;
  reviews?: SessionReviewUpdateManyWithoutSessionInput;
  system?: System;
  type?: TypeOfGame;
  slots?: Int;
  requirements?: RequirementUpdateManyInput;
  discounts?: DiscountUpdateManyInput;
  timeslots?: GamingTimeSlotUpdateManyWithoutGamingSessionInput;
}

export interface GameUpsertWithWhereUniqueNestedInput {
  where: GameWhereUniqueInput;
  update: GameUpdateDataInput;
  create: GameCreateInput;
}

export interface GameWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  sessions_every?: GamingSessionWhereInput;
  sessions_some?: GamingSessionWhereInput;
  sessions_none?: GamingSessionWhereInput;
  launcher?: Launcher;
  launcher_not?: Launcher;
  launcher_in?: Launcher[] | Launcher;
  launcher_not_in?: Launcher[] | Launcher;
  numSessions?: Int;
  numSessions_not?: Int;
  numSessions_in?: Int[] | Int;
  numSessions_not_in?: Int[] | Int;
  numSessions_lt?: Int;
  numSessions_lte?: Int;
  numSessions_gt?: Int;
  numSessions_gte?: Int;
  AND?: GameWhereInput[] | GameWhereInput;
  OR?: GameWhereInput[] | GameWhereInput;
  NOT?: GameWhereInput[] | GameWhereInput;
}

export interface GameScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  launcher?: Launcher;
  launcher_not?: Launcher;
  launcher_in?: Launcher[] | Launcher;
  launcher_not_in?: Launcher[] | Launcher;
  numSessions?: Int;
  numSessions_not?: Int;
  numSessions_in?: Int[] | Int;
  numSessions_not_in?: Int[] | Int;
  numSessions_lt?: Int;
  numSessions_lte?: Int;
  numSessions_gt?: Int;
  numSessions_gte?: Int;
  AND?: GameScalarWhereInput[] | GameScalarWhereInput;
  OR?: GameScalarWhereInput[] | GameScalarWhereInput;
  NOT?: GameScalarWhereInput[] | GameScalarWhereInput;
}

export interface GameUpdateOneRequiredInput {
  create?: GameCreateInput;
  update?: GameUpdateDataInput;
  upsert?: GameUpsertNestedInput;
  connect?: GameWhereUniqueInput;
}

export interface GameUpdateManyWithWhereNestedInput {
  where: GameScalarWhereInput;
  data: GameUpdateManyDataInput;
}

export interface NotificationUpdateWithoutFriendRequestDataInput {
  type?: NotificationType;
  text?: String;
  for?: UserUpdateOneRequiredInput;
  bookingInvite?: BookingInviteUpdateOneWithoutNotificationInput;
  booking?: BookingUpdateOneInput;
  friend?: UserUpdateOneInput;
  viewed?: Boolean;
}

export interface GameUpdateManyDataInput {
  name?: String;
  tags?: GameUpdatetagsInput;
  launcher?: Launcher;
  numSessions?: Int;
}

export interface GamingSessionCreateOneWithoutTimeslotsInput {
  create?: GamingSessionCreateWithoutTimeslotsInput;
  connect?: GamingSessionWhereUniqueInput;
}

export interface GamingTimeSlotUpdateOneRequiredWithoutPlayersInput {
  create?: GamingTimeSlotCreateWithoutPlayersInput;
  update?: GamingTimeSlotUpdateWithoutPlayersDataInput;
  upsert?: GamingTimeSlotUpsertWithoutPlayersInput;
  connect?: GamingTimeSlotWhereUniqueInput;
}

export interface UserCreateManyWithoutTimeSlotsInput {
  create?: UserCreateWithoutTimeSlotsInput[] | UserCreateWithoutTimeSlotsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface GamingTimeSlotUpdateWithoutPlayersDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  gamingSession?: GamingSessionUpdateOneRequiredWithoutTimeslotsInput;
  gamers?: UserUpdateManyWithoutTimeSlotsInput;
  bookings?: BookingUpdateManyWithoutTimeslotInput;
  length?: Int;
  slots?: Int;
}

export interface UserCreateManyWithoutTimeSlotsBookedInput {
  create?:
    | UserCreateWithoutTimeSlotsBookedInput[]
    | UserCreateWithoutTimeSlotsBookedInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface GamingTimeSlotUpsertWithoutPlayersInput {
  update: GamingTimeSlotUpdateWithoutPlayersDataInput;
  create: GamingTimeSlotCreateWithoutPlayersInput;
}

export interface PCLauncherSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PCLauncherWhereInput;
  AND?: PCLauncherSubscriptionWhereInput[] | PCLauncherSubscriptionWhereInput;
  OR?: PCLauncherSubscriptionWhereInput[] | PCLauncherSubscriptionWhereInput;
  NOT?: PCLauncherSubscriptionWhereInput[] | PCLauncherSubscriptionWhereInput;
}

export interface BookingInviteCreateWithoutNotificationInput {
  startTime: DateTimeInput;
  booking: BookingCreateOneWithoutInvitesInput;
  to?: UserCreateOneWithoutInvitesReceivedInput;
  from: UserCreateOneWithoutInvitesInput;
  sent: Boolean;
  accepted?: Boolean;
}

export interface SessionReviewCreateOneInput {
  create?: SessionReviewCreateInput;
  connect?: SessionReviewWhereUniqueInput;
}

export interface BookingInviteCreateOneWithoutNotificationInput {
  create?: BookingInviteCreateWithoutNotificationInput;
  connect?: BookingInviteWhereUniqueInput;
}

export interface GamingSessionUpdateManyMutationInput {
  title?: String;
  length?: Int;
  price?: Float;
  system?: System;
  type?: TypeOfGame;
  slots?: Int;
}

export interface BookingUpdateInput {
  numSlots?: Int;
  numPlayers?: Int;
  players?: UserUpdateManyWithoutTimeSlotsBookedInput;
  total?: Float;
  timeslot?: GamingTimeSlotUpdateOneRequiredWithoutBookingsInput;
  invites?: BookingInviteUpdateManyWithoutBookingInput;
  cancelled?: Boolean;
}

export interface GameUpdateManyMutationInput {
  name?: String;
  tags?: GameUpdatetagsInput;
  launcher?: Launcher;
  numSessions?: Int;
}

export interface BookingUpdateManyMutationInput {
  numSlots?: Int;
  numPlayers?: Int;
  total?: Float;
  cancelled?: Boolean;
}

export interface GamingSessionCreateManyWithoutGamersInput {
  create?:
    | GamingSessionCreateWithoutGamersInput[]
    | GamingSessionCreateWithoutGamersInput;
  connect?: GamingSessionWhereUniqueInput[] | GamingSessionWhereUniqueInput;
}

export interface BookingInviteCreateInput {
  startTime: DateTimeInput;
  booking: BookingCreateOneWithoutInvitesInput;
  to?: UserCreateOneWithoutInvitesReceivedInput;
  from: UserCreateOneWithoutInvitesInput;
  sent: Boolean;
  accepted?: Boolean;
  notification?: NotificationCreateOneWithoutBookingInviteInput;
}

export interface GamingSessionCreateOneWithoutReviewsInput {
  create?: GamingSessionCreateWithoutReviewsInput;
  connect?: GamingSessionWhereUniqueInput;
}

export interface BookingInviteUpdateInput {
  startTime?: DateTimeInput;
  booking?: BookingUpdateOneRequiredWithoutInvitesInput;
  to?: UserUpdateOneWithoutInvitesReceivedInput;
  from?: UserUpdateOneRequiredWithoutInvitesInput;
  sent?: Boolean;
  accepted?: Boolean;
  notification?: NotificationUpdateOneWithoutBookingInviteInput;
}

export interface NotificationCreateInput {
  type: NotificationType;
  text: String;
  for: UserCreateOneInput;
  friendRequest?: FriendRequestCreateOneWithoutNotificationInput;
  bookingInvite?: BookingInviteCreateOneWithoutNotificationInput;
  booking?: BookingCreateOneInput;
  friend?: UserCreateOneInput;
  viewed?: Boolean;
}

export interface NotificationCreateOneWithoutFriendRequestInput {
  create?: NotificationCreateWithoutFriendRequestInput;
  connect?: NotificationWhereUniqueInput;
}

export interface FriendRequestCreateInput {
  to: UserCreateOneInput;
  from: UserCreateOneInput;
  notification: NotificationCreateOneWithoutFriendRequestInput;
}

export interface DiscountUpdateManyMutationInput {
  percentage?: Int;
  threshold?: Int;
  playerOrSession?: PlayerOrSession;
}

export interface BookingInviteUpdateManyMutationInput {
  startTime?: DateTimeInput;
  sent?: Boolean;
  accepted?: Boolean;
}

export interface SocialMediaCreateInput {
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface UserIndexUpdateManyMutationInput {
  email?: String;
  username?: String;
  name?: String;
}

export interface BookingInviteCreateManyWithoutBookingInput {
  create?:
    | BookingInviteCreateWithoutBookingInput[]
    | BookingInviteCreateWithoutBookingInput;
  connect?: BookingInviteWhereUniqueInput[] | BookingInviteWhereUniqueInput;
}

export interface GameCreateInput {
  name: String;
  tags?: GameCreatetagsInput;
  sessions?: GamingSessionCreateManyWithoutGameInput;
  launcher?: Launcher;
  numSessions?: Int;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserIndexPreviousValues {
  id: ID_Output;
  email: String;
  username: String;
  name: String;
}

export interface UserIndexPreviousValuesPromise
  extends Promise<UserIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  name: () => Promise<String>;
}

export interface UserIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<UserIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBookingInvite {
  count: Int;
}

export interface AggregateBookingInvitePromise
  extends Promise<AggregateBookingInvite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingInviteSubscription
  extends Promise<AsyncIterator<AggregateBookingInvite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Game {
  id: ID_Output;
  name: String;
  tags: Tags[];
  launcher?: Launcher;
  numSessions: Int;
}

export interface GamePromise extends Promise<Game>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  tags: () => Promise<Tags[]>;
  sessions: <T = FragmentableArray<GamingSession>>(
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  launcher: () => Promise<Launcher>;
  numSessions: () => Promise<Int>;
}

export interface GameSubscription
  extends Promise<AsyncIterator<Game>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<Tags[]>>;
  sessions: <T = Promise<AsyncIterator<GamingSessionSubscription>>>(
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  launcher: () => Promise<AsyncIterator<Launcher>>;
  numSessions: () => Promise<AsyncIterator<Int>>;
}

export interface DiscountEdge {
  node: Discount;
  cursor: String;
}

export interface DiscountEdgePromise
  extends Promise<DiscountEdge>,
    Fragmentable {
  node: <T = DiscountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiscountEdgeSubscription
  extends Promise<AsyncIterator<DiscountEdge>>,
    Fragmentable {
  node: <T = DiscountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SocialMediaPreviousValues {
  id: ID_Output;
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface SocialMediaPreviousValuesPromise
  extends Promise<SocialMediaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  twitter: () => Promise<String>;
  facebook: () => Promise<String>;
  youtube: () => Promise<String>;
  instagram: () => Promise<String>;
  twitch: () => Promise<String>;
  snapchat: () => Promise<String>;
}

export interface SocialMediaPreviousValuesSubscription
  extends Promise<AsyncIterator<SocialMediaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  twitter: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  youtube: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
  twitch: () => Promise<AsyncIterator<String>>;
  snapchat: () => Promise<AsyncIterator<String>>;
}

export interface DiscountConnection {
  pageInfo: PageInfo;
  edges: DiscountEdge[];
}

export interface DiscountConnectionPromise
  extends Promise<DiscountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiscountEdge>>() => T;
  aggregate: <T = AggregateDiscountPromise>() => T;
}

export interface DiscountConnectionSubscription
  extends Promise<AsyncIterator<DiscountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiscountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiscountSubscription>() => T;
}

export interface BookingInviteEdge {
  node: BookingInvite;
  cursor: String;
}

export interface BookingInviteEdgePromise
  extends Promise<BookingInviteEdge>,
    Fragmentable {
  node: <T = BookingInvitePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookingInviteEdgeSubscription
  extends Promise<AsyncIterator<BookingInviteEdge>>,
    Fragmentable {
  node: <T = BookingInviteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserIndexConnection {
  pageInfo: PageInfo;
  edges: UserIndexEdge[];
}

export interface UserIndexConnectionPromise
  extends Promise<UserIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserIndexEdge>>() => T;
  aggregate: <T = AggregateUserIndexPromise>() => T;
}

export interface UserIndexConnectionSubscription
  extends Promise<AsyncIterator<UserIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserIndexEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserIndexSubscription>() => T;
}

export interface AggregateUserIndex {
  count: Int;
}

export interface AggregateUserIndexPromise
  extends Promise<AggregateUserIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserIndexSubscription
  extends Promise<AsyncIterator<AggregateUserIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserIndex {
  id: ID_Output;
  email: String;
  username: String;
  name: String;
}

export interface UserIndexPromise extends Promise<UserIndex>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  name: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface UserIndexSubscription
  extends Promise<AsyncIterator<UserIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface BookingInviteConnection {
  pageInfo: PageInfo;
  edges: BookingInviteEdge[];
}

export interface BookingInviteConnectionPromise
  extends Promise<BookingInviteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookingInviteEdge>>() => T;
  aggregate: <T = AggregateBookingInvitePromise>() => T;
}

export interface BookingInviteConnectionSubscription
  extends Promise<AsyncIterator<BookingInviteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingInviteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingInviteSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBooking {
  count: Int;
}

export interface AggregateBookingPromise
  extends Promise<AggregateBooking>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingSubscription
  extends Promise<AsyncIterator<AggregateBooking>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSocialMedia {
  count: Int;
}

export interface AggregateSocialMediaPromise
  extends Promise<AggregateSocialMedia>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSocialMediaSubscription
  extends Promise<AsyncIterator<AggregateSocialMedia>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookedPlayer {
  id: ID_Output;
}

export interface BookedPlayerPromise
  extends Promise<BookedPlayer>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  player: <T = UserPromise>() => T;
  timeslot: <T = GamingTimeSlotPromise>() => T;
}

export interface BookedPlayerSubscription
  extends Promise<AsyncIterator<BookedPlayer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  player: <T = UserSubscription>() => T;
  timeslot: <T = GamingTimeSlotSubscription>() => T;
}

export interface SocialMediaConnection {
  pageInfo: PageInfo;
  edges: SocialMediaEdge[];
}

export interface SocialMediaConnectionPromise
  extends Promise<SocialMediaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SocialMediaEdge>>() => T;
  aggregate: <T = AggregateSocialMediaPromise>() => T;
}

export interface SocialMediaConnectionSubscription
  extends Promise<AsyncIterator<SocialMediaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SocialMediaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSocialMediaSubscription>() => T;
}

export interface BookedPlayerSubscriptionPayload {
  mutation: MutationType;
  node: BookedPlayer;
  updatedFields: String[];
  previousValues: BookedPlayerPreviousValues;
}

export interface BookedPlayerSubscriptionPayloadPromise
  extends Promise<BookedPlayerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookedPlayerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookedPlayerPreviousValuesPromise>() => T;
}

export interface BookedPlayerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookedPlayerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookedPlayerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookedPlayerPreviousValuesSubscription>() => T;
}

export interface AggregateSessionReviewIndex {
  count: Int;
}

export interface AggregateSessionReviewIndexPromise
  extends Promise<AggregateSessionReviewIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionReviewIndexSubscription
  extends Promise<AsyncIterator<AggregateSessionReviewIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookedPlayerPreviousValues {
  id: ID_Output;
}

export interface BookedPlayerPreviousValuesPromise
  extends Promise<BookedPlayerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface BookedPlayerPreviousValuesSubscription
  extends Promise<AsyncIterator<BookedPlayerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SessionReviewIndexConnection {
  pageInfo: PageInfo;
  edges: SessionReviewIndexEdge[];
}

export interface SessionReviewIndexConnectionPromise
  extends Promise<SessionReviewIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionReviewIndexEdge>>() => T;
  aggregate: <T = AggregateSessionReviewIndexPromise>() => T;
}

export interface SessionReviewIndexConnectionSubscription
  extends Promise<AsyncIterator<SessionReviewIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SessionReviewIndexEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSessionReviewIndexSubscription>() => T;
}

export interface BookingEdge {
  node: Booking;
  cursor: String;
}

export interface BookingEdgePromise extends Promise<BookingEdge>, Fragmentable {
  node: <T = BookingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookingEdgeSubscription
  extends Promise<AsyncIterator<BookingEdge>>,
    Fragmentable {
  node: <T = BookingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SessionReviewIndex {
  id: ID_Output;
  text: String;
}

export interface SessionReviewIndexPromise
  extends Promise<SessionReviewIndex>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  sessionReview: <T = SessionReviewPromise>() => T;
}

export interface SessionReviewIndexSubscription
  extends Promise<AsyncIterator<SessionReviewIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  sessionReview: <T = SessionReviewSubscription>() => T;
}

export interface BookingSubscriptionPayload {
  mutation: MutationType;
  node: Booking;
  updatedFields: String[];
  previousValues: BookingPreviousValues;
}

export interface BookingSubscriptionPayloadPromise
  extends Promise<BookingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingPreviousValuesPromise>() => T;
}

export interface BookingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingPreviousValuesSubscription>() => T;
}

export interface SessionReviewEdge {
  node: SessionReview;
  cursor: String;
}

export interface SessionReviewEdgePromise
  extends Promise<SessionReviewEdge>,
    Fragmentable {
  node: <T = SessionReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionReviewEdgeSubscription
  extends Promise<AsyncIterator<SessionReviewEdge>>,
    Fragmentable {
  node: <T = SessionReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookingPreviousValues {
  id: ID_Output;
  numSlots: Int;
  numPlayers: Int;
  total: Float;
  cancelled?: Boolean;
}

export interface BookingPreviousValuesPromise
  extends Promise<BookingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  numSlots: () => Promise<Int>;
  numPlayers: () => Promise<Int>;
  total: () => Promise<Float>;
  cancelled: () => Promise<Boolean>;
}

export interface BookingPreviousValuesSubscription
  extends Promise<AsyncIterator<BookingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  numSlots: () => Promise<AsyncIterator<Int>>;
  numPlayers: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Float>>;
  cancelled: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateRequirement {
  count: Int;
}

export interface AggregateRequirementPromise
  extends Promise<AggregateRequirement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRequirementSubscription
  extends Promise<AsyncIterator<AggregateRequirement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingConnection {
  pageInfo: PageInfo;
  edges: BookingEdge[];
}

export interface BookingConnectionPromise
  extends Promise<BookingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookingEdge>>() => T;
  aggregate: <T = AggregateBookingPromise>() => T;
}

export interface BookingConnectionSubscription
  extends Promise<AsyncIterator<BookingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingSubscription>() => T;
}

export interface RequirementConnection {
  pageInfo: PageInfo;
  edges: RequirementEdge[];
}

export interface RequirementConnectionPromise
  extends Promise<RequirementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RequirementEdge>>() => T;
  aggregate: <T = AggregateRequirementPromise>() => T;
}

export interface RequirementConnectionSubscription
  extends Promise<AsyncIterator<RequirementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RequirementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRequirementSubscription>() => T;
}

export interface BookingInviteSubscriptionPayload {
  mutation: MutationType;
  node: BookingInvite;
  updatedFields: String[];
  previousValues: BookingInvitePreviousValues;
}

export interface BookingInviteSubscriptionPayloadPromise
  extends Promise<BookingInviteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookingInvitePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingInvitePreviousValuesPromise>() => T;
}

export interface BookingInviteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingInviteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingInviteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingInvitePreviousValuesSubscription>() => T;
}

export interface PCLauncherEdge {
  node: PCLauncher;
  cursor: String;
}

export interface PCLauncherEdgePromise
  extends Promise<PCLauncherEdge>,
    Fragmentable {
  node: <T = PCLauncherPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PCLauncherEdgeSubscription
  extends Promise<AsyncIterator<PCLauncherEdge>>,
    Fragmentable {
  node: <T = PCLauncherSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookingInvitePreviousValues {
  id: ID_Output;
  startTime: DateTimeOutput;
  sent: Boolean;
  accepted?: Boolean;
}

export interface BookingInvitePreviousValuesPromise
  extends Promise<BookingInvitePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  sent: () => Promise<Boolean>;
  accepted: () => Promise<Boolean>;
}

export interface BookingInvitePreviousValuesSubscription
  extends Promise<AsyncIterator<BookingInvitePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  sent: () => Promise<AsyncIterator<Boolean>>;
  accepted: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateNotification {
  count: Int;
}

export interface AggregateNotificationPromise
  extends Promise<AggregateNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateBookedPlayer {
  count: Int;
}

export interface AggregateBookedPlayerPromise
  extends Promise<AggregateBookedPlayer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookedPlayerSubscription
  extends Promise<AsyncIterator<AggregateBookedPlayer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationConnection {
  pageInfo: PageInfo;
  edges: NotificationEdge[];
}

export interface NotificationConnectionPromise
  extends Promise<NotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotificationEdge>>() => T;
  aggregate: <T = AggregateNotificationPromise>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface DiscountSubscriptionPayload {
  mutation: MutationType;
  node: Discount;
  updatedFields: String[];
  previousValues: DiscountPreviousValues;
}

export interface DiscountSubscriptionPayloadPromise
  extends Promise<DiscountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiscountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiscountPreviousValuesPromise>() => T;
}

export interface DiscountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiscountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiscountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiscountPreviousValuesSubscription>() => T;
}

export interface GamingTimeSlotEdge {
  node: GamingTimeSlot;
  cursor: String;
}

export interface GamingTimeSlotEdgePromise
  extends Promise<GamingTimeSlotEdge>,
    Fragmentable {
  node: <T = GamingTimeSlotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamingTimeSlotEdgeSubscription
  extends Promise<AsyncIterator<GamingTimeSlotEdge>>,
    Fragmentable {
  node: <T = GamingTimeSlotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DiscountPreviousValues {
  percentage: Int;
  threshold: Int;
  playerOrSession: PlayerOrSession;
}

export interface DiscountPreviousValuesPromise
  extends Promise<DiscountPreviousValues>,
    Fragmentable {
  percentage: () => Promise<Int>;
  threshold: () => Promise<Int>;
  playerOrSession: () => Promise<PlayerOrSession>;
}

export interface DiscountPreviousValuesSubscription
  extends Promise<AsyncIterator<DiscountPreviousValues>>,
    Fragmentable {
  percentage: () => Promise<AsyncIterator<Int>>;
  threshold: () => Promise<AsyncIterator<Int>>;
  playerOrSession: () => Promise<AsyncIterator<PlayerOrSession>>;
}

export interface AggregateGamingSessionIndex {
  count: Int;
}

export interface AggregateGamingSessionIndexPromise
  extends Promise<AggregateGamingSessionIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamingSessionIndexSubscription
  extends Promise<AsyncIterator<AggregateGamingSessionIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookedPlayerEdge {
  node: BookedPlayer;
  cursor: String;
}

export interface BookedPlayerEdgePromise
  extends Promise<BookedPlayerEdge>,
    Fragmentable {
  node: <T = BookedPlayerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookedPlayerEdgeSubscription
  extends Promise<AsyncIterator<BookedPlayerEdge>>,
    Fragmentable {
  node: <T = BookedPlayerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamingSessionIndexConnection {
  pageInfo: PageInfo;
  edges: GamingSessionIndexEdge[];
}

export interface GamingSessionIndexConnectionPromise
  extends Promise<GamingSessionIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamingSessionIndexEdge>>() => T;
  aggregate: <T = AggregateGamingSessionIndexPromise>() => T;
}

export interface GamingSessionIndexConnectionSubscription
  extends Promise<AsyncIterator<GamingSessionIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<GamingSessionIndexEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateGamingSessionIndexSubscription>() => T;
}

export interface FriendRequestSubscriptionPayload {
  mutation: MutationType;
  node: FriendRequest;
  updatedFields: String[];
  previousValues: FriendRequestPreviousValues;
}

export interface FriendRequestSubscriptionPayloadPromise
  extends Promise<FriendRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FriendRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FriendRequestPreviousValuesPromise>() => T;
}

export interface FriendRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FriendRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FriendRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FriendRequestPreviousValuesSubscription>() => T;
}

export interface AggregateGamingSession {
  count: Int;
}

export interface AggregateGamingSessionPromise
  extends Promise<AggregateGamingSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamingSessionSubscription
  extends Promise<AsyncIterator<AggregateGamingSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FriendRequestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface FriendRequestPreviousValuesPromise
  extends Promise<FriendRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FriendRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<FriendRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GamingSessionConnection {
  pageInfo: PageInfo;
  edges: GamingSessionEdge[];
}

export interface GamingSessionConnectionPromise
  extends Promise<GamingSessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamingSessionEdge>>() => T;
  aggregate: <T = AggregateGamingSessionPromise>() => T;
}

export interface GamingSessionConnectionSubscription
  extends Promise<AsyncIterator<GamingSessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GamingSessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGamingSessionSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface GamerTagEdge {
  node: GamerTag;
  cursor: String;
}

export interface GamerTagEdgePromise
  extends Promise<GamerTagEdge>,
    Fragmentable {
  node: <T = GamerTagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamerTagEdgeSubscription
  extends Promise<AsyncIterator<GamerTagEdge>>,
    Fragmentable {
  node: <T = GamerTagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GameSubscriptionPayload {
  mutation: MutationType;
  node: Game;
  updatedFields: String[];
  previousValues: GamePreviousValues;
}

export interface GameSubscriptionPayloadPromise
  extends Promise<GameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamePreviousValuesPromise>() => T;
}

export interface GameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamePreviousValuesSubscription>() => T;
}

export interface AggregateGamerRequest {
  count: Int;
}

export interface AggregateGamerRequestPromise
  extends Promise<AggregateGamerRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamerRequestSubscription
  extends Promise<AsyncIterator<AggregateGamerRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamePreviousValues {
  id: ID_Output;
  name: String;
  tags: Tags[];
  launcher?: Launcher;
  numSessions: Int;
}

export interface GamePreviousValuesPromise
  extends Promise<GamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  tags: () => Promise<Tags[]>;
  launcher: () => Promise<Launcher>;
  numSessions: () => Promise<Int>;
}

export interface GamePreviousValuesSubscription
  extends Promise<AsyncIterator<GamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<Tags[]>>;
  launcher: () => Promise<AsyncIterator<Launcher>>;
  numSessions: () => Promise<AsyncIterator<Int>>;
}

export interface GamerRequestConnection {
  pageInfo: PageInfo;
  edges: GamerRequestEdge[];
}

export interface GamerRequestConnectionPromise
  extends Promise<GamerRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamerRequestEdge>>() => T;
  aggregate: <T = AggregateGamerRequestPromise>() => T;
}

export interface GamerRequestConnectionSubscription
  extends Promise<AsyncIterator<GamerRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GamerRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGamerRequestSubscription>() => T;
}

export interface BookedPlayerConnection {
  pageInfo: PageInfo;
  edges: BookedPlayerEdge[];
}

export interface BookedPlayerConnectionPromise
  extends Promise<BookedPlayerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookedPlayerEdge>>() => T;
  aggregate: <T = AggregateBookedPlayerPromise>() => T;
}

export interface BookedPlayerConnectionSubscription
  extends Promise<AsyncIterator<BookedPlayerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookedPlayerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookedPlayerSubscription>() => T;
}

export interface GamerRequest {
  id: ID_Output;
  occupations: Occupations[];
  addToOccupations?: String;
}

export interface GamerRequestPromise
  extends Promise<GamerRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  occupations: () => Promise<Occupations[]>;
  addToOccupations: () => Promise<String>;
  socialMedia: <T = SocialMediaPromise>() => T;
}

export interface GamerRequestSubscription
  extends Promise<AsyncIterator<GamerRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  addToOccupations: () => Promise<AsyncIterator<String>>;
  socialMedia: <T = SocialMediaSubscription>() => T;
}

export interface GameIndexSubscriptionPayload {
  mutation: MutationType;
  node: GameIndex;
  updatedFields: String[];
  previousValues: GameIndexPreviousValues;
}

export interface GameIndexSubscriptionPayloadPromise
  extends Promise<GameIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GameIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GameIndexPreviousValuesPromise>() => T;
}

export interface GameIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GameIndexPreviousValuesSubscription>() => T;
}

export interface GameIndexEdge {
  node: GameIndex;
  cursor: String;
}

export interface GameIndexEdgePromise
  extends Promise<GameIndexEdge>,
    Fragmentable {
  node: <T = GameIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameIndexEdgeSubscription
  extends Promise<AsyncIterator<GameIndexEdge>>,
    Fragmentable {
  node: <T = GameIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GameIndexPreviousValues {
  id: ID_Output;
  name: String;
  tags: String[];
}

export interface GameIndexPreviousValuesPromise
  extends Promise<GameIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  tags: () => Promise<String[]>;
}

export interface GameIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<GameIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  username: String;
  password: String;
  isGamer: Boolean;
  occupations: Occupations[];
  name: String;
  aboutMe?: String;
  setup?: Int;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  isGamer: () => Promise<Boolean>;
  occupations: () => Promise<Occupations[]>;
  name: () => Promise<String>;
  aboutMe: () => Promise<String>;
  setup: () => Promise<Int>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  isGamer: () => Promise<AsyncIterator<Boolean>>;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  name: () => Promise<AsyncIterator<String>>;
  aboutMe: () => Promise<AsyncIterator<String>>;
  setup: () => Promise<AsyncIterator<Int>>;
}

export interface PCLauncher {
  id: ID_Output;
  epic?: String;
  steam?: String;
  origin?: String;
  gog?: String;
  battlenet?: String;
  uplay?: String;
  bethesda?: String;
  itch?: String;
  windows?: String;
}

export interface PCLauncherPromise extends Promise<PCLauncher>, Fragmentable {
  id: () => Promise<ID_Output>;
  epic: () => Promise<String>;
  steam: () => Promise<String>;
  origin: () => Promise<String>;
  gog: () => Promise<String>;
  battlenet: () => Promise<String>;
  uplay: () => Promise<String>;
  bethesda: () => Promise<String>;
  itch: () => Promise<String>;
  windows: () => Promise<String>;
}

export interface PCLauncherSubscription
  extends Promise<AsyncIterator<PCLauncher>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  epic: () => Promise<AsyncIterator<String>>;
  steam: () => Promise<AsyncIterator<String>>;
  origin: () => Promise<AsyncIterator<String>>;
  gog: () => Promise<AsyncIterator<String>>;
  battlenet: () => Promise<AsyncIterator<String>>;
  uplay: () => Promise<AsyncIterator<String>>;
  bethesda: () => Promise<AsyncIterator<String>>;
  itch: () => Promise<AsyncIterator<String>>;
  windows: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGame {
  count: Int;
}

export interface AggregateGamePromise
  extends Promise<AggregateGame>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameSubscription
  extends Promise<AsyncIterator<AggregateGame>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamerRequestSubscriptionPayload {
  mutation: MutationType;
  node: GamerRequest;
  updatedFields: String[];
  previousValues: GamerRequestPreviousValues;
}

export interface GamerRequestSubscriptionPayloadPromise
  extends Promise<GamerRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamerRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamerRequestPreviousValuesPromise>() => T;
}

export interface GamerRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamerRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamerRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamerRequestPreviousValuesSubscription>() => T;
}

export interface GameConnection {
  pageInfo: PageInfo;
  edges: GameEdge[];
}

export interface GameConnectionPromise
  extends Promise<GameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameEdge>>() => T;
  aggregate: <T = AggregateGamePromise>() => T;
}

export interface GameConnectionSubscription
  extends Promise<AsyncIterator<GameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameSubscription>() => T;
}

export interface GamerRequestPreviousValues {
  id: ID_Output;
  occupations: Occupations[];
  addToOccupations?: String;
}

export interface GamerRequestPreviousValuesPromise
  extends Promise<GamerRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  occupations: () => Promise<Occupations[]>;
  addToOccupations: () => Promise<String>;
}

export interface GamerRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<GamerRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  addToOccupations: () => Promise<AsyncIterator<String>>;
}

export interface FriendRequestEdge {
  node: FriendRequest;
  cursor: String;
}

export interface FriendRequestEdgePromise
  extends Promise<FriendRequestEdge>,
    Fragmentable {
  node: <T = FriendRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FriendRequestEdgeSubscription
  extends Promise<AsyncIterator<FriendRequestEdge>>,
    Fragmentable {
  node: <T = FriendRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamerTag {
  id: ID_Output;
  psn?: String;
  xbl?: String;
  nso?: String;
}

export interface GamerTagPromise extends Promise<GamerTag>, Fragmentable {
  id: () => Promise<ID_Output>;
  psn: () => Promise<String>;
  xbl: () => Promise<String>;
  nso: () => Promise<String>;
  pc: <T = PCLauncherPromise>() => T;
}

export interface GamerTagSubscription
  extends Promise<AsyncIterator<GamerTag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  psn: () => Promise<AsyncIterator<String>>;
  xbl: () => Promise<AsyncIterator<String>>;
  nso: () => Promise<AsyncIterator<String>>;
  pc: <T = PCLauncherSubscription>() => T;
}

export interface AggregateDiscount {
  count: Int;
}

export interface AggregateDiscountPromise
  extends Promise<AggregateDiscount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiscountSubscription
  extends Promise<AsyncIterator<AggregateDiscount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamerTagSubscriptionPayload {
  mutation: MutationType;
  node: GamerTag;
  updatedFields: String[];
  previousValues: GamerTagPreviousValues;
}

export interface GamerTagSubscriptionPayloadPromise
  extends Promise<GamerTagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamerTagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamerTagPreviousValuesPromise>() => T;
}

export interface GamerTagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamerTagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamerTagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamerTagPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email: String;
  username: String;
  password: String;
  isGamer: Boolean;
  occupations: Occupations[];
  name: String;
  aboutMe?: String;
  setup?: Int;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  isGamer: () => Promise<Boolean>;
  occupations: () => Promise<Occupations[]>;
  name: () => Promise<String>;
  aboutMe: () => Promise<String>;
  favoriteGames: <T = FragmentableArray<Game>>(
    args?: {
      where?: GameWhereInput;
      orderBy?: GameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sessions: <T = FragmentableArray<GamingSession>>(
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  timeSlots: <T = FragmentableArray<GamingTimeSlot>>(
    args?: {
      where?: GamingTimeSlotWhereInput;
      orderBy?: GamingTimeSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  timeSlotsBooked: <T = FragmentableArray<Booking>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invites: <T = FragmentableArray<BookingInvite>>(
    args?: {
      where?: BookingInviteWhereInput;
      orderBy?: BookingInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invitesReceived: <T = FragmentableArray<BookingInvite>>(
    args?: {
      where?: BookingInviteWhereInput;
      orderBy?: BookingInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  setup: () => Promise<Int>;
  reviews: <T = FragmentableArray<SessionReview>>(
    args?: {
      where?: SessionReviewWhereInput;
      orderBy?: SessionReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  friends: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  gamertags: <T = FragmentableArray<GamerTag>>(
    args?: {
      where?: GamerTagWhereInput;
      orderBy?: GamerTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  isGamer: () => Promise<AsyncIterator<Boolean>>;
  occupations: () => Promise<AsyncIterator<Occupations[]>>;
  name: () => Promise<AsyncIterator<String>>;
  aboutMe: () => Promise<AsyncIterator<String>>;
  favoriteGames: <T = Promise<AsyncIterator<GameSubscription>>>(
    args?: {
      where?: GameWhereInput;
      orderBy?: GameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sessions: <T = Promise<AsyncIterator<GamingSessionSubscription>>>(
    args?: {
      where?: GamingSessionWhereInput;
      orderBy?: GamingSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  timeSlots: <T = Promise<AsyncIterator<GamingTimeSlotSubscription>>>(
    args?: {
      where?: GamingTimeSlotWhereInput;
      orderBy?: GamingTimeSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  timeSlotsBooked: <T = Promise<AsyncIterator<BookingSubscription>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invites: <T = Promise<AsyncIterator<BookingInviteSubscription>>>(
    args?: {
      where?: BookingInviteWhereInput;
      orderBy?: BookingInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invitesReceived: <T = Promise<AsyncIterator<BookingInviteSubscription>>>(
    args?: {
      where?: BookingInviteWhereInput;
      orderBy?: BookingInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  setup: () => Promise<AsyncIterator<Int>>;
  reviews: <T = Promise<AsyncIterator<SessionReviewSubscription>>>(
    args?: {
      where?: SessionReviewWhereInput;
      orderBy?: SessionReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  friends: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  gamertags: <T = Promise<AsyncIterator<GamerTagSubscription>>>(
    args?: {
      where?: GamerTagWhereInput;
      orderBy?: GamerTagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GamerTagPreviousValues {
  id: ID_Output;
  psn?: String;
  xbl?: String;
  nso?: String;
}

export interface GamerTagPreviousValuesPromise
  extends Promise<GamerTagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  psn: () => Promise<String>;
  xbl: () => Promise<String>;
  nso: () => Promise<String>;
}

export interface GamerTagPreviousValuesSubscription
  extends Promise<AsyncIterator<GamerTagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  psn: () => Promise<AsyncIterator<String>>;
  xbl: () => Promise<AsyncIterator<String>>;
  nso: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserIndexSubscriptionPayload {
  mutation: MutationType;
  node: UserIndex;
  updatedFields: String[];
  previousValues: UserIndexPreviousValues;
}

export interface UserIndexSubscriptionPayloadPromise
  extends Promise<UserIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserIndexPreviousValuesPromise>() => T;
}

export interface UserIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserIndexPreviousValuesSubscription>() => T;
}

export interface GamingSessionSubscriptionPayload {
  mutation: MutationType;
  node: GamingSession;
  updatedFields: String[];
  previousValues: GamingSessionPreviousValues;
}

export interface GamingSessionSubscriptionPayloadPromise
  extends Promise<GamingSessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamingSessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamingSessionPreviousValuesPromise>() => T;
}

export interface GamingSessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamingSessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamingSessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamingSessionPreviousValuesSubscription>() => T;
}

export interface GamingSession {
  id: ID_Output;
  title: String;
  length: Int;
  price: Float;
  system: System;
  type: TypeOfGame;
  slots: Int;
}

export interface GamingSessionPromise
  extends Promise<GamingSession>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  gamers: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  creator: <T = UserPromise>() => T;
  game: <T = GamePromise>() => T;
  title: () => Promise<String>;
  length: () => Promise<Int>;
  price: () => Promise<Float>;
  reviews: <T = FragmentableArray<SessionReview>>(
    args?: {
      where?: SessionReviewWhereInput;
      orderBy?: SessionReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  system: () => Promise<System>;
  type: () => Promise<TypeOfGame>;
  slots: () => Promise<Int>;
  requirements: <T = FragmentableArray<Requirement>>(
    args?: {
      where?: RequirementWhereInput;
      orderBy?: RequirementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  discounts: <T = FragmentableArray<Discount>>(
    args?: {
      where?: DiscountWhereInput;
      orderBy?: DiscountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  timeslots: <T = FragmentableArray<GamingTimeSlot>>(
    args?: {
      where?: GamingTimeSlotWhereInput;
      orderBy?: GamingTimeSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GamingSessionSubscription
  extends Promise<AsyncIterator<GamingSession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  gamers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  creator: <T = UserSubscription>() => T;
  game: <T = GameSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  length: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  reviews: <T = Promise<AsyncIterator<SessionReviewSubscription>>>(
    args?: {
      where?: SessionReviewWhereInput;
      orderBy?: SessionReviewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  system: () => Promise<AsyncIterator<System>>;
  type: () => Promise<AsyncIterator<TypeOfGame>>;
  slots: () => Promise<AsyncIterator<Int>>;
  requirements: <T = Promise<AsyncIterator<RequirementSubscription>>>(
    args?: {
      where?: RequirementWhereInput;
      orderBy?: RequirementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  discounts: <T = Promise<AsyncIterator<DiscountSubscription>>>(
    args?: {
      where?: DiscountWhereInput;
      orderBy?: DiscountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  timeslots: <T = Promise<AsyncIterator<GamingTimeSlotSubscription>>>(
    args?: {
      where?: GamingTimeSlotWhereInput;
      orderBy?: GamingTimeSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GamingSessionPreviousValues {
  id: ID_Output;
  title: String;
  length: Int;
  price: Float;
  system: System;
  type: TypeOfGame;
  slots: Int;
}

export interface GamingSessionPreviousValuesPromise
  extends Promise<GamingSessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  length: () => Promise<Int>;
  price: () => Promise<Float>;
  system: () => Promise<System>;
  type: () => Promise<TypeOfGame>;
  slots: () => Promise<Int>;
}

export interface GamingSessionPreviousValuesSubscription
  extends Promise<AsyncIterator<GamingSessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  length: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  system: () => Promise<AsyncIterator<System>>;
  type: () => Promise<AsyncIterator<TypeOfGame>>;
  slots: () => Promise<AsyncIterator<Int>>;
}

export interface SessionReviewConnection {
  pageInfo: PageInfo;
  edges: SessionReviewEdge[];
}

export interface SessionReviewConnectionPromise
  extends Promise<SessionReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionReviewEdge>>() => T;
  aggregate: <T = AggregateSessionReviewPromise>() => T;
}

export interface SessionReviewConnectionSubscription
  extends Promise<AsyncIterator<SessionReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionReviewSubscription>() => T;
}

export interface SessionReview {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
  rating: Int;
}

export interface SessionReviewPromise
  extends Promise<SessionReview>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  session: <T = GamingSessionPromise>() => T;
  text: () => Promise<String>;
  rating: () => Promise<Int>;
}

export interface SessionReviewSubscription
  extends Promise<AsyncIterator<SessionReview>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  session: <T = GamingSessionSubscription>() => T;
  text: () => Promise<AsyncIterator<String>>;
  rating: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePCLauncher {
  count: Int;
}

export interface AggregatePCLauncherPromise
  extends Promise<AggregatePCLauncher>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePCLauncherSubscription
  extends Promise<AsyncIterator<AggregatePCLauncher>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamingSessionIndexSubscriptionPayload {
  mutation: MutationType;
  node: GamingSessionIndex;
  updatedFields: String[];
  previousValues: GamingSessionIndexPreviousValues;
}

export interface GamingSessionIndexSubscriptionPayloadPromise
  extends Promise<GamingSessionIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamingSessionIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamingSessionIndexPreviousValuesPromise>() => T;
}

export interface GamingSessionIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamingSessionIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamingSessionIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamingSessionIndexPreviousValuesSubscription>() => T;
}

export interface NotificationEdge {
  node: Notification;
  cursor: String;
}

export interface NotificationEdgePromise
  extends Promise<NotificationEdge>,
    Fragmentable {
  node: <T = NotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdge>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamingSessionIndexPreviousValues {
  id: ID_Output;
  title: String;
}

export interface GamingSessionIndexPreviousValuesPromise
  extends Promise<GamingSessionIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

export interface GamingSessionIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<GamingSessionIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface GamingTimeSlotConnection {
  pageInfo: PageInfo;
  edges: GamingTimeSlotEdge[];
}

export interface GamingTimeSlotConnectionPromise
  extends Promise<GamingTimeSlotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamingTimeSlotEdge>>() => T;
  aggregate: <T = AggregateGamingTimeSlotPromise>() => T;
}

export interface GamingTimeSlotConnectionSubscription
  extends Promise<AsyncIterator<GamingTimeSlotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GamingTimeSlotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGamingTimeSlotSubscription>() => T;
}

export interface FriendRequest {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface FriendRequestPromise
  extends Promise<FriendRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  to: <T = UserPromise>() => T;
  from: <T = UserPromise>() => T;
  notification: <T = NotificationPromise>() => T;
}

export interface FriendRequestSubscription
  extends Promise<AsyncIterator<FriendRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  to: <T = UserSubscription>() => T;
  from: <T = UserSubscription>() => T;
  notification: <T = NotificationSubscription>() => T;
}

export interface GamingSessionIndex {
  id: ID_Output;
  title: String;
}

export interface GamingSessionIndexPromise
  extends Promise<GamingSessionIndex>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  gamingSession: <T = GamingSessionPromise>() => T;
}

export interface GamingSessionIndexSubscription
  extends Promise<AsyncIterator<GamingSessionIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  gamingSession: <T = GamingSessionSubscription>() => T;
}

export interface GamingTimeSlotSubscriptionPayload {
  mutation: MutationType;
  node: GamingTimeSlot;
  updatedFields: String[];
  previousValues: GamingTimeSlotPreviousValues;
}

export interface GamingTimeSlotSubscriptionPayloadPromise
  extends Promise<GamingTimeSlotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamingTimeSlotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamingTimeSlotPreviousValuesPromise>() => T;
}

export interface GamingTimeSlotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GamingTimeSlotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GamingTimeSlotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamingTimeSlotPreviousValuesSubscription>() => T;
}

export interface AggregateGamerTag {
  count: Int;
}

export interface AggregateGamerTagPromise
  extends Promise<AggregateGamerTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamerTagSubscription
  extends Promise<AsyncIterator<AggregateGamerTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GamingTimeSlotPreviousValues {
  id: ID_Output;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  length: Int;
  slots: Int;
}

export interface GamingTimeSlotPreviousValuesPromise
  extends Promise<GamingTimeSlotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  length: () => Promise<Int>;
  slots: () => Promise<Int>;
}

export interface GamingTimeSlotPreviousValuesSubscription
  extends Promise<AsyncIterator<GamingTimeSlotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  length: () => Promise<AsyncIterator<Int>>;
  slots: () => Promise<AsyncIterator<Int>>;
}

export interface GamerRequestEdge {
  node: GamerRequest;
  cursor: String;
}

export interface GamerRequestEdgePromise
  extends Promise<GamerRequestEdge>,
    Fragmentable {
  node: <T = GamerRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamerRequestEdgeSubscription
  extends Promise<AsyncIterator<GamerRequestEdge>>,
    Fragmentable {
  node: <T = GamerRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Notification {
  id: ID_Output;
  type: NotificationType;
  text: String;
  viewed: Boolean;
}

export interface NotificationPromise
  extends Promise<Notification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<NotificationType>;
  text: () => Promise<String>;
  for: <T = UserPromise>() => T;
  friendRequest: <T = FriendRequestPromise>() => T;
  bookingInvite: <T = BookingInvitePromise>() => T;
  booking: <T = BookingPromise>() => T;
  friend: <T = UserPromise>() => T;
  viewed: () => Promise<Boolean>;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<Notification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<NotificationType>>;
  text: () => Promise<AsyncIterator<String>>;
  for: <T = UserSubscription>() => T;
  friendRequest: <T = FriendRequestSubscription>() => T;
  bookingInvite: <T = BookingInviteSubscription>() => T;
  booking: <T = BookingSubscription>() => T;
  friend: <T = UserSubscription>() => T;
  viewed: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateGameIndex {
  count: Int;
}

export interface AggregateGameIndexPromise
  extends Promise<AggregateGameIndex>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameIndexSubscription
  extends Promise<AsyncIterator<AggregateGameIndex>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationSubscriptionPayload {
  mutation: MutationType;
  node: Notification;
  updatedFields: String[];
  previousValues: NotificationPreviousValues;
}

export interface NotificationSubscriptionPayloadPromise
  extends Promise<NotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValuesPromise>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface GameIndex {
  id: ID_Output;
  name: String;
  tags: String[];
}

export interface GameIndexPromise extends Promise<GameIndex>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  tags: () => Promise<String[]>;
  game: <T = GamePromise>() => T;
}

export interface GameIndexSubscription
  extends Promise<AsyncIterator<GameIndex>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  game: <T = GameSubscription>() => T;
}

export interface NotificationPreviousValues {
  id: ID_Output;
  type: NotificationType;
  text: String;
  viewed: Boolean;
}

export interface NotificationPreviousValuesPromise
  extends Promise<NotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<NotificationType>;
  text: () => Promise<String>;
  viewed: () => Promise<Boolean>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<NotificationType>>;
  text: () => Promise<AsyncIterator<String>>;
  viewed: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateFriendRequest {
  count: Int;
}

export interface AggregateFriendRequestPromise
  extends Promise<AggregateFriendRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFriendRequestSubscription
  extends Promise<AsyncIterator<AggregateFriendRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingInvite {
  id: ID_Output;
  startTime: DateTimeOutput;
  sent: Boolean;
  accepted?: Boolean;
}

export interface BookingInvitePromise
  extends Promise<BookingInvite>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  booking: <T = BookingPromise>() => T;
  to: <T = UserPromise>() => T;
  from: <T = UserPromise>() => T;
  sent: () => Promise<Boolean>;
  accepted: () => Promise<Boolean>;
  notification: <T = NotificationPromise>() => T;
}

export interface BookingInviteSubscription
  extends Promise<AsyncIterator<BookingInvite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  booking: <T = BookingSubscription>() => T;
  to: <T = UserSubscription>() => T;
  from: <T = UserSubscription>() => T;
  sent: () => Promise<AsyncIterator<Boolean>>;
  accepted: () => Promise<AsyncIterator<Boolean>>;
  notification: <T = NotificationSubscription>() => T;
}

export interface UserIndexEdge {
  node: UserIndex;
  cursor: String;
}

export interface UserIndexEdgePromise
  extends Promise<UserIndexEdge>,
    Fragmentable {
  node: <T = UserIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserIndexEdgeSubscription
  extends Promise<AsyncIterator<UserIndexEdge>>,
    Fragmentable {
  node: <T = UserIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PCLauncherSubscriptionPayload {
  mutation: MutationType;
  node: PCLauncher;
  updatedFields: String[];
  previousValues: PCLauncherPreviousValues;
}

export interface PCLauncherSubscriptionPayloadPromise
  extends Promise<PCLauncherSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PCLauncherPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PCLauncherPreviousValuesPromise>() => T;
}

export interface PCLauncherSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PCLauncherSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PCLauncherSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PCLauncherPreviousValuesSubscription>() => T;
}

export interface SocialMediaEdge {
  node: SocialMedia;
  cursor: String;
}

export interface SocialMediaEdgePromise
  extends Promise<SocialMediaEdge>,
    Fragmentable {
  node: <T = SocialMediaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SocialMediaEdgeSubscription
  extends Promise<AsyncIterator<SocialMediaEdge>>,
    Fragmentable {
  node: <T = SocialMediaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PCLauncherPreviousValues {
  id: ID_Output;
  epic?: String;
  steam?: String;
  origin?: String;
  gog?: String;
  battlenet?: String;
  uplay?: String;
  bethesda?: String;
  itch?: String;
  windows?: String;
}

export interface PCLauncherPreviousValuesPromise
  extends Promise<PCLauncherPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  epic: () => Promise<String>;
  steam: () => Promise<String>;
  origin: () => Promise<String>;
  gog: () => Promise<String>;
  battlenet: () => Promise<String>;
  uplay: () => Promise<String>;
  bethesda: () => Promise<String>;
  itch: () => Promise<String>;
  windows: () => Promise<String>;
}

export interface PCLauncherPreviousValuesSubscription
  extends Promise<AsyncIterator<PCLauncherPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  epic: () => Promise<AsyncIterator<String>>;
  steam: () => Promise<AsyncIterator<String>>;
  origin: () => Promise<AsyncIterator<String>>;
  gog: () => Promise<AsyncIterator<String>>;
  battlenet: () => Promise<AsyncIterator<String>>;
  uplay: () => Promise<AsyncIterator<String>>;
  bethesda: () => Promise<AsyncIterator<String>>;
  itch: () => Promise<AsyncIterator<String>>;
  windows: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSessionReview {
  count: Int;
}

export interface AggregateSessionReviewPromise
  extends Promise<AggregateSessionReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionReviewSubscription
  extends Promise<AsyncIterator<AggregateSessionReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Booking {
  id: ID_Output;
  numSlots: Int;
  numPlayers: Int;
  total: Float;
  cancelled?: Boolean;
}

export interface BookingPromise extends Promise<Booking>, Fragmentable {
  id: () => Promise<ID_Output>;
  numSlots: () => Promise<Int>;
  numPlayers: () => Promise<Int>;
  players: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  total: () => Promise<Float>;
  timeslot: <T = GamingTimeSlotPromise>() => T;
  invites: <T = FragmentableArray<BookingInvite>>(
    args?: {
      where?: BookingInviteWhereInput;
      orderBy?: BookingInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cancelled: () => Promise<Boolean>;
}

export interface BookingSubscription
  extends Promise<AsyncIterator<Booking>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  numSlots: () => Promise<AsyncIterator<Int>>;
  numPlayers: () => Promise<AsyncIterator<Int>>;
  players: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  total: () => Promise<AsyncIterator<Float>>;
  timeslot: <T = GamingTimeSlotSubscription>() => T;
  invites: <T = Promise<AsyncIterator<BookingInviteSubscription>>>(
    args?: {
      where?: BookingInviteWhereInput;
      orderBy?: BookingInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cancelled: () => Promise<AsyncIterator<Boolean>>;
}

export interface PCLauncherConnection {
  pageInfo: PageInfo;
  edges: PCLauncherEdge[];
}

export interface PCLauncherConnectionPromise
  extends Promise<PCLauncherConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PCLauncherEdge>>() => T;
  aggregate: <T = AggregatePCLauncherPromise>() => T;
}

export interface PCLauncherConnectionSubscription
  extends Promise<AsyncIterator<PCLauncherConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PCLauncherEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePCLauncherSubscription>() => T;
}

export interface RequirementSubscriptionPayload {
  mutation: MutationType;
  node: Requirement;
  updatedFields: String[];
  previousValues: RequirementPreviousValues;
}

export interface RequirementSubscriptionPayloadPromise
  extends Promise<RequirementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RequirementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RequirementPreviousValuesPromise>() => T;
}

export interface RequirementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RequirementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RequirementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RequirementPreviousValuesSubscription>() => T;
}

export interface GamingSessionIndexEdge {
  node: GamingSessionIndex;
  cursor: String;
}

export interface GamingSessionIndexEdgePromise
  extends Promise<GamingSessionIndexEdge>,
    Fragmentable {
  node: <T = GamingSessionIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamingSessionIndexEdgeSubscription
  extends Promise<AsyncIterator<GamingSessionIndexEdge>>,
    Fragmentable {
  node: <T = GamingSessionIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RequirementPreviousValues {
  msg: String;
}

export interface RequirementPreviousValuesPromise
  extends Promise<RequirementPreviousValues>,
    Fragmentable {
  msg: () => Promise<String>;
}

export interface RequirementPreviousValuesSubscription
  extends Promise<AsyncIterator<RequirementPreviousValues>>,
    Fragmentable {
  msg: () => Promise<AsyncIterator<String>>;
}

export interface GamerTagConnection {
  pageInfo: PageInfo;
  edges: GamerTagEdge[];
}

export interface GamerTagConnectionPromise
  extends Promise<GamerTagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GamerTagEdge>>() => T;
  aggregate: <T = AggregateGamerTagPromise>() => T;
}

export interface GamerTagConnectionSubscription
  extends Promise<AsyncIterator<GamerTagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GamerTagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGamerTagSubscription>() => T;
}

export interface GamingTimeSlot {
  id: ID_Output;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  length: Int;
  slots: Int;
}

export interface GamingTimeSlotPromise
  extends Promise<GamingTimeSlot>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  gamingSession: <T = GamingSessionPromise>() => T;
  gamers: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bookings: <T = FragmentableArray<Booking>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  players: <T = FragmentableArray<BookedPlayer>>(
    args?: {
      where?: BookedPlayerWhereInput;
      orderBy?: BookedPlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  length: () => Promise<Int>;
  slots: () => Promise<Int>;
}

export interface GamingTimeSlotSubscription
  extends Promise<AsyncIterator<GamingTimeSlot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  gamingSession: <T = GamingSessionSubscription>() => T;
  gamers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(
    args?: {
      where?: BookingWhereInput;
      orderBy?: BookingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  players: <T = Promise<AsyncIterator<BookedPlayerSubscription>>>(
    args?: {
      where?: BookedPlayerWhereInput;
      orderBy?: BookedPlayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  length: () => Promise<AsyncIterator<Int>>;
  slots: () => Promise<AsyncIterator<Int>>;
}

export interface GameIndexConnection {
  pageInfo: PageInfo;
  edges: GameIndexEdge[];
}

export interface GameIndexConnectionPromise
  extends Promise<GameIndexConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameIndexEdge>>() => T;
  aggregate: <T = AggregateGameIndexPromise>() => T;
}

export interface GameIndexConnectionSubscription
  extends Promise<AsyncIterator<GameIndexConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameIndexEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameIndexSubscription>() => T;
}

export interface SessionReviewSubscriptionPayload {
  mutation: MutationType;
  node: SessionReview;
  updatedFields: String[];
  previousValues: SessionReviewPreviousValues;
}

export interface SessionReviewSubscriptionPayloadPromise
  extends Promise<SessionReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionReviewPreviousValuesPromise>() => T;
}

export interface SessionReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionReviewPreviousValuesSubscription>() => T;
}

export interface FriendRequestConnection {
  pageInfo: PageInfo;
  edges: FriendRequestEdge[];
}

export interface FriendRequestConnectionPromise
  extends Promise<FriendRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FriendRequestEdge>>() => T;
  aggregate: <T = AggregateFriendRequestPromise>() => T;
}

export interface FriendRequestConnectionSubscription
  extends Promise<AsyncIterator<FriendRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FriendRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFriendRequestSubscription>() => T;
}

export interface SessionReviewPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  text: String;
  rating: Int;
}

export interface SessionReviewPreviousValuesPromise
  extends Promise<SessionReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  rating: () => Promise<Int>;
}

export interface SessionReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  rating: () => Promise<AsyncIterator<Int>>;
}

export interface SessionReviewIndexEdge {
  node: SessionReviewIndex;
  cursor: String;
}

export interface SessionReviewIndexEdgePromise
  extends Promise<SessionReviewIndexEdge>,
    Fragmentable {
  node: <T = SessionReviewIndexPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionReviewIndexEdgeSubscription
  extends Promise<AsyncIterator<SessionReviewIndexEdge>>,
    Fragmentable {
  node: <T = SessionReviewIndexSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Discount {
  percentage: Int;
  threshold: Int;
  playerOrSession: PlayerOrSession;
}

export interface DiscountPromise extends Promise<Discount>, Fragmentable {
  percentage: () => Promise<Int>;
  threshold: () => Promise<Int>;
  playerOrSession: () => Promise<PlayerOrSession>;
}

export interface DiscountSubscription
  extends Promise<AsyncIterator<Discount>>,
    Fragmentable {
  percentage: () => Promise<AsyncIterator<Int>>;
  threshold: () => Promise<AsyncIterator<Int>>;
  playerOrSession: () => Promise<AsyncIterator<PlayerOrSession>>;
}

export interface AggregateGamingTimeSlot {
  count: Int;
}

export interface AggregateGamingTimeSlotPromise
  extends Promise<AggregateGamingTimeSlot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGamingTimeSlotSubscription
  extends Promise<AsyncIterator<AggregateGamingTimeSlot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SocialMedia {
  id: ID_Output;
  twitter?: String;
  facebook?: String;
  youtube?: String;
  instagram?: String;
  twitch?: String;
  snapchat?: String;
}

export interface SocialMediaPromise extends Promise<SocialMedia>, Fragmentable {
  id: () => Promise<ID_Output>;
  twitter: () => Promise<String>;
  facebook: () => Promise<String>;
  youtube: () => Promise<String>;
  instagram: () => Promise<String>;
  twitch: () => Promise<String>;
  snapchat: () => Promise<String>;
}

export interface SocialMediaSubscription
  extends Promise<AsyncIterator<SocialMedia>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  twitter: () => Promise<AsyncIterator<String>>;
  facebook: () => Promise<AsyncIterator<String>>;
  youtube: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
  twitch: () => Promise<AsyncIterator<String>>;
  snapchat: () => Promise<AsyncIterator<String>>;
}

export interface SocialMediaSubscriptionPayload {
  mutation: MutationType;
  node: SocialMedia;
  updatedFields: String[];
  previousValues: SocialMediaPreviousValues;
}

export interface SocialMediaSubscriptionPayloadPromise
  extends Promise<SocialMediaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SocialMediaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SocialMediaPreviousValuesPromise>() => T;
}

export interface SocialMediaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SocialMediaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SocialMediaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SocialMediaPreviousValuesSubscription>() => T;
}

export interface Requirement {
  msg: String;
}

export interface RequirementPromise extends Promise<Requirement>, Fragmentable {
  msg: () => Promise<String>;
}

export interface RequirementSubscription
  extends Promise<AsyncIterator<Requirement>>,
    Fragmentable {
  msg: () => Promise<AsyncIterator<String>>;
}

export interface SessionReviewIndexPreviousValues {
  id: ID_Output;
  text: String;
}

export interface SessionReviewIndexPreviousValuesPromise
  extends Promise<SessionReviewIndexPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
}

export interface SessionReviewIndexPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionReviewIndexPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface SessionReviewIndexSubscriptionPayload {
  mutation: MutationType;
  node: SessionReviewIndex;
  updatedFields: String[];
  previousValues: SessionReviewIndexPreviousValues;
}

export interface SessionReviewIndexSubscriptionPayloadPromise
  extends Promise<SessionReviewIndexSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionReviewIndexPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionReviewIndexPreviousValuesPromise>() => T;
}

export interface SessionReviewIndexSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionReviewIndexSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionReviewIndexSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionReviewIndexPreviousValuesSubscription>() => T;
}

export interface GameEdge {
  node: Game;
  cursor: String;
}

export interface GameEdgePromise extends Promise<GameEdge>, Fragmentable {
  node: <T = GamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameEdgeSubscription
  extends Promise<AsyncIterator<GameEdge>>,
    Fragmentable {
  node: <T = GameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GamingSessionEdge {
  node: GamingSession;
  cursor: String;
}

export interface GamingSessionEdgePromise
  extends Promise<GamingSessionEdge>,
    Fragmentable {
  node: <T = GamingSessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GamingSessionEdgeSubscription
  extends Promise<AsyncIterator<GamingSessionEdge>>,
    Fragmentable {
  node: <T = GamingSessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RequirementEdge {
  node: Requirement;
  cursor: String;
}

export interface RequirementEdgePromise
  extends Promise<RequirementEdge>,
    Fragmentable {
  node: <T = RequirementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RequirementEdgeSubscription
  extends Promise<AsyncIterator<RequirementEdge>>,
    Fragmentable {
  node: <T = RequirementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserIndex",
    embedded: false
  },
  {
    name: "BookedPlayer",
    embedded: false
  },
  {
    name: "GamerTag",
    embedded: false
  },
  {
    name: "PCLauncher",
    embedded: false
  },
  {
    name: "GamerRequest",
    embedded: false
  },
  {
    name: "SocialMedia",
    embedded: false
  },
  {
    name: "Game",
    embedded: false
  },
  {
    name: "GameIndex",
    embedded: false
  },
  {
    name: "Launcher",
    embedded: false
  },
  {
    name: "GamingSession",
    embedded: false
  },
  {
    name: "GamingSessionIndex",
    embedded: false
  },
  {
    name: "Requirement",
    embedded: false
  },
  {
    name: "Discount",
    embedded: false
  },
  {
    name: "SessionReview",
    embedded: false
  },
  {
    name: "SessionReviewIndex",
    embedded: false
  },
  {
    name: "GamingTimeSlot",
    embedded: false
  },
  {
    name: "Occupations",
    embedded: false
  },
  {
    name: "Tags",
    embedded: false
  },
  {
    name: "System",
    embedded: false
  },
  {
    name: "TypeOfGame",
    embedded: false
  },
  {
    name: "PlayerOrSession",
    embedded: false
  },
  {
    name: "Booking",
    embedded: false
  },
  {
    name: "BookingInvite",
    embedded: false
  },
  {
    name: "FriendRequest",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "NotificationType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
